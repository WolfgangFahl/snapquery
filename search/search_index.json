{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"snapquery API Documentation","text":""},{"location":"#snapquery.basequeryview","title":"<code>basequeryview</code>","text":"<p>Created on 2024-06-23 @author: wf</p>"},{"location":"#snapquery.basequeryview.BaseQueryView","title":"<code>BaseQueryView</code>","text":"<p>general search for queries</p> Source code in <code>snapquery/basequeryview.py</code> <pre><code>class BaseQueryView:\n    \"\"\"\n    general search for queries\n    \"\"\"\n\n    def __init__(self, solution: WebSolution, debug: bool = False):\n        self.solution = solution\n        self.nqm = self.solution.nqm\n        self.debug = debug\n        self.setup_ui()\n\n    def setup_ui(self):\n        \"\"\"\n        setup my user interface\n        \"\"\"\n        with ui.row().classes(\"w-full items-baseline\") as self.header_row:\n            ui.label(\"Available Queries\").classes(\"text-xl\")\n            ui.label(\"select a query to view and execute\").classes(\"text-slate-400\")\n\n        self.query_selector = QuerySelector(self.solution, self.on_search_change)\n        self.search_result_row = ui.row()\n        self.debouncer = DebouncerUI(parent=self.search_result_row, delay=0.65, debug=self.debug)\n\n        ui.timer(0.0, self.on_search_change, once=True)\n\n    async def on_search_change(self, _args=None):\n        \"\"\"\n        react on changes in the search input\n        \"\"\"\n        await self.debouncer.debounce(self.perform_search)\n\n    async def perform_search(self):\n        \"\"\"\n        Performs the search based on the current QuerySelector values.\n        \"\"\"\n        try:\n            qn = self.query_selector.qn\n            name_like = f\"{qn.name}%\"\n            namespace_like = f\"{qn.namespace}%\"\n            domain_like = f\"{qn.domain}%\"\n            sql_query = \"\"\"SELECT \n            * \n            FROM NamedQuery \n            WHERE \n                name LIKE ? \n                AND namespace LIKE ? \n                AND domain LIKE ?\"\"\"\n            self.q_lod = self.nqm.sql_db.query(sql_query, (name_like, namespace_like, domain_like))\n            self.show_lod(self.q_lod)\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def show_lod(self, q_lod: List):\n        \"\"\"\n        show the given list of dicts\n        \"\"\"\n        self.search_result_row.clear()\n        view_lod = []\n        for record in self.q_lod:\n            nq = NamedQuery.from_record(record)\n            vr = nq.as_viewrecord()\n            view_lod.append(vr)\n        with self.search_result_row:\n            self.search_result_grid = ListOfDictsGrid()\n            ui.notify(f\"found {len(q_lod)} queries\")\n            self.search_result_grid.load_lod(view_lod)\n        self.search_result_row.update()\n</code></pre>"},{"location":"#snapquery.basequeryview.BaseQueryView.on_search_change","title":"<code>on_search_change(_args=None)</code>  <code>async</code>","text":"<p>react on changes in the search input</p> Source code in <code>snapquery/basequeryview.py</code> <pre><code>async def on_search_change(self, _args=None):\n    \"\"\"\n    react on changes in the search input\n    \"\"\"\n    await self.debouncer.debounce(self.perform_search)\n</code></pre>"},{"location":"#snapquery.basequeryview.BaseQueryView.perform_search","title":"<code>perform_search()</code>  <code>async</code>","text":"<p>Performs the search based on the current QuerySelector values.</p> Source code in <code>snapquery/basequeryview.py</code> <pre><code>async def perform_search(self):\n    \"\"\"\n    Performs the search based on the current QuerySelector values.\n    \"\"\"\n    try:\n        qn = self.query_selector.qn\n        name_like = f\"{qn.name}%\"\n        namespace_like = f\"{qn.namespace}%\"\n        domain_like = f\"{qn.domain}%\"\n        sql_query = \"\"\"SELECT \n        * \n        FROM NamedQuery \n        WHERE \n            name LIKE ? \n            AND namespace LIKE ? \n            AND domain LIKE ?\"\"\"\n        self.q_lod = self.nqm.sql_db.query(sql_query, (name_like, namespace_like, domain_like))\n        self.show_lod(self.q_lod)\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#snapquery.basequeryview.BaseQueryView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>setup my user interface</p> Source code in <code>snapquery/basequeryview.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    setup my user interface\n    \"\"\"\n    with ui.row().classes(\"w-full items-baseline\") as self.header_row:\n        ui.label(\"Available Queries\").classes(\"text-xl\")\n        ui.label(\"select a query to view and execute\").classes(\"text-slate-400\")\n\n    self.query_selector = QuerySelector(self.solution, self.on_search_change)\n    self.search_result_row = ui.row()\n    self.debouncer = DebouncerUI(parent=self.search_result_row, delay=0.65, debug=self.debug)\n\n    ui.timer(0.0, self.on_search_change, once=True)\n</code></pre>"},{"location":"#snapquery.basequeryview.BaseQueryView.show_lod","title":"<code>show_lod(q_lod)</code>","text":"<p>show the given list of dicts</p> Source code in <code>snapquery/basequeryview.py</code> <pre><code>def show_lod(self, q_lod: List):\n    \"\"\"\n    show the given list of dicts\n    \"\"\"\n    self.search_result_row.clear()\n    view_lod = []\n    for record in self.q_lod:\n        nq = NamedQuery.from_record(record)\n        vr = nq.as_viewrecord()\n        view_lod.append(vr)\n    with self.search_result_row:\n        self.search_result_grid = ListOfDictsGrid()\n        ui.notify(f\"found {len(q_lod)} queries\")\n        self.search_result_grid.load_lod(view_lod)\n    self.search_result_row.update()\n</code></pre>"},{"location":"#snapquery.ceurws","title":"<code>ceurws</code>","text":"<p>Created on 2024-07-02 @author: wf</p>"},{"location":"#snapquery.ceurws.CeurWSQueries","title":"<code>CeurWSQueries</code>","text":"<p>A class to handle the extraction and management of CEUR-WS queries.</p> Source code in <code>snapquery/ceurws.py</code> <pre><code>class CeurWSQueries:\n    \"\"\"\n    A class to handle the extraction and management of CEUR-WS queries.\n    \"\"\"\n\n    def __init__(self, nqm: NamedQueryManager, debug: bool = False):\n        \"\"\"\n        Constructor\n        Args:\n            nqm (NamedQueryManager): The NamedQueryManager to use for storing queries.\n            debug (bool): Enable debug output. Defaults to False.\n        \"\"\"\n        self.nqm = nqm\n        self.named_query_set = NamedQuerySet(\n            domain=\"ceur-ws.org\",\n            namespace=\"challenge\",\n            target_graph_name=\"wikidata\",\n        )\n        self.debug = debug\n        self.wiki_id = \"cr\"\n        self.wiki_client = WikiClient.ofWikiId(self.wiki_id)\n        self.smw = SMWClient(self.wiki_client.getSite())\n\n    def extract_queries(self, limit: int = None):\n        \"\"\"\n        Extract all queries from the CEUR-WS challenge wiki.\n        Args:\n            limit (int, optional): Limit the number of queries fetched. Defaults to None.\n        \"\"\"\n        if limit:\n            limitclause = f\"|limit={limit}\"\n        else:\n            limitclause = \"\"\n        ask_query = f\"\"\"{{{{#ask: [[Concept:Query]]\n|mainlabel=Query\n|?Query id=id\n|?Query name=name\n|?Query title=title\n|?Query tryiturl=tryiturl\n|?Query wdqsurl=wdqsurl\n|?Query scholia=scholia\n|?Query relevance=relevance\n|?Query task=task\n|?Query sparql=sparql\n{limitclause}\n|sort=Query task,Query id\n|order=ascending\n}}}}\"\"\"\n        query_results = self.smw.query(ask_query)\n        for _page_title, query_data in query_results.items():\n            # Extract values into local variables for easier debugging\n            name = query_data.get(\"name\")\n            url = query_data.get(\"wdqsurl\")\n            if not url:\n                continue\n            title = query_data.get(\"title\")\n            description = query_data.get(\"task\")\n            sparql = query_data.get(\"sparql\")\n            if url:\n                url = f\"https://w.wiki/{url}\"\n            tryiturl = query_data.get(\"tryiturl\")\n            if tryiturl:\n                tryiturl = f\"https://qlever.cs.uni-freiburg.de/wikidata/{tryiturl}\"\n            comment = f\"qlever tryit url: {tryiturl}\" if tryiturl else None\n            named_query = NamedQuery(\n                domain=self.named_query_set.domain,\n                namespace=self.named_query_set.namespace,\n                name=name,\n                url=url,\n                title=title,\n                description=description,\n                sparql=sparql,\n                comment=comment,\n            )\n            self.named_query_set.queries.append(named_query)\n\n            if self.debug:\n                print(\".\", end=\"\", flush=True)\n                if len(self.named_query_set.queries) % 80 == 0:\n                    print(f\"{len(self.named_query_set.queries)}\")\n\n        if self.debug:\n            print(f\"\\nFound {len(self.named_query_set.queries)} CEUR-WS challenge queries\")\n\n    def save_to_json(self, file_path: str = \"/tmp/ceurws-queries.json\"):\n        \"\"\"\n        Save the NamedQueryList to a JSON file.\n        Args:\n            file_path (str): Path to the JSON file.\n        \"\"\"\n        self.named_query_set.save_to_json_file(file_path, indent=2)\n\n    def store_queries(self):\n        \"\"\"\n        Store the named queries into the database.\n        \"\"\"\n        self.nqm.store_named_query_list(self.named_query_set)\n</code></pre>"},{"location":"#snapquery.ceurws.CeurWSQueries.__init__","title":"<code>__init__(nqm, debug=False)</code>","text":"<p>Constructor Args:     nqm (NamedQueryManager): The NamedQueryManager to use for storing queries.     debug (bool): Enable debug output. Defaults to False.</p> Source code in <code>snapquery/ceurws.py</code> <pre><code>def __init__(self, nqm: NamedQueryManager, debug: bool = False):\n    \"\"\"\n    Constructor\n    Args:\n        nqm (NamedQueryManager): The NamedQueryManager to use for storing queries.\n        debug (bool): Enable debug output. Defaults to False.\n    \"\"\"\n    self.nqm = nqm\n    self.named_query_set = NamedQuerySet(\n        domain=\"ceur-ws.org\",\n        namespace=\"challenge\",\n        target_graph_name=\"wikidata\",\n    )\n    self.debug = debug\n    self.wiki_id = \"cr\"\n    self.wiki_client = WikiClient.ofWikiId(self.wiki_id)\n    self.smw = SMWClient(self.wiki_client.getSite())\n</code></pre>"},{"location":"#snapquery.ceurws.CeurWSQueries.extract_queries","title":"<code>extract_queries(limit=None)</code>","text":"<p>Extract all queries from the CEUR-WS challenge wiki. Args:     limit (int, optional): Limit the number of queries fetched. Defaults to None.</p> Source code in <code>snapquery/ceurws.py</code> <pre><code>    def extract_queries(self, limit: int = None):\n        \"\"\"\n        Extract all queries from the CEUR-WS challenge wiki.\n        Args:\n            limit (int, optional): Limit the number of queries fetched. Defaults to None.\n        \"\"\"\n        if limit:\n            limitclause = f\"|limit={limit}\"\n        else:\n            limitclause = \"\"\n        ask_query = f\"\"\"{{{{#ask: [[Concept:Query]]\n|mainlabel=Query\n|?Query id=id\n|?Query name=name\n|?Query title=title\n|?Query tryiturl=tryiturl\n|?Query wdqsurl=wdqsurl\n|?Query scholia=scholia\n|?Query relevance=relevance\n|?Query task=task\n|?Query sparql=sparql\n{limitclause}\n|sort=Query task,Query id\n|order=ascending\n}}}}\"\"\"\n        query_results = self.smw.query(ask_query)\n        for _page_title, query_data in query_results.items():\n            # Extract values into local variables for easier debugging\n            name = query_data.get(\"name\")\n            url = query_data.get(\"wdqsurl\")\n            if not url:\n                continue\n            title = query_data.get(\"title\")\n            description = query_data.get(\"task\")\n            sparql = query_data.get(\"sparql\")\n            if url:\n                url = f\"https://w.wiki/{url}\"\n            tryiturl = query_data.get(\"tryiturl\")\n            if tryiturl:\n                tryiturl = f\"https://qlever.cs.uni-freiburg.de/wikidata/{tryiturl}\"\n            comment = f\"qlever tryit url: {tryiturl}\" if tryiturl else None\n            named_query = NamedQuery(\n                domain=self.named_query_set.domain,\n                namespace=self.named_query_set.namespace,\n                name=name,\n                url=url,\n                title=title,\n                description=description,\n                sparql=sparql,\n                comment=comment,\n            )\n            self.named_query_set.queries.append(named_query)\n\n            if self.debug:\n                print(\".\", end=\"\", flush=True)\n                if len(self.named_query_set.queries) % 80 == 0:\n                    print(f\"{len(self.named_query_set.queries)}\")\n\n        if self.debug:\n            print(f\"\\nFound {len(self.named_query_set.queries)} CEUR-WS challenge queries\")\n</code></pre>"},{"location":"#snapquery.ceurws.CeurWSQueries.save_to_json","title":"<code>save_to_json(file_path='/tmp/ceurws-queries.json')</code>","text":"<p>Save the NamedQueryList to a JSON file. Args:     file_path (str): Path to the JSON file.</p> Source code in <code>snapquery/ceurws.py</code> <pre><code>def save_to_json(self, file_path: str = \"/tmp/ceurws-queries.json\"):\n    \"\"\"\n    Save the NamedQueryList to a JSON file.\n    Args:\n        file_path (str): Path to the JSON file.\n    \"\"\"\n    self.named_query_set.save_to_json_file(file_path, indent=2)\n</code></pre>"},{"location":"#snapquery.ceurws.CeurWSQueries.store_queries","title":"<code>store_queries()</code>","text":"<p>Store the named queries into the database.</p> Source code in <code>snapquery/ceurws.py</code> <pre><code>def store_queries(self):\n    \"\"\"\n    Store the named queries into the database.\n    \"\"\"\n    self.nqm.store_named_query_list(self.named_query_set)\n</code></pre>"},{"location":"#snapquery.dblp","title":"<code>dblp</code>","text":"<p>Created on 2024-06-07</p> <p>@author: wf</p>"},{"location":"#snapquery.dblp.DblpPersonLookup","title":"<code>DblpPersonLookup</code>","text":"<p>lookup persons in dblp</p> Source code in <code>snapquery/dblp.py</code> <pre><code>class DblpPersonLookup:\n    \"\"\"\n    lookup persons in dblp\n    \"\"\"\n\n    def __init__(self, nqm: NamedQueryManager, endpoint_name: str = \"dblp\"):\n        self.nqm = nqm\n        self.endpoint_name = endpoint_name\n\n    def search(self, name_part: str, limit: int = 10) -&gt; List[Person]:\n        \"\"\"\n        search persons by part of their name using a SPARQL query with regex.\n\n        Args:\n            name_part (str): The part of the name to search for.\n            limit (int): The maximum number of results to return.\n\n        Returns:\n            List[Person]: A list of Person objects.\n        \"\"\"\n        named_query = NamedQuery(\n            domain=\"dblp.org\",\n            namespace=\"pid-lookup\",\n            name=\"person-by-name-part\",\n            title=\"Lookup persons with a name matching a pattern\",\n            description=\"Search for persons by matching part of their name using regex\",\n            sparql=\"\"\"# snapquery person lookup by name part\nSELECT DISTINCT \n  ?author \n  ?label \n  ?dblp_author_id \n  ?wikidata_id \n  ?orcid_id\nWHERE {\n  ?author a dblp:Person.\n  ?author rdfs:label ?label.\n  FILTER regex(?label, \"{{ name_regex }}\", \"i\")\n  OPTIONAL {\n    ?author datacite:hasIdentifier ?identifier.\n    ?identifier datacite:usesIdentifierScheme datacite:dblp.\n    ?identifier litre:hasLiteralValue ?dblp_author_id.\n  }\n  OPTIONAL {\n    ?author datacite:hasIdentifier ?identifier2.\n    ?identifier2 datacite:usesIdentifierScheme datacite:wikidata.\n    ?identifier2 litre:hasLiteralValue ?wikidata_id.\n  }\n  OPTIONAL {\n    ?author datacite:hasIdentifier ?identifier3.\n    ?identifier3 datacite:usesIdentifierScheme datacite:orcid.\n    ?identifier3 litre:hasLiteralValue ?orcid_id.\n  }\n}\n            \"\"\",\n        )\n        params_dict = {\"name_regex\": name_part}\n\n        person_lod, _stats = self.nqm.execute_query(\n            named_query=named_query,\n            params_dict=params_dict,\n            endpoint_name=self.endpoint_name,\n            limit=limit,\n            with_stats=False,\n        )\n        persons = []\n        for pr in person_lod:\n            person = Person(\n                label=pr.get(\"label\"),\n                wikidata_id=pr.get(\"wikidata_id\"),\n                dblp_author_id=pr.get(\"dblp_author_id\"),\n                orcid_id=pr.get(\"orcid_id\"),\n            )\n            person.parse_label()\n            persons.append(person)\n        return persons\n</code></pre>"},{"location":"#snapquery.dblp.DblpPersonLookup.search","title":"<code>search(name_part, limit=10)</code>","text":"<p>search persons by part of their name using a SPARQL query with regex.</p> <p>Parameters:</p> Name Type Description Default <code>name_part</code> <code>str</code> <p>The part of the name to search for.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>List[Person]</code> <p>List[Person]: A list of Person objects.</p> Source code in <code>snapquery/dblp.py</code> <pre><code>    def search(self, name_part: str, limit: int = 10) -&gt; List[Person]:\n        \"\"\"\n        search persons by part of their name using a SPARQL query with regex.\n\n        Args:\n            name_part (str): The part of the name to search for.\n            limit (int): The maximum number of results to return.\n\n        Returns:\n            List[Person]: A list of Person objects.\n        \"\"\"\n        named_query = NamedQuery(\n            domain=\"dblp.org\",\n            namespace=\"pid-lookup\",\n            name=\"person-by-name-part\",\n            title=\"Lookup persons with a name matching a pattern\",\n            description=\"Search for persons by matching part of their name using regex\",\n            sparql=\"\"\"# snapquery person lookup by name part\nSELECT DISTINCT \n  ?author \n  ?label \n  ?dblp_author_id \n  ?wikidata_id \n  ?orcid_id\nWHERE {\n  ?author a dblp:Person.\n  ?author rdfs:label ?label.\n  FILTER regex(?label, \"{{ name_regex }}\", \"i\")\n  OPTIONAL {\n    ?author datacite:hasIdentifier ?identifier.\n    ?identifier datacite:usesIdentifierScheme datacite:dblp.\n    ?identifier litre:hasLiteralValue ?dblp_author_id.\n  }\n  OPTIONAL {\n    ?author datacite:hasIdentifier ?identifier2.\n    ?identifier2 datacite:usesIdentifierScheme datacite:wikidata.\n    ?identifier2 litre:hasLiteralValue ?wikidata_id.\n  }\n  OPTIONAL {\n    ?author datacite:hasIdentifier ?identifier3.\n    ?identifier3 datacite:usesIdentifierScheme datacite:orcid.\n    ?identifier3 litre:hasLiteralValue ?orcid_id.\n  }\n}\n            \"\"\",\n        )\n        params_dict = {\"name_regex\": name_part}\n\n        person_lod, _stats = self.nqm.execute_query(\n            named_query=named_query,\n            params_dict=params_dict,\n            endpoint_name=self.endpoint_name,\n            limit=limit,\n            with_stats=False,\n        )\n        persons = []\n        for pr in person_lod:\n            person = Person(\n                label=pr.get(\"label\"),\n                wikidata_id=pr.get(\"wikidata_id\"),\n                dblp_author_id=pr.get(\"dblp_author_id\"),\n                orcid_id=pr.get(\"orcid_id\"),\n            )\n            person.parse_label()\n            persons.append(person)\n        return persons\n</code></pre>"},{"location":"#snapquery.endpoint","title":"<code>endpoint</code>","text":"<p>Created on 29.06.2024 @author: wf</p>"},{"location":"#snapquery.endpoint.Endpoint","title":"<code>Endpoint</code>","text":"<p>A query endpoint for SPARQL, SQL or other storage systems</p> Source code in <code>snapquery/endpoint.py</code> <pre><code>@lod_storable\nclass Endpoint:\n    \"\"\"\n    A query endpoint for SPARQL, SQL or other storage systems\n    \"\"\"\n\n    name: str\n    endpoint: str\n    lang: str = \"sparql\"\n    website: Optional[str] = None\n    database: Optional[str] = None\n    method: Optional[str] = \"POST\"\n    prefixes: Optional[str] = None\n    auth: Optional[str] = None\n    user: Optional[str] = None\n    password: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"\n        Perform post-initialization processing if needed.\n        \"\"\"\n        pass\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, List[\"Endpoint\"]]:\n        \"\"\"\n        Get samples for Endpoint\n        \"\"\"\n        samples = {\n            \"sample-endpoints\": [\n                cls(\n                    name=\"wikidata\",\n                    lang=\"sparql\",\n                    endpoint=\"https://query.wikidata.org/sparql\",\n                    website=\"https://query.wikidata.org/\",\n                    database=\"blazegraph\",\n                    method=\"POST\",\n                    prefixes=\"PREFIX bd: &lt;http://www.bigdata.com/rdf#&gt;\\nPREFIX cc: &lt;http://creativecommons.org/ns#&gt;\",\n                ),\n                cls(\n                    name=\"dbis-jena\",\n                    lang=\"sparql\",\n                    endpoint=\"https://confident.dbis.rwth-aachen.de/jena/\",\n                    website=\"https://confident.dbis.rwth-aachen.de\",\n                    auth=\"BASIC\",\n                    user=\"secret\",\n                    password=\"#not public - example not usable for access#\",\n                ),\n            ]\n        }\n        return samples\n</code></pre>"},{"location":"#snapquery.endpoint.Endpoint.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Perform post-initialization processing if needed.</p> Source code in <code>snapquery/endpoint.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Perform post-initialization processing if needed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#snapquery.endpoint.Endpoint.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>Get samples for Endpoint</p> Source code in <code>snapquery/endpoint.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, List[\"Endpoint\"]]:\n    \"\"\"\n    Get samples for Endpoint\n    \"\"\"\n    samples = {\n        \"sample-endpoints\": [\n            cls(\n                name=\"wikidata\",\n                lang=\"sparql\",\n                endpoint=\"https://query.wikidata.org/sparql\",\n                website=\"https://query.wikidata.org/\",\n                database=\"blazegraph\",\n                method=\"POST\",\n                prefixes=\"PREFIX bd: &lt;http://www.bigdata.com/rdf#&gt;\\nPREFIX cc: &lt;http://creativecommons.org/ns#&gt;\",\n            ),\n            cls(\n                name=\"dbis-jena\",\n                lang=\"sparql\",\n                endpoint=\"https://confident.dbis.rwth-aachen.de/jena/\",\n                website=\"https://confident.dbis.rwth-aachen.de\",\n                auth=\"BASIC\",\n                user=\"secret\",\n                password=\"#not public - example not usable for access#\",\n            ),\n        ]\n    }\n    return samples\n</code></pre>"},{"location":"#snapquery.endpoint.EndpointManager","title":"<code>EndpointManager</code>","text":"<p>Manages the storage and retrieval of Endpoint configurations.</p> Source code in <code>snapquery/endpoint.py</code> <pre><code>@lod_storable\nclass EndpointManager:\n    \"\"\"\n    Manages the storage and retrieval of\n    Endpoint configurations.\n    \"\"\"\n\n    endpoints: Dict[str, Endpoint] = field(default_factory=dict)\n\n    @classmethod\n    def get_yaml_path(cls) -&gt; str:\n        samples_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"samples\")\n        yaml_path = os.path.join(samples_path, \"endpoints.yaml\")\n        return yaml_path\n\n    def get_endpoint(self, name: str) -&gt; Endpoint:\n        \"\"\"\n        Retrieve an endpoint by name.\n        \"\"\"\n        return self.endpoints.get(name)\n\n    def __len__(self):\n        return len(self.endpoints)\n\n    def __iter__(self):\n        return iter(self.endpoints.values())\n</code></pre>"},{"location":"#snapquery.endpoint.EndpointManager.get_endpoint","title":"<code>get_endpoint(name)</code>","text":"<p>Retrieve an endpoint by name.</p> Source code in <code>snapquery/endpoint.py</code> <pre><code>def get_endpoint(self, name: str) -&gt; Endpoint:\n    \"\"\"\n    Retrieve an endpoint by name.\n    \"\"\"\n    return self.endpoints.get(name)\n</code></pre>"},{"location":"#snapquery.error_filter","title":"<code>error_filter</code>","text":"<p>Created on 2024-05-06</p> <p>@author: wf</p>"},{"location":"#snapquery.error_filter.ErrorFilter","title":"<code>ErrorFilter</code>","text":"<p>handle technical error message to retrieve user friendly content</p> Source code in <code>snapquery/error_filter.py</code> <pre><code>class ErrorFilter:\n    \"\"\"\n    handle technical error message to\n    retrieve user friendly content\n    \"\"\"\n\n    def __init__(self, raw_error_message: str):\n        self.raw_error_message = raw_error_message\n        self.category = self.categorize_error()\n        self.filtered_message = self._extract_relevant_info()\n\n    def categorize_error(self) -&gt; str:\n        \"\"\"\n        Categorizes the error message into predefined types.\n\n        Returns:\n            str: The category of the error message.\n        \"\"\"\n        if self.raw_error_message is None:\n            return None\n\n        lower_error_msg = self.raw_error_message.lower()\n        # Todo: query is often part of the error message when these keywords are used within the query the classification fails.\n        if (\n            \"query timeout after\" in lower_error_msg\n            or \"timeoutexception\" in lower_error_msg\n            or \"query has timed out\" in lower_error_msg\n            or \"http error 504\" in lower_error_msg\n        ):\n            return \"Timeout\"\n        elif (\n            \"syntax error\" in lower_error_msg\n            or \"invalid sparql query\" in lower_error_msg\n            or \"querybadformed\" in lower_error_msg\n        ):\n            return \"Syntax Error\"\n        elif \"connection error\" in lower_error_msg:\n            return \"Connection Error\"\n        elif \"access denied\" in lower_error_msg:\n            return \"Authorization Error\"\n        elif (\n            \"service unavailable\" in lower_error_msg\n            or \"service temporarily unavailable\" in lower_error_msg\n            or \"http error 503\" in lower_error_msg\n        ):\n            return \"Service Unavailable\"\n        elif \"too many requests\" in lower_error_msg or \"http error 429\" in lower_error_msg:\n            return \"Too Many Requests\"\n        elif \"bad gateway\" in lower_error_msg or \"http error 502\" in lower_error_msg:\n            return \"Bad Gateway\"\n        elif \"endpointinternalerror\" in lower_error_msg:\n            return \"EndPointInternalError\"\n        else:\n            return \"Other\"\n\n    def _extract_relevant_info(self) -&gt; str:\n        \"\"\"\n        Extract relevant information from the given raw error message.\n        Identifies and processes different error message formats.\n        \"\"\"\n        if not self.raw_error_message:\n            return None\n\n        if \"SPARQL-QUERY:\" in self.raw_error_message:\n            return self._extract_sparql_error()\n        elif self.raw_error_message.startswith(\"QueryBadFormed:\") and \"Virtuoso\" in self.raw_error_message:\n            return self._extract_virtuoso_error()\n        elif self.raw_error_message.startswith(\"QueryBadFormed:\"):\n            return self._extract_triply_db_error()\n        elif \"Not supported:\" in self.raw_error_message:\n            return self._extract_qlever_error()\n        elif \"Invalid SPARQL query\" in self.raw_error_message:\n            return self._extract_invalid_sparql_error()\n        else:\n            if self.category == \"Timeout\":\n                return \"Query has timed out.\"\n            message_json = self._get_error_message_json()\n            if message_json and isinstance(message_json, dict) and \"exception\" in message_json:\n                return message_json.get(\"exception\")\n            return \"Error: Unrecognized error format.\"\n\n    def _extract_sparql_error(self) -&gt; str:\n        \"\"\"\n        Specifically extract and format SPARQL error messages.\n        \"\"\"\n        if \"java.util.concurrent.TimeoutException\" in self.raw_error_message:\n            return \"Query has timed out.\"\n        sparql_start_token = \"SPARQL-QUERY:\"\n        sparql_end_token = \"java.util.concurrent.ExecutionException\"\n        sparql_query = self._extract_message_between_tokens(sparql_start_token, sparql_end_token)\n        error_log_start = sparql_end_token\n        error_log_start_idx = self.raw_error_message.find(error_log_start)\n        error_log_end_idx = self.raw_error_message.find(\"\\\\tat\", error_log_start_idx)\n        error_message = self.raw_error_message[error_log_start_idx:error_log_end_idx]\n        if error_message:\n            return error_message.split(\"Exception:\")[-1].encode(\"utf-8\").decode(\"unicode_escape\").strip()\n        else:\n            return \"Error: SPARQL query information is incomplete.\"\n\n    def _extract_qlever_error(self) -&gt; str:\n        \"\"\"\n        Specifically extract and format QLever error messages.\n        \"\"\"\n        start_idx = self.raw_error_message.find(\"Not supported:\")\n        if start_idx != -1:\n            end_idx = self.raw_error_message.find(\"}\", start_idx)\n            error_message = self.raw_error_message[start_idx : end_idx + 1].strip()\n            return f\"QLever error:\\n{error_message}\"\n        else:\n            return \"Error: QLever error information is incomplete.\"\n\n    def _extract_virtuoso_error(self) -&gt; str:\n        \"\"\"\n        Specifically extract and format virtuoso error messages.\n        Returns:\n\n        \"\"\"\n        start_token = \"Response: b'\"\n        end_token = \"SPARQL query:\"\n        message = self._extract_message_between_tokens(start_token, end_token)\n        if message:\n            return message\n        else:\n            return \"Error: Virtuoso error information is incomplete.\"\n\n    def _extract_triply_db_error(self) -&gt; str:\n        \"\"\"\n        Specifically extract and format TriplyDB error messages.\n        Returns:\n\n        \"\"\"\n        message_json = self._get_error_message_json()\n        if message_json and \"message\" in message_json:\n            return message_json.get(\"message\")\n        elif message_json and \"exception\" in message_json:\n            return message_json.get(\"exception\")\n        else:\n            return \"Error: TriplyDB error information is incomplete.\"\n\n    def _get_error_message_json(self) -&gt; Union[dict, None]:\n        \"\"\"\n        Try to extract the json record from the raw error message.\n        \"\"\"\n        start_token = \"Response:\\nb'\"\n        stat_idx = self.raw_error_message.find(start_token)\n        end_idx = -1\n        message_json_raw = self.raw_error_message[stat_idx + len(start_token) : end_idx].strip()\n        try:\n            message_json = json.loads(message_json_raw.encode().decode(\"unicode_escape\"))\n        except JSONDecodeError as e:\n            message_json = None\n        return message_json\n\n    def _extract_message_between_tokens(self, start_token: str, end_token: str) -&gt; Union[str, None]:\n        \"\"\"\n        Extract and format message between tokens.\n        Args:\n            start_token:\n            end_token:\n\n        Returns:\n\n        \"\"\"\n        start_idx = self.raw_error_message.find(start_token)\n        end_idx = self.raw_error_message.find(end_token)\n        message = None\n        if start_idx != -1 and end_idx != -1:\n            message = self.raw_error_message[start_idx:end_idx]\n            message = message[len(start_token) :]\n            message = message.strip()\n        return message\n\n    def _extract_invalid_sparql_error(self) -&gt; str:\n        \"\"\"\n        Specifically extract and format Invalid SPARQL query error messages.\n        \"\"\"\n        error_start = self.raw_error_message.find(\"Invalid SPARQL query\")\n        if error_start != -1:\n            error_msg = self.raw_error_message[error_start:].split(\"\\n\")[0]\n            return f\"Invalid SPARQL query error:\\n{error_msg}\"\n        else:\n            return \"Error: Invalid SPARQL query information is incomplete.\"\n\n    def get_message(self, for_html: bool = True) -&gt; str:\n        \"\"\"\n        get the filtered message\n        \"\"\"\n        filtered_msg = self.filtered_message\n        if filtered_msg:\n            filtered_msg = filtered_msg.replace(\"\\\\n\", \"\\n\")\n            if for_html:\n                filtered_msg = filtered_msg.replace(\"\\n\", \"&lt;br&gt;\\n\")\n        return filtered_msg\n</code></pre>"},{"location":"#snapquery.error_filter.ErrorFilter.categorize_error","title":"<code>categorize_error()</code>","text":"<p>Categorizes the error message into predefined types.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The category of the error message.</p> Source code in <code>snapquery/error_filter.py</code> <pre><code>def categorize_error(self) -&gt; str:\n    \"\"\"\n    Categorizes the error message into predefined types.\n\n    Returns:\n        str: The category of the error message.\n    \"\"\"\n    if self.raw_error_message is None:\n        return None\n\n    lower_error_msg = self.raw_error_message.lower()\n    # Todo: query is often part of the error message when these keywords are used within the query the classification fails.\n    if (\n        \"query timeout after\" in lower_error_msg\n        or \"timeoutexception\" in lower_error_msg\n        or \"query has timed out\" in lower_error_msg\n        or \"http error 504\" in lower_error_msg\n    ):\n        return \"Timeout\"\n    elif (\n        \"syntax error\" in lower_error_msg\n        or \"invalid sparql query\" in lower_error_msg\n        or \"querybadformed\" in lower_error_msg\n    ):\n        return \"Syntax Error\"\n    elif \"connection error\" in lower_error_msg:\n        return \"Connection Error\"\n    elif \"access denied\" in lower_error_msg:\n        return \"Authorization Error\"\n    elif (\n        \"service unavailable\" in lower_error_msg\n        or \"service temporarily unavailable\" in lower_error_msg\n        or \"http error 503\" in lower_error_msg\n    ):\n        return \"Service Unavailable\"\n    elif \"too many requests\" in lower_error_msg or \"http error 429\" in lower_error_msg:\n        return \"Too Many Requests\"\n    elif \"bad gateway\" in lower_error_msg or \"http error 502\" in lower_error_msg:\n        return \"Bad Gateway\"\n    elif \"endpointinternalerror\" in lower_error_msg:\n        return \"EndPointInternalError\"\n    else:\n        return \"Other\"\n</code></pre>"},{"location":"#snapquery.error_filter.ErrorFilter.get_message","title":"<code>get_message(for_html=True)</code>","text":"<p>get the filtered message</p> Source code in <code>snapquery/error_filter.py</code> <pre><code>def get_message(self, for_html: bool = True) -&gt; str:\n    \"\"\"\n    get the filtered message\n    \"\"\"\n    filtered_msg = self.filtered_message\n    if filtered_msg:\n        filtered_msg = filtered_msg.replace(\"\\\\n\", \"\\n\")\n        if for_html:\n            filtered_msg = filtered_msg.replace(\"\\n\", \"&lt;br&gt;\\n\")\n    return filtered_msg\n</code></pre>"},{"location":"#snapquery.execution","title":"<code>execution</code>","text":"<p>Created on 2024-07-09</p> <p>@author: wf</p>"},{"location":"#snapquery.execution.Execution","title":"<code>Execution</code>","text":"<p>supports execution of named queries</p> Source code in <code>snapquery/execution.py</code> <pre><code>class Execution:\n    \"\"\"\n    supports execution of named queries\n    \"\"\"\n\n    def __init__(self, nqm: NamedQueryManager, debug: bool = False):\n        \"\"\" \"\"\"\n        self.nqm = nqm\n        self.debug = debug\n        self.logger = logging.getLogger(\"snapquery.execution.Execution\")\n\n    def parameterize(self, nq: NamedQuery):\n        qd = QueryDetails.from_sparql(query_id=nq.query_id, sparql=nq.sparql)\n        # Execute the query\n        params_dict = {}\n        if qd.params == \"q\":\n            # use Tim Berners-Lee as a example\n            params_dict = {\"q\": \"Q80\"}\n            pass\n        return qd, params_dict\n\n    def execute(\n        self,\n        nq: NamedQuery,\n        endpoint_name: str,\n        title: str,\n        context: str = \"test\",\n        prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n    ):\n        \"\"\"\n        execute the given named query\n        \"\"\"\n        qd, params_dict = self.parameterize(nq)\n        self.logger.debug(f\"{title}: {nq.name} {qd} - via {endpoint_name}\")\n        _results, stats = self.nqm.execute_query(\n            nq, params_dict=params_dict, endpoint_name=endpoint_name, prefix_merger=prefix_merger\n        )\n        stats.context = context\n        self.nqm.store_stats([stats])\n        msg = f\"{title} executed:\"\n        if not stats.records:\n            msg += f\"error {stats.filtered_msg}\"\n        else:\n            msg += f\"{stats.records} records found\"\n        self.logger.debug(msg)\n</code></pre>"},{"location":"#snapquery.execution.Execution.__init__","title":"<code>__init__(nqm, debug=False)</code>","text":"Source code in <code>snapquery/execution.py</code> <pre><code>def __init__(self, nqm: NamedQueryManager, debug: bool = False):\n    \"\"\" \"\"\"\n    self.nqm = nqm\n    self.debug = debug\n    self.logger = logging.getLogger(\"snapquery.execution.Execution\")\n</code></pre>"},{"location":"#snapquery.execution.Execution.execute","title":"<code>execute(nq, endpoint_name, title, context='test', prefix_merger=QueryPrefixMerger.SIMPLE_MERGER)</code>","text":"<p>execute the given named query</p> Source code in <code>snapquery/execution.py</code> <pre><code>def execute(\n    self,\n    nq: NamedQuery,\n    endpoint_name: str,\n    title: str,\n    context: str = \"test\",\n    prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n):\n    \"\"\"\n    execute the given named query\n    \"\"\"\n    qd, params_dict = self.parameterize(nq)\n    self.logger.debug(f\"{title}: {nq.name} {qd} - via {endpoint_name}\")\n    _results, stats = self.nqm.execute_query(\n        nq, params_dict=params_dict, endpoint_name=endpoint_name, prefix_merger=prefix_merger\n    )\n    stats.context = context\n    self.nqm.store_stats([stats])\n    msg = f\"{title} executed:\"\n    if not stats.records:\n        msg += f\"error {stats.filtered_msg}\"\n    else:\n        msg += f\"{stats.records} records found\"\n    self.logger.debug(msg)\n</code></pre>"},{"location":"#snapquery.graph","title":"<code>graph</code>","text":"<p>Created on 27.06.2024</p> <p>@author: wf</p>"},{"location":"#snapquery.graph.Graph","title":"<code>Graph</code>","text":"<p>A class representing a graph with its basic properties.</p> Source code in <code>snapquery/graph.py</code> <pre><code>@lod_storable\nclass Graph:\n    \"\"\"\n    A class representing a graph with its basic properties.\n    \"\"\"\n\n    name: str\n    default_endpoint_name: str\n    description: str\n    url: str\n    comment: str = \"\"\n\n    def __post_init__(self):\n        \"\"\"\n        Perform post-initialization processing if needed.\n        \"\"\"\n        pass\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"Graph\"]:\n        \"\"\"\n        get samples for Graph\n        \"\"\"\n        samples = {\n            \"graphs\": [\n                cls(\n                    name=\"wikidata\",\n                    default_endpoint_name=\"wikidata\",\n                    description=\"Wikidata knowledge graph\",\n                    url=\"https://query.wikidata.org/sparql\",\n                    comment=\"Main Wikidata endpoint\",\n                ),\n                cls(\n                    name=\"dblp\",\n                    default_endpoint_name=\"dblp\",\n                    description=\"DBLP computer science bibliography\",\n                    url=\"https://qlever.cs.uni-freiburg.de/api/dblp\",\n                    comment=\"DBLP endpoint powered by QLever\",\n                ),\n            ]\n        }\n        return samples\n</code></pre>"},{"location":"#snapquery.graph.Graph.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Perform post-initialization processing if needed.</p> Source code in <code>snapquery/graph.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Perform post-initialization processing if needed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#snapquery.graph.Graph.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>get samples for Graph</p> Source code in <code>snapquery/graph.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, \"Graph\"]:\n    \"\"\"\n    get samples for Graph\n    \"\"\"\n    samples = {\n        \"graphs\": [\n            cls(\n                name=\"wikidata\",\n                default_endpoint_name=\"wikidata\",\n                description=\"Wikidata knowledge graph\",\n                url=\"https://query.wikidata.org/sparql\",\n                comment=\"Main Wikidata endpoint\",\n            ),\n            cls(\n                name=\"dblp\",\n                default_endpoint_name=\"dblp\",\n                description=\"DBLP computer science bibliography\",\n                url=\"https://qlever.cs.uni-freiburg.de/api/dblp\",\n                comment=\"DBLP endpoint powered by QLever\",\n            ),\n        ]\n    }\n    return samples\n</code></pre>"},{"location":"#snapquery.graph.GraphManager","title":"<code>GraphManager</code>","text":"<p>Manages the storage and retrieval of Graph configurations.</p> Source code in <code>snapquery/graph.py</code> <pre><code>@lod_storable\nclass GraphManager:\n    \"\"\"\n    Manages the storage and retrieval of\n    Graph configurations.\n    \"\"\"\n\n    graphs: Dict[str, Graph] = field(default_factory=dict)\n\n    @classmethod\n    def get_yaml_path(cls) -&gt; str:\n        samples_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"samples\")\n        yaml_path = os.path.join(samples_path, \"graphs.yaml\")\n        return yaml_path\n\n    def get_graph(self, name: str) -&gt; Graph:\n        \"\"\"\n        Retrieve a graph by name.\n        \"\"\"\n        return self.graphs.get(name)\n\n    def __len__(self):\n        return len(self.graphs)\n\n    def __iter__(self):\n        return iter(self.graphs.values())\n</code></pre>"},{"location":"#snapquery.graph.GraphManager.get_graph","title":"<code>get_graph(name)</code>","text":"<p>Retrieve a graph by name.</p> Source code in <code>snapquery/graph.py</code> <pre><code>def get_graph(self, name: str) -&gt; Graph:\n    \"\"\"\n    Retrieve a graph by name.\n    \"\"\"\n    return self.graphs.get(name)\n</code></pre>"},{"location":"#snapquery.models","title":"<code>models</code>","text":""},{"location":"#snapquery.models.person","title":"<code>person</code>","text":"<p>Created 2023 refactored to snapquery by WF 2024-05</p> <p>@author: th</p>"},{"location":"#snapquery.models.person.Affiliation","title":"<code>Affiliation</code>  <code>dataclass</code>","text":"<p>affiliation of a person</p> Source code in <code>snapquery/models/person.py</code> <pre><code>@dataclass\nclass Affiliation:\n    \"\"\"\n    affiliation of a person\n    \"\"\"\n    name: Optional[str] = None\n    location: Optional[str] = None\n    country: Optional[str] = None\n    wikidata_id: Optional[str] = None\n\n    @property\n    def ui_label(self) -&gt; str:\n        if not self.name:\n            return \"\u2753\"  # empty\n        else:\n            return self.name\n</code></pre>"},{"location":"#snapquery.models.person.Person","title":"<code>Person</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PersonName</code></p> <p>A person</p> Source code in <code>snapquery/models/person.py</code> <pre><code>@dataclass\nclass Person(PersonName):\n    \"\"\"\n    A person\n    \"\"\"\n\n    wikidata_id: Optional[str] = None\n    dblp_author_id: Optional[str] = None\n    orcid_id: Optional[str] = None\n    image: Optional[str] = None\n    affiliation: Optional[List[Affiliation]] = None\n    official_website: Optional[str] = None\n\n    @property\n    def has_pid(self) -&gt; bool:\n        \"\"\"\n        Checks if the scholar has any persistent identifier (PID) set.\n        \"\"\"\n        return any([self.wikidata_id, self.dblp_author_id, self.orcid_id])\n\n    def share_identifier(self, other: \"Person\") -&gt; bool:\n        \"\"\"\n        Check if the given person shares an identifier with this person.\n        Args:\n\n            other: another person\n\n        Returns:\n            true if the person shares an identifier, false otherwise\n        \"\"\"\n        share_id = False\n        if self.wikidata_id is not None and other.wikidata_id == self.wikidata_id:\n            share_id = True\n        elif self.dblp_author_id is not None and other.dblp_author_id == self.dblp_author_id:\n            share_id = True\n        elif self.orcid_id is not None and other.orcid_id == self.orcid_id:\n            share_id = True\n        return share_id\n\n    def merge_with(self, other: \"Person\"):\n        \"\"\"\n        Merge this person with another person.\n        Args:\n            other: person to merge with\n        \"\"\"\n        for field in fields(self):\n            value = getattr(self, field.name)\n            if value is None:\n                value = getattr(other, field.name)\n            setattr(self, field.name, value)\n</code></pre>"},{"location":"#snapquery.models.person.Person.has_pid","title":"<code>has_pid: bool</code>  <code>property</code>","text":"<p>Checks if the scholar has any persistent identifier (PID) set.</p>"},{"location":"#snapquery.models.person.Person.merge_with","title":"<code>merge_with(other)</code>","text":"<p>Merge this person with another person. Args:     other: person to merge with</p> Source code in <code>snapquery/models/person.py</code> <pre><code>def merge_with(self, other: \"Person\"):\n    \"\"\"\n    Merge this person with another person.\n    Args:\n        other: person to merge with\n    \"\"\"\n    for field in fields(self):\n        value = getattr(self, field.name)\n        if value is None:\n            value = getattr(other, field.name)\n        setattr(self, field.name, value)\n</code></pre>"},{"location":"#snapquery.models.person.Person.share_identifier","title":"<code>share_identifier(other)</code>","text":"<p>Check if the given person shares an identifier with this person. Args:</p> <pre><code>other: another person\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>true if the person shares an identifier, false otherwise</p> Source code in <code>snapquery/models/person.py</code> <pre><code>def share_identifier(self, other: \"Person\") -&gt; bool:\n    \"\"\"\n    Check if the given person shares an identifier with this person.\n    Args:\n\n        other: another person\n\n    Returns:\n        true if the person shares an identifier, false otherwise\n    \"\"\"\n    share_id = False\n    if self.wikidata_id is not None and other.wikidata_id == self.wikidata_id:\n        share_id = True\n    elif self.dblp_author_id is not None and other.dblp_author_id == self.dblp_author_id:\n        share_id = True\n    elif self.orcid_id is not None and other.orcid_id == self.orcid_id:\n        share_id = True\n    return share_id\n</code></pre>"},{"location":"#snapquery.models.person.PersonName","title":"<code>PersonName</code>  <code>dataclass</code>","text":"<p>person name handling</p> Source code in <code>snapquery/models/person.py</code> <pre><code>@dataclass\nclass PersonName:    \n    \"\"\"\n    person name handling\n    \"\"\"    \n    label: Optional[str] = None\n    given_name: Optional[str] = None\n    family_name: Optional[str] = None\n\n    @property\n    def name(self) -&gt; str:\n        if not self.given_name and not self.family_name:\n            return \"\u2753\"  # empty\n        elif not self.given_name:\n            return self.family_name\n        elif not self.family_name:\n            return self.given_name\n        else:\n            return f\"{self.given_name} {self.family_name}\"\n\n    @property\n    def ui_label(self) -&gt; str:\n        return self.name\n\n    def parse_label(self):\n        \"\"\"\n        get family name and given name from label\n        \"\"\"\n        if self.label:\n            human_name=HumanName(self.label)\n            if not self.family_name and human_name.last:\n                self.family_name=human_name.last\n            if not self.given_name and human_name.first:\n                self.given_name=human_name.first\n</code></pre>"},{"location":"#snapquery.models.person.PersonName.parse_label","title":"<code>parse_label()</code>","text":"<p>get family name and given name from label</p> Source code in <code>snapquery/models/person.py</code> <pre><code>def parse_label(self):\n    \"\"\"\n    get family name and given name from label\n    \"\"\"\n    if self.label:\n        human_name=HumanName(self.label)\n        if not self.family_name and human_name.last:\n            self.family_name=human_name.last\n        if not self.given_name and human_name.first:\n            self.given_name=human_name.first\n</code></pre>"},{"location":"#snapquery.mwlogin","title":"<code>mwlogin</code>","text":"<p>Created on 04.05.2024</p> <p>@author: wf</p>"},{"location":"#snapquery.mwlogin.Login","title":"<code>Login</code>","text":"<p>login to mediawiki</p> Source code in <code>snapquery/mwlogin.py</code> <pre><code>class Login:\n    \"\"\"\n    login to mediawiki\n    \"\"\"\n\n    def __init__(\n        self,\n        consumer_key,\n        consumer_secret,\n        wiki_url=\"https://en.wikipedia.org/w/index.php\",\n    ):\n        self.consumer_token = ConsumerToken(consumer_key, consumer_secret)\n        self.handshaker = Handshaker(wiki_url, self.consumer_token)\n        self.request_token = None\n        self.access_token = None\n\n    def initiate_login(self):\n        \"\"\"\n        Step 1: Initialize -- ask MediaWiki for a temporary key/secret for user\n        \"\"\"\n        redirect, self.request_token = self.handshaker.initiate()\n        webbrowser.open(redirect)\n        print(\"Browser opened to MediaWiki login page. Please authorize the application.\")\n\n    def complete_login(self, response_qs):\n        \"\"\"\n        Step 3: Complete -- obtain authorized key/secret for \"resource owner\"\n        \"\"\"\n        self.access_token = self.handshaker.complete(self.request_token, response_qs)\n        print(\"Login completed successfully.\")\n\n    def identify_user(self):\n        \"\"\"\n        Step 4: Identify -- (optional) get identifying information about the user\n        \"\"\"\n        if self.access_token:\n            identity = self.handshaker.identify(self.access_token)\n            print(f\"Identified as {identity['username']}.\")\n        else:\n            print(\"Access token is not available. Please complete the login process first.\")\n</code></pre>"},{"location":"#snapquery.mwlogin.Login.complete_login","title":"<code>complete_login(response_qs)</code>","text":"<p>Step 3: Complete -- obtain authorized key/secret for \"resource owner\"</p> Source code in <code>snapquery/mwlogin.py</code> <pre><code>def complete_login(self, response_qs):\n    \"\"\"\n    Step 3: Complete -- obtain authorized key/secret for \"resource owner\"\n    \"\"\"\n    self.access_token = self.handshaker.complete(self.request_token, response_qs)\n    print(\"Login completed successfully.\")\n</code></pre>"},{"location":"#snapquery.mwlogin.Login.identify_user","title":"<code>identify_user()</code>","text":"<p>Step 4: Identify -- (optional) get identifying information about the user</p> Source code in <code>snapquery/mwlogin.py</code> <pre><code>def identify_user(self):\n    \"\"\"\n    Step 4: Identify -- (optional) get identifying information about the user\n    \"\"\"\n    if self.access_token:\n        identity = self.handshaker.identify(self.access_token)\n        print(f\"Identified as {identity['username']}.\")\n    else:\n        print(\"Access token is not available. Please complete the login process first.\")\n</code></pre>"},{"location":"#snapquery.mwlogin.Login.initiate_login","title":"<code>initiate_login()</code>","text":"<p>Step 1: Initialize -- ask MediaWiki for a temporary key/secret for user</p> Source code in <code>snapquery/mwlogin.py</code> <pre><code>def initiate_login(self):\n    \"\"\"\n    Step 1: Initialize -- ask MediaWiki for a temporary key/secret for user\n    \"\"\"\n    redirect, self.request_token = self.handshaker.initiate()\n    webbrowser.open(redirect)\n    print(\"Browser opened to MediaWiki login page. Please authorize the application.\")\n</code></pre>"},{"location":"#snapquery.namespace_stats_view","title":"<code>namespace_stats_view</code>","text":"<p>Created on 2024-06-23</p> <p>@author: wf</p>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView","title":"<code>NamespaceStatsView</code>","text":"<p>Class to view and manage SPARQL query statistics using NiceGUI.</p> <p>Attributes:</p> Name Type Description <code>solution</code> <code>WebSolution</code> <p>The web solution context which provides access to shared resources.</p> <code>nqm</code> <code>NamedQueryManager</code> <p>The manager to handle named queries and database interactions.</p> <code>results_row</code> <code>row</code> <p>UI component that holds the results grid.</p> <code>lod_grid</code> <code>ListOfDictsGrid</code> <p>Grid component to display the query statistics.</p> Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>class NamespaceStatsView:\n    \"\"\"Class to view and manage SPARQL query statistics using NiceGUI.\n\n    Attributes:\n        solution (WebSolution): The web solution context which provides access to shared resources.\n        nqm (NamedQueryManager): The manager to handle named queries and database interactions.\n        results_row (ui.row): UI component that holds the results grid.\n        lod_grid (ListOfDictsGrid): Grid component to display the query statistics.\n    \"\"\"\n\n    def __init__(self, solution: WebSolution):\n        \"\"\"Initialize the NamespaceStatsView with a given web solution context.\n\n        Args:\n            solution (WebSolution): The web solution context which includes shared resources like the NamedQueryManager.\n        \"\"\"\n        self.solution = solution\n        self.nqm = self.solution.nqm\n        self.progress_bar: Optional[NiceguiProgressbar] = None\n        self.lod_grid: Optional[ListOfDictsGrid] = None\n        self.setup_ui()\n\n    def setup_ui(self):\n        \"\"\"Sets up the user interface for displaying SPARQL query statistics.\"\"\"\n        with ui.row() as self.progress_row:\n            self.progress_bar = NiceguiProgressbar(desc=\"Query Progress\", total=100, unit=\"queries\")\n            self.progress_bar.progress.classes(\"rounded\")\n        with ui.row() as self.results_row:\n            ui.label(\"Legend: \u2705 Distinct Successful Queries  \u274c Distinct Failed Queries  \ud83d\udd04 Total Successful Runs\")\n            self.lod_grid = ListOfDictsGrid()\n            # Set up a click event handler for the grid\n            self.lod_grid.ag_grid.on(\"cellClicked\", self.on_cell_clicked)\n\n        # Fetch and display data immediately upon UI setup\n        ui.timer(0.0, self.on_fetch_lod, once=True)\n\n    async def on_cell_clicked(self, event):\n        \"\"\"Handle cell click events to perform specific actions based on the cell content.\"\"\"\n        # Retrieve details from the event object\n        logger.debug(f\"Cell clicked: {event}\")\n        row_data = event.args[\"data\"]\n        endpoint_name = event.args[\"colId\"]\n        namespace = row_data[\"namespace\"]\n        domain = row_data[\"domain\"]\n        if endpoint_name in self.nqm.endpoints.keys():\n            if self.solution.webserver.authenticated():\n                await run.io_bound(\n                    self.execute_queries,\n                    namespace=namespace,\n                    endpoint_name=endpoint_name,\n                    domain=domain,\n                )\n            else:\n                ui.notify(\"you must be admin to run queries via the web interface\")\n        else:\n            # this should not be possible\n            ui.notify(f\"invalid endpoint {endpoint_name}\")\n\n    async def on_fetch_lod(self, _args=None):\n        \"\"\"Fetches data asynchronously and loads it into the grid upon successful retrieval.\"\"\"\n        try:\n            stats_lod = await run.io_bound(self.fetch_query_lod)\n            processed_lod = self.process_stats_lod(stats_lod)\n            with self.results_row:\n                self.lod_grid.load_lod(processed_lod)\n                self.lod_grid.update()\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def fetch_query_lod(self) -&gt; List[Dict[str, any]]:\n        \"\"\"Fetch data from the database based on the named query 'query_success_by_namespace'.\n\n        Returns:\n            List[Dict[str, any]]: A list of dictionaries containing the query results.\n        \"\"\"\n        query_name = \"query_namespace_endpoint_matrix_with_distinct\"\n        query = self.nqm.meta_qm.queriesByName[query_name]\n        return self.nqm.sql_db.query(query.query)\n\n    def process_stats_lod(self, raw_lod: List[Dict[str, any]]) -&gt; List[Dict[str, any]]:\n        \"\"\"Process the raw list of dictionaries to format suitable for the grid display.\n\n        Args:\n            raw_lod (List[Dict[str, any]]): The raw data fetched from the SQL query.\n\n        Returns:\n            List[Dict[str, any]]: The processed list of dictionaries formatted for grid display.\n        \"\"\"\n        domain_namespace_stats = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: [0, 0, 0])))\n        endpoints = list(self.nqm.endpoints.keys())\n        total_queries = {}\n\n        for entry in raw_lod:\n            domain = entry[\"domain\"]\n            namespace = entry[\"namespace\"]\n            endpoint = entry[\"endpoint_name\"]\n            distinct_successful = entry.get(\"distinct_successful\", 0)\n            distinct_failed = entry.get(\"distinct_failed\", 0)\n            success_count = entry[\"success_count\"]\n            total_queries[(domain, namespace)] = entry[\"total\"]\n            domain_namespace_stats[domain][namespace][endpoint] = [\n                distinct_successful,\n                distinct_failed,\n                success_count,\n            ]\n\n        processed_lod = []\n        for domain, namespaces in domain_namespace_stats.items():\n            for namespace, counts in namespaces.items():\n                row = {\n                    \"domain\": domain,\n                    \"namespace\": namespace,\n                    \"total\": total_queries[(domain, namespace)],\n                }\n                for endpoint in endpoints:\n                    success, fail, total = counts.get(endpoint, [0, 0, 0])\n                    if success == 0 and fail == 0 and total == 0:\n                        row[endpoint] = \"\"\n                    else:\n                        row[endpoint] = f\"\u2705{success} \u274c{fail} \ud83d\udd04{total}\"\n                processed_lod.append(row)\n\n        return processed_lod\n\n    def execute_queries(self, namespace: str, endpoint_name: str, domain: str):\n        \"\"\"execute queries with progress updates.\n        Args:\n            namespace (str): The namespace of the queries to execute.\n            endpoint_name (str): The endpoint name where the queries will be executed.\n            domain: domain name\n        \"\"\"\n        queries = self.nqm.get_all_queries(namespace=namespace, domain=domain)\n        total_queries = len(queries)\n\n        self.progress_bar.total = total_queries\n        self.progress_bar.reset()\n        execution = Execution(self.nqm)\n        for i, nq in enumerate(queries, start=1):\n            with self.progress_row:\n                self.progress_bar.update_value(i)\n                self.progress_bar.set_description(f\"Executing {nq.name} on {endpoint_name}\")\n                logger.debug(f\"Executing {nq.name} on {endpoint_name}\")\n            execution.execute(nq, endpoint_name, title=f\"query {i}/{len(queries)}::{endpoint_name}\", context=\"web-test\")\n        with self.progress_row:\n            ui.timer(0.1, self.on_fetch_lod, once=True)\n            ui.notify(\n                f\"finished {total_queries} queries for namespace: {namespace} with domain: {domain}\",\n                type=\"positive\",\n            )\n</code></pre>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView.__init__","title":"<code>__init__(solution)</code>","text":"<p>Initialize the NamespaceStatsView with a given web solution context.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>WebSolution</code> <p>The web solution context which includes shared resources like the NamedQueryManager.</p> required Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>def __init__(self, solution: WebSolution):\n    \"\"\"Initialize the NamespaceStatsView with a given web solution context.\n\n    Args:\n        solution (WebSolution): The web solution context which includes shared resources like the NamedQueryManager.\n    \"\"\"\n    self.solution = solution\n    self.nqm = self.solution.nqm\n    self.progress_bar: Optional[NiceguiProgressbar] = None\n    self.lod_grid: Optional[ListOfDictsGrid] = None\n    self.setup_ui()\n</code></pre>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView.execute_queries","title":"<code>execute_queries(namespace, endpoint_name, domain)</code>","text":"<p>execute queries with progress updates. Args:     namespace (str): The namespace of the queries to execute.     endpoint_name (str): The endpoint name where the queries will be executed.     domain: domain name</p> Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>def execute_queries(self, namespace: str, endpoint_name: str, domain: str):\n    \"\"\"execute queries with progress updates.\n    Args:\n        namespace (str): The namespace of the queries to execute.\n        endpoint_name (str): The endpoint name where the queries will be executed.\n        domain: domain name\n    \"\"\"\n    queries = self.nqm.get_all_queries(namespace=namespace, domain=domain)\n    total_queries = len(queries)\n\n    self.progress_bar.total = total_queries\n    self.progress_bar.reset()\n    execution = Execution(self.nqm)\n    for i, nq in enumerate(queries, start=1):\n        with self.progress_row:\n            self.progress_bar.update_value(i)\n            self.progress_bar.set_description(f\"Executing {nq.name} on {endpoint_name}\")\n            logger.debug(f\"Executing {nq.name} on {endpoint_name}\")\n        execution.execute(nq, endpoint_name, title=f\"query {i}/{len(queries)}::{endpoint_name}\", context=\"web-test\")\n    with self.progress_row:\n        ui.timer(0.1, self.on_fetch_lod, once=True)\n        ui.notify(\n            f\"finished {total_queries} queries for namespace: {namespace} with domain: {domain}\",\n            type=\"positive\",\n        )\n</code></pre>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView.fetch_query_lod","title":"<code>fetch_query_lod()</code>","text":"<p>Fetch data from the database based on the named query 'query_success_by_namespace'.</p> <p>Returns:</p> Type Description <code>List[Dict[str, any]]</code> <p>List[Dict[str, any]]: A list of dictionaries containing the query results.</p> Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>def fetch_query_lod(self) -&gt; List[Dict[str, any]]:\n    \"\"\"Fetch data from the database based on the named query 'query_success_by_namespace'.\n\n    Returns:\n        List[Dict[str, any]]: A list of dictionaries containing the query results.\n    \"\"\"\n    query_name = \"query_namespace_endpoint_matrix_with_distinct\"\n    query = self.nqm.meta_qm.queriesByName[query_name]\n    return self.nqm.sql_db.query(query.query)\n</code></pre>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView.on_cell_clicked","title":"<code>on_cell_clicked(event)</code>  <code>async</code>","text":"<p>Handle cell click events to perform specific actions based on the cell content.</p> Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>async def on_cell_clicked(self, event):\n    \"\"\"Handle cell click events to perform specific actions based on the cell content.\"\"\"\n    # Retrieve details from the event object\n    logger.debug(f\"Cell clicked: {event}\")\n    row_data = event.args[\"data\"]\n    endpoint_name = event.args[\"colId\"]\n    namespace = row_data[\"namespace\"]\n    domain = row_data[\"domain\"]\n    if endpoint_name in self.nqm.endpoints.keys():\n        if self.solution.webserver.authenticated():\n            await run.io_bound(\n                self.execute_queries,\n                namespace=namespace,\n                endpoint_name=endpoint_name,\n                domain=domain,\n            )\n        else:\n            ui.notify(\"you must be admin to run queries via the web interface\")\n    else:\n        # this should not be possible\n        ui.notify(f\"invalid endpoint {endpoint_name}\")\n</code></pre>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView.on_fetch_lod","title":"<code>on_fetch_lod(_args=None)</code>  <code>async</code>","text":"<p>Fetches data asynchronously and loads it into the grid upon successful retrieval.</p> Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>async def on_fetch_lod(self, _args=None):\n    \"\"\"Fetches data asynchronously and loads it into the grid upon successful retrieval.\"\"\"\n    try:\n        stats_lod = await run.io_bound(self.fetch_query_lod)\n        processed_lod = self.process_stats_lod(stats_lod)\n        with self.results_row:\n            self.lod_grid.load_lod(processed_lod)\n            self.lod_grid.update()\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView.process_stats_lod","title":"<code>process_stats_lod(raw_lod)</code>","text":"<p>Process the raw list of dictionaries to format suitable for the grid display.</p> <p>Parameters:</p> Name Type Description Default <code>raw_lod</code> <code>List[Dict[str, any]]</code> <p>The raw data fetched from the SQL query.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, any]]</code> <p>List[Dict[str, any]]: The processed list of dictionaries formatted for grid display.</p> Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>def process_stats_lod(self, raw_lod: List[Dict[str, any]]) -&gt; List[Dict[str, any]]:\n    \"\"\"Process the raw list of dictionaries to format suitable for the grid display.\n\n    Args:\n        raw_lod (List[Dict[str, any]]): The raw data fetched from the SQL query.\n\n    Returns:\n        List[Dict[str, any]]: The processed list of dictionaries formatted for grid display.\n    \"\"\"\n    domain_namespace_stats = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: [0, 0, 0])))\n    endpoints = list(self.nqm.endpoints.keys())\n    total_queries = {}\n\n    for entry in raw_lod:\n        domain = entry[\"domain\"]\n        namespace = entry[\"namespace\"]\n        endpoint = entry[\"endpoint_name\"]\n        distinct_successful = entry.get(\"distinct_successful\", 0)\n        distinct_failed = entry.get(\"distinct_failed\", 0)\n        success_count = entry[\"success_count\"]\n        total_queries[(domain, namespace)] = entry[\"total\"]\n        domain_namespace_stats[domain][namespace][endpoint] = [\n            distinct_successful,\n            distinct_failed,\n            success_count,\n        ]\n\n    processed_lod = []\n    for domain, namespaces in domain_namespace_stats.items():\n        for namespace, counts in namespaces.items():\n            row = {\n                \"domain\": domain,\n                \"namespace\": namespace,\n                \"total\": total_queries[(domain, namespace)],\n            }\n            for endpoint in endpoints:\n                success, fail, total = counts.get(endpoint, [0, 0, 0])\n                if success == 0 and fail == 0 and total == 0:\n                    row[endpoint] = \"\"\n                else:\n                    row[endpoint] = f\"\u2705{success} \u274c{fail} \ud83d\udd04{total}\"\n            processed_lod.append(row)\n\n    return processed_lod\n</code></pre>"},{"location":"#snapquery.namespace_stats_view.NamespaceStatsView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Sets up the user interface for displaying SPARQL query statistics.</p> Source code in <code>snapquery/namespace_stats_view.py</code> <pre><code>def setup_ui(self):\n    \"\"\"Sets up the user interface for displaying SPARQL query statistics.\"\"\"\n    with ui.row() as self.progress_row:\n        self.progress_bar = NiceguiProgressbar(desc=\"Query Progress\", total=100, unit=\"queries\")\n        self.progress_bar.progress.classes(\"rounded\")\n    with ui.row() as self.results_row:\n        ui.label(\"Legend: \u2705 Distinct Successful Queries  \u274c Distinct Failed Queries  \ud83d\udd04 Total Successful Runs\")\n        self.lod_grid = ListOfDictsGrid()\n        # Set up a click event handler for the grid\n        self.lod_grid.ag_grid.on(\"cellClicked\", self.on_cell_clicked)\n\n    # Fetch and display data immediately upon UI setup\n    ui.timer(0.0, self.on_fetch_lod, once=True)\n</code></pre>"},{"location":"#snapquery.orcid","title":"<code>orcid</code>","text":""},{"location":"#snapquery.orcid.OrcidAccessToken","title":"<code>OrcidAccessToken</code>","text":"<p>orcid access token response</p> Source code in <code>snapquery/orcid.py</code> <pre><code>@lod_storable\nclass OrcidAccessToken:\n    \"\"\"\n    orcid access token response\n    \"\"\"\n\n    orcid: str\n    access_token: str\n    token_type: str\n    refresh_token: str\n    expires_in: int\n    scope: str\n    name: str\n    login_timestamp: int = int(time())\n\n    @classmethod\n    def get_samples(cls):\n        lod = [\n            {\n                \"access_token\": \"f5af9f51-07e6-4332-8f1a-c0c11c1e3728\",\n                \"token_type\": \"bearer\",\n                \"refresh_token\": \"f725f747-3a65-49f6-a231-3e8944ce464d\",\n                \"expires_in\": 631138518,\n                \"scope\": \"/activities/update /read-limited\",\n                \"name\": \"Sofia Garcia\",\n                \"orcid\": \"0000-0001-2345-6789\",\n            }\n        ]\n        return [OrcidAccessToken.from_dict2(d) for d in lod]\n</code></pre>"},{"location":"#snapquery.orcid.OrcidAuth","title":"<code>OrcidAuth</code>","text":"<p>authenticate with orcid</p> Source code in <code>snapquery/orcid.py</code> <pre><code>class OrcidAuth:\n    \"\"\"\n    authenticate with orcid\n    \"\"\"\n\n    def __init__(\n        self,\n        base_path: Optional[Path] = None,\n        config_file_name: str = \"orcid_config.yaml\",\n    ):\n        if base_path is None:\n            base_path = Path.home() / \".solutions/snapquery\"\n        self.base_path = base_path\n        self.config_file_name = config_file_name\n        self.config = self.load_config()\n\n    def get_config_path(self) -&gt; Path:\n        return self.base_path / self.config_file_name\n\n    def config_exists(self):\n        return self.get_config_path().exists()\n\n    def available(self) -&gt; bool:\n        return self.config is not None\n\n    def load_config(self) -&gt; Union[\"OrcidConfig\", None]:\n        if not self.config_exists():\n            return None\n        config = OrcidConfig.load_from_yaml_file(str(self.get_config_path()))\n        return config\n\n    def authenticate_url(self):\n        return self.config.authenticate_url()\n\n    def authenticated(self) -&gt; bool:\n        authenticated = False\n        if not self.available():\n            return authenticated\n        orcid_token = self.get_cached_user_access_token()\n        if orcid_token is not None:\n            authenticated = self._check_access_token(orcid_token)\n        return authenticated\n\n    def get_cached_user_access_token(self) -&gt; Union[\"OrcidAccessToken\", None]:\n        orcid_token_record = app.storage.user.get(\"orcid_token\", None)\n        orcid_token = None\n        if orcid_token_record:\n            orcid_token: OrcidAccessToken = OrcidAccessToken.from_dict2(orcid_token_record)\n        return orcid_token\n\n    def _check_access_token(self, orcid_token: \"OrcidAccessToken\") -&gt; bool:\n        \"\"\"\n        Check if the given access token is valid\n        Args:\n            orcid_token: orcid access token\n\n        Returns:\n            True if the access token is valid, False otherwise\n        \"\"\"\n        time_passed = int(time()) - orcid_token.login_timestamp\n        if orcid_token.expires_in - time_passed &lt; 0:\n            return False\n        else:\n            return True\n\n    def login(self, access_code: str) -&gt; bool:\n        authenticated = False\n        try:\n            orcid_token = self._retrieve_token(access_code)\n            app.storage.user.update({\"orcid_token\": asdict(orcid_token)})\n            authenticated = True\n        except Exception as e:\n            print(e)\n            raise e\n        return authenticated\n\n    def _retrieve_token(self, code: str) -&gt; \"OrcidAccessToken\":\n        \"\"\"\n        URL=https://sandbox.orcid.org/oauth/token\n         HEADER: Accept: application/json\n         HEADER: Content-Type: application/x-www-form-urlencoded\n         METHOD: POST\n         DATA:\n           client_id=[Your client ID]\n           client_secret=[Your client secret]\n           grant_type=authorization_code\n           code=Six-digit code\n           redirect_uri=[Your landing page]\n        \"\"\"\n        url = f\"{self.config.url}/oauth/token\"\n        data = {\n            \"client_id\": self.config.client_id,\n            \"client_secret\": self.config.client_secret,\n            \"grant_type\": \"authorization_code\",\n            \"code\": code,\n        }\n        resp = requests.post(url, data=data)\n        resp.raise_for_status()\n        resp_json = resp.json()\n        orcid_token: OrcidAccessToken = OrcidAccessToken.from_dict2(resp_json)\n        return orcid_token\n\n    def logout(self):\n        \"\"\"\n        logout user by deleting cached access token\n        \"\"\"\n        del app.storage.user[\"orcid_token\"]\n\n    def _request_search_token(self) -&gt; str:\n        \"\"\"\n        Request search token\n        see https://info.orcid.org/documentation/api-tutorials/api-tutorial-searching-the-orcid-registry/\n\n        URL=https://sandbox.orcid.org/oauth/token\n          HEADER: Accept: application/json\n          METHOD: POST\n          DATA:\n            client_id=[Your public API client ID]\n            client_secret=[Your public API secret]\n            grant_type=client_credentials\n            scope=/read-public\n        Returns:\n\n        \"\"\"\n        url = f\"{self.config.url}/oauth/token\"\n        data = {\n            \"client_id\": self.config.client_id,\n            \"client_secret\": self.config.client_secret,\n            \"grant_type\": \"client_credentials\",\n            \"scope\": \"/read-public\",\n        }\n        resp = requests.post(url, data=data)\n        resp.raise_for_status()\n        resp_json = resp.json()\n        return resp_json[\"access_token\"]\n\n    @property\n    def search_token(self) -&gt; str:\n        if self.config.search_token is None:\n            search_token = self._request_search_token()\n            self.config.search_token = search_token\n            self.store_config()\n        return self.config.search_token\n\n    def store_config(self):\n        self.config.save_to_yaml_file(str(self.get_config_path()))\n\n    def search(self, params: \"OrcidSearchParams\", limit: int = 10) -&gt; list[Person]:\n        access_token = self.search_token\n        url = f\"{self.config.api_endpoint}/expanded-search/?q={params.get_search_query()}&amp;rows={limit}\"\n        headers = {\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {access_token}\",\n        }\n        resp = requests.get(url, headers=headers)\n        resp.raise_for_status()\n        records: list[dict] = resp.json().get(\"expanded-result\", [])\n        persons = []\n        if records:\n            for record in records:\n                person = Person(\n                    given_name=record.get(\"given-names\", None),\n                    family_name=record.get(\"family-names\", None),\n                    orcid_id=record.get(\"orcid-id\", None),\n                )\n                persons.append(person)\n        return persons\n</code></pre>"},{"location":"#snapquery.orcid.OrcidAuth.logout","title":"<code>logout()</code>","text":"<p>logout user by deleting cached access token</p> Source code in <code>snapquery/orcid.py</code> <pre><code>def logout(self):\n    \"\"\"\n    logout user by deleting cached access token\n    \"\"\"\n    del app.storage.user[\"orcid_token\"]\n</code></pre>"},{"location":"#snapquery.orcid.OrcidConfig","title":"<code>OrcidConfig</code>","text":"<p>orcid authentication configuration</p> Source code in <code>snapquery/orcid.py</code> <pre><code>@lod_storable\nclass OrcidConfig:\n    \"\"\"\n    orcid authentication configuration\n    \"\"\"\n\n    url: str\n    client_id: str\n    client_secret: str\n    redirect_uri: str = \"http://127.0.0.1:9862/orcid_callback\"\n    api_endpoint: str = \"https://pub.orcid.org/v3.0\"\n    search_token: Optional[str] = None\n\n    @classmethod\n    def get_samples(cls) -&gt; list[\"OrcidConfig\"]:\n        lod = [\n            {\n                \"url\": \"https://orcid.org\",\n                \"client_id\": \"APP-123456789ABCDEFG\",\n                \"client_secret\": \"&lt;KEY&gt;\",\n                \"redirect_uri\": \"http://127.0.0.1:9862/orcid_callback\",\n                \"api_endpoint\": \"https://sandbox.orcid.org/v3.0\",\n            }\n        ]\n        return [OrcidConfig.from_dict2(d) for d in lod]\n\n    def authenticate_url(self):\n        return f\"{self.url}/oauth/authorize?client_id={self.client_id}&amp;response_type=code&amp;scope=/authenticate&amp;redirect_uri={self.redirect_uri}\"\n</code></pre>"},{"location":"#snapquery.orcid.OrcidSearchParams","title":"<code>OrcidSearchParams</code>  <code>dataclass</code>","text":"<p>Orcid search api params see https://info.orcid.org/documentation/api-tutorials/api-tutorial-searching-the-orcid-registry/</p> Source code in <code>snapquery/orcid.py</code> <pre><code>@dataclass\nclass OrcidSearchParams:\n    \"\"\"\n    Orcid search api params\n    see https://info.orcid.org/documentation/api-tutorials/api-tutorial-searching-the-orcid-registry/\n    \"\"\"\n\n    # Biographical data\n    given_names: Optional[str] = None\n    family_name: Optional[str] = None\n    credit_name: Optional[str] = None\n    other_names: Optional[list[str]] = None\n    email: Optional[str] = None\n    keyword: Optional[list[str]] = None\n    external_id_reference: Optional[str] = None\n\n    # Affiliations data\n    affiliation_org_name: Optional[str] = None\n    grid_org_id: Optional[str] = None\n    ror_org_id: Optional[str] = None\n    ringgold_org_id: Optional[str] = None\n\n    # Funding data\n    funding_titles: Optional[list[str]] = None\n    fundref_org_id: Optional[str] = None\n    grant_numbers: Optional[list[str]] = None\n\n    # Research activities data\n    work_titles: Optional[list[str]] = None\n    digital_object_ids: Optional[list[str]] = None\n\n    # ORCID record data\n    orcid: Optional[str] = None\n    profile_submission_date: Optional[str] = None  # Assuming date format is string\n    profile_last_modified_date: Optional[str] = None  # Assuming date format is string\n\n    # All data (default for Lucene syntax)\n    text: Optional[str] = None\n\n    def get_search_query(self) -&gt; str:\n        query = \"\"\n        dlim = \"\"\n        for field in fields(self):\n            key = field.name.replace(\"_\", \"-\")\n            value = getattr(self, field.name)\n            if value is None:\n                continue\n            query += f\"{key}:{value}\"\n            dlim = \"+\"\n        return query\n</code></pre>"},{"location":"#snapquery.params_view","title":"<code>params_view</code>","text":"<p>Created on 06.05.2024</p> <p>@author: wf</p>"},{"location":"#snapquery.params_view.ParamsView","title":"<code>ParamsView</code>","text":"<p>a view for Query Parameters</p> Source code in <code>snapquery/params_view.py</code> <pre><code>class ParamsView:\n    \"\"\"\n    a view for Query Parameters\n    \"\"\"\n\n    def __init__(self, solution, params: Params):\n        \"\"\"\n        construct me with the given solution and params\n        \"\"\"\n        self.solution = solution\n        self.params = params\n\n    def open(self):\n        \"\"\"\n        show the details of the dict edit\n        \"\"\"\n        self.dict_edit.expansion.open()\n\n    def close(self):\n        \"\"\"\n        hide the details of the dict edit\n        \"\"\"\n        self.dict_edit.expansion.close()\n\n    def get_dict_edit(self) -&gt; DictEdit:\n        \"\"\"\n        Return a DictEdit instance for editing parameters.\n        \"\"\"\n        # Define a custom form definition for the title \"Params\"\n        form_ui_def = FormUiDef(\n            title=\"Params\",\n            icon=\"tune\",\n            ui_fields={key: FieldUiDef.from_key_value(key, value) for key, value in self.params.params_dict.items()},\n        )\n        self.dict_edit = DictEdit(data_to_edit=self.params.params_dict, form_ui_def=form_ui_def)\n        self.open()\n        return self.dict_edit\n</code></pre>"},{"location":"#snapquery.params_view.ParamsView.__init__","title":"<code>__init__(solution, params)</code>","text":"<p>construct me with the given solution and params</p> Source code in <code>snapquery/params_view.py</code> <pre><code>def __init__(self, solution, params: Params):\n    \"\"\"\n    construct me with the given solution and params\n    \"\"\"\n    self.solution = solution\n    self.params = params\n</code></pre>"},{"location":"#snapquery.params_view.ParamsView.close","title":"<code>close()</code>","text":"<p>hide the details of the dict edit</p> Source code in <code>snapquery/params_view.py</code> <pre><code>def close(self):\n    \"\"\"\n    hide the details of the dict edit\n    \"\"\"\n    self.dict_edit.expansion.close()\n</code></pre>"},{"location":"#snapquery.params_view.ParamsView.get_dict_edit","title":"<code>get_dict_edit()</code>","text":"<p>Return a DictEdit instance for editing parameters.</p> Source code in <code>snapquery/params_view.py</code> <pre><code>def get_dict_edit(self) -&gt; DictEdit:\n    \"\"\"\n    Return a DictEdit instance for editing parameters.\n    \"\"\"\n    # Define a custom form definition for the title \"Params\"\n    form_ui_def = FormUiDef(\n        title=\"Params\",\n        icon=\"tune\",\n        ui_fields={key: FieldUiDef.from_key_value(key, value) for key, value in self.params.params_dict.items()},\n    )\n    self.dict_edit = DictEdit(data_to_edit=self.params.params_dict, form_ui_def=form_ui_def)\n    self.open()\n    return self.dict_edit\n</code></pre>"},{"location":"#snapquery.params_view.ParamsView.open","title":"<code>open()</code>","text":"<p>show the details of the dict edit</p> Source code in <code>snapquery/params_view.py</code> <pre><code>def open(self):\n    \"\"\"\n    show the details of the dict edit\n    \"\"\"\n    self.dict_edit.expansion.open()\n</code></pre>"},{"location":"#snapquery.person_selector","title":"<code>person_selector</code>","text":"<p>Created 2023</p> <p>@author: th</p>"},{"location":"#snapquery.person_selector.PersonSelector","title":"<code>PersonSelector</code>","text":"<p>Provides an interface for searching and selecting people with auto-suggestions.</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>class PersonSelector:\n    \"\"\"\n    Provides an interface for searching and selecting people with auto-suggestions.\n    \"\"\"\n\n    def __init__(\n        self,\n        solution: WebSolution,\n        selection_callback: Callable[[Person], Any],\n        limit: int = 10,\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        # parameters\n        self.solution = solution\n        self.selection_callback = selection_callback\n        self.limit = limit\n        # instance variables\n        self.suggested_persons: List[Person] = []\n        self.selected_person: Optional[Person] = None\n        self.suggestion_view: Optional[ui.element] = None\n        self.search_name = \"\"\n        self.person_lookup = PersonLookup(nqm=solution.webserver.nqm)\n        self.selection_btn: Optional[Button] = None\n        self.debouncer_ui = DebouncerUI(parent=self.solution.container, debug=True)\n        self.person_selection()\n\n    @ui.refreshable\n    def person_selection(self):\n        \"\"\"\n        Display input fields for person data with auto-suggestion\n        \"\"\"\n        person = self.selected_person if self.selected_person else Person()\n        with ui.element(\"row\").classes(\"w-full h-full\"):\n            with ui.splitter().classes(\"h-full  w-full\") as splitter:\n                with splitter.before:\n                    with ui.row() as self.top_row:\n                        pass\n                    with ui.card() as self.selection_card:\n                        with ui.row():\n                            self.label = ui.label(\"Name or Pid:\")\n                        with ui.row():\n                            self.name_input = ui.input(\n                                label=\"name\",\n                                placeholder=\"Tim Berners-Lee\",\n                                on_change=self.suggest_persons,\n                                value=self.search_name,\n                            ).props(\"size=60\")\n                        with ui.row():\n                            self.identifier_input = ui.input(\n                                label=\"PID\",\n                                placeholder=\"Q80\",\n                                on_change=self.check_pid,\n                                value=person.wikidata_id,\n                            ).props(\"size=20\")\n                        # if self.selection_btn is None:\n                        self.selection_btn = ui.button(text=\"Continue\", on_click=self.btn_selection_callback)\n                        self.selection_btn.disable()\n            with splitter.after:\n                with ui.element(\"column\").classes(\" w-full h-full gap-2\"):\n                    self.suggestion_view = ui.column().classes(\"rounded-md border-2 p-3\")\n\n    async def btn_selection_callback(self):\n        person = Person()\n        pid_value = PIDs().pid4id(self.identifier_input.value)\n        if pid_value.pid.name == \"Wikidata\":\n            person.wikidata_id = self.identifier_input.value\n        elif pid_value.pid.name == \"dblp\":\n            person.dblp_id = self.identifier_input.value\n        elif pid_value.pid.name == \"ORCID\":\n            person.orcid_id = self.identifier_input.value\n        person.label = self.name_input.value\n        self.selection_callback(person)\n\n    async def check_pid(self):\n        pid = PIDs().pid4id(self.identifier_input.value)\n        if pid is not None and pid.is_valid() and self.selection_btn is not None:\n            self.selection_btn.enable()\n        elif self.selection_btn:\n            self.selection_btn.disable()\n\n    def clear_suggested_persons(self):\n        self.suggested_persons = []\n        self.update_suggestions_view()\n\n    async def suggest_persons(self):\n        \"\"\"\n        Use debouncer to\n        suggest potential persons based on the input.\n        \"\"\"\n        await self.debouncer_ui.debounce(self.load_person_suggestions, self.name_input.value)\n\n    async def load_person_suggestions(self, search_name: str):\n        \"\"\"\n        Load person suggestions based on the search name.\n        This method fetches data concurrently from multiple sources and updates suggestions as they arrive.\n\n        Args:\n            search_name(str): the search name to search for\n        \"\"\"\n        if len(search_name) &lt; 4:  # Skip querying for very short input strings.\n            return\n        try:\n            self.clear_suggested_persons()\n            tasks = [\n                asyncio.to_thread(self.person_lookup.suggest_from_wikidata, search_name, self.limit),\n                asyncio.to_thread(self.person_lookup.suggest_from_orcid, search_name, self.limit),\n                asyncio.to_thread(self.person_lookup.suggest_from_dblp, search_name, self.limit),\n            ]\n            for future in asyncio.as_completed(tasks):\n                new_persons = await future\n                self.merge_and_update_suggestions(new_persons)\n                self.update_suggestions_view()\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def merge_and_update_suggestions(self, new_persons: List[Person]):\n        \"\"\"\n        Merges new persons with existing ones based on shared identifiers or adds them if unique.\n        Ensures no duplicates are present in the list of suggested persons.\n\n        Args:\n            new_persons (List[Person]): New person suggestions to be added or merged.\n        \"\"\"\n        for new_person in new_persons:\n            merged = False\n            for existing_person in self.suggested_persons:\n                if existing_person.share_identifier(new_person):\n                    existing_person.merge_with(new_person)\n                    merged = True\n                    break\n            if not merged:\n                self.suggested_persons.append(new_person)\n\n    def update_suggestions_view(self):\n        \"\"\"\n        update the suggestions view\n        \"\"\"\n        if self.suggestion_view:\n            self.suggestion_view.clear()\n            with self.suggestion_view:\n                with ui.list().props(\"bordered separator\"):\n                    ui.item_label(\"Suggestions\").props(\"header\").classes(\"text-bold\")\n                    ui.separator()\n                    for person in self.suggested_persons[: self.limit]:\n                        PersonSuggestion(person=person, on_select=self.selection_callback)\n\n                    if len(self.suggested_persons) &gt; self.limit:\n                        with ui.item():\n                            ui.label(\n                                f\"{'&gt;' if len(self.suggested_persons) &gt;= 10000 else ''}{len(self.suggested_persons)} matches are available...\"\n                            )\n            return []\n\n    def select_person_suggestion(self, person: Person):\n        \"\"\"\n        Select the given Person by updating the input fields to the selected person and storing the object internally\n        Args:\n            person: person that should be selected\n        \"\"\"\n        self.selected_person = person\n        self.person_selection.refresh()\n        self.suggested_persons = [person]\n        self.update_suggestions_list()\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSelector.__init__","title":"<code>__init__(solution, selection_callback, limit=10)</code>","text":"<p>Constructor</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>def __init__(\n    self,\n    solution: WebSolution,\n    selection_callback: Callable[[Person], Any],\n    limit: int = 10,\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    # parameters\n    self.solution = solution\n    self.selection_callback = selection_callback\n    self.limit = limit\n    # instance variables\n    self.suggested_persons: List[Person] = []\n    self.selected_person: Optional[Person] = None\n    self.suggestion_view: Optional[ui.element] = None\n    self.search_name = \"\"\n    self.person_lookup = PersonLookup(nqm=solution.webserver.nqm)\n    self.selection_btn: Optional[Button] = None\n    self.debouncer_ui = DebouncerUI(parent=self.solution.container, debug=True)\n    self.person_selection()\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSelector.load_person_suggestions","title":"<code>load_person_suggestions(search_name)</code>  <code>async</code>","text":"<p>Load person suggestions based on the search name. This method fetches data concurrently from multiple sources and updates suggestions as they arrive.</p> <p>Parameters:</p> Name Type Description Default <code>search_name(str)</code> <p>the search name to search for</p> required Source code in <code>snapquery/person_selector.py</code> <pre><code>async def load_person_suggestions(self, search_name: str):\n    \"\"\"\n    Load person suggestions based on the search name.\n    This method fetches data concurrently from multiple sources and updates suggestions as they arrive.\n\n    Args:\n        search_name(str): the search name to search for\n    \"\"\"\n    if len(search_name) &lt; 4:  # Skip querying for very short input strings.\n        return\n    try:\n        self.clear_suggested_persons()\n        tasks = [\n            asyncio.to_thread(self.person_lookup.suggest_from_wikidata, search_name, self.limit),\n            asyncio.to_thread(self.person_lookup.suggest_from_orcid, search_name, self.limit),\n            asyncio.to_thread(self.person_lookup.suggest_from_dblp, search_name, self.limit),\n        ]\n        for future in asyncio.as_completed(tasks):\n            new_persons = await future\n            self.merge_and_update_suggestions(new_persons)\n            self.update_suggestions_view()\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSelector.merge_and_update_suggestions","title":"<code>merge_and_update_suggestions(new_persons)</code>","text":"<p>Merges new persons with existing ones based on shared identifiers or adds them if unique. Ensures no duplicates are present in the list of suggested persons.</p> <p>Parameters:</p> Name Type Description Default <code>new_persons</code> <code>List[Person]</code> <p>New person suggestions to be added or merged.</p> required Source code in <code>snapquery/person_selector.py</code> <pre><code>def merge_and_update_suggestions(self, new_persons: List[Person]):\n    \"\"\"\n    Merges new persons with existing ones based on shared identifiers or adds them if unique.\n    Ensures no duplicates are present in the list of suggested persons.\n\n    Args:\n        new_persons (List[Person]): New person suggestions to be added or merged.\n    \"\"\"\n    for new_person in new_persons:\n        merged = False\n        for existing_person in self.suggested_persons:\n            if existing_person.share_identifier(new_person):\n                existing_person.merge_with(new_person)\n                merged = True\n                break\n        if not merged:\n            self.suggested_persons.append(new_person)\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSelector.person_selection","title":"<code>person_selection()</code>","text":"<p>Display input fields for person data with auto-suggestion</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>@ui.refreshable\ndef person_selection(self):\n    \"\"\"\n    Display input fields for person data with auto-suggestion\n    \"\"\"\n    person = self.selected_person if self.selected_person else Person()\n    with ui.element(\"row\").classes(\"w-full h-full\"):\n        with ui.splitter().classes(\"h-full  w-full\") as splitter:\n            with splitter.before:\n                with ui.row() as self.top_row:\n                    pass\n                with ui.card() as self.selection_card:\n                    with ui.row():\n                        self.label = ui.label(\"Name or Pid:\")\n                    with ui.row():\n                        self.name_input = ui.input(\n                            label=\"name\",\n                            placeholder=\"Tim Berners-Lee\",\n                            on_change=self.suggest_persons,\n                            value=self.search_name,\n                        ).props(\"size=60\")\n                    with ui.row():\n                        self.identifier_input = ui.input(\n                            label=\"PID\",\n                            placeholder=\"Q80\",\n                            on_change=self.check_pid,\n                            value=person.wikidata_id,\n                        ).props(\"size=20\")\n                    # if self.selection_btn is None:\n                    self.selection_btn = ui.button(text=\"Continue\", on_click=self.btn_selection_callback)\n                    self.selection_btn.disable()\n        with splitter.after:\n            with ui.element(\"column\").classes(\" w-full h-full gap-2\"):\n                self.suggestion_view = ui.column().classes(\"rounded-md border-2 p-3\")\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSelector.select_person_suggestion","title":"<code>select_person_suggestion(person)</code>","text":"<p>Select the given Person by updating the input fields to the selected person and storing the object internally Args:     person: person that should be selected</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>def select_person_suggestion(self, person: Person):\n    \"\"\"\n    Select the given Person by updating the input fields to the selected person and storing the object internally\n    Args:\n        person: person that should be selected\n    \"\"\"\n    self.selected_person = person\n    self.person_selection.refresh()\n    self.suggested_persons = [person]\n    self.update_suggestions_list()\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSelector.suggest_persons","title":"<code>suggest_persons()</code>  <code>async</code>","text":"<p>Use debouncer to suggest potential persons based on the input.</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>async def suggest_persons(self):\n    \"\"\"\n    Use debouncer to\n    suggest potential persons based on the input.\n    \"\"\"\n    await self.debouncer_ui.debounce(self.load_person_suggestions, self.name_input.value)\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSelector.update_suggestions_view","title":"<code>update_suggestions_view()</code>","text":"<p>update the suggestions view</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>def update_suggestions_view(self):\n    \"\"\"\n    update the suggestions view\n    \"\"\"\n    if self.suggestion_view:\n        self.suggestion_view.clear()\n        with self.suggestion_view:\n            with ui.list().props(\"bordered separator\"):\n                ui.item_label(\"Suggestions\").props(\"header\").classes(\"text-bold\")\n                ui.separator()\n                for person in self.suggested_persons[: self.limit]:\n                    PersonSuggestion(person=person, on_select=self.selection_callback)\n\n                if len(self.suggested_persons) &gt; self.limit:\n                    with ui.item():\n                        ui.label(\n                            f\"{'&gt;' if len(self.suggested_persons) &gt;= 10000 else ''}{len(self.suggested_persons)} matches are available...\"\n                        )\n        return []\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSuggestion","title":"<code>PersonSuggestion</code>","text":"<p>               Bases: <code>PersonView</code></p> <p>Display a Person</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>class PersonSuggestion(PersonView):\n    \"\"\"\n    Display a Person\n    \"\"\"\n\n    def __init__(self, person: Person, on_select: Callable[[Person], Any]):\n        super().__init__(person=person)\n        self._on_select_callback = on_select\n        self.person_card.on_click(self.on_select)\n\n    def on_select(self):\n        \"\"\"\n        Handle selection of the suggestion card\n        \"\"\"\n        return self._on_select_callback(self.person)\n</code></pre>"},{"location":"#snapquery.person_selector.PersonSuggestion.on_select","title":"<code>on_select()</code>","text":"<p>Handle selection of the suggestion card</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>def on_select(self):\n    \"\"\"\n    Handle selection of the suggestion card\n    \"\"\"\n    return self._on_select_callback(self.person)\n</code></pre>"},{"location":"#snapquery.person_selector.PersonView","title":"<code>PersonView</code>","text":"<p>               Bases: <code>Element</code></p> <p>Display a person</p> Source code in <code>snapquery/person_selector.py</code> <pre><code>class PersonView(Element):\n    \"\"\"\n    Display a person\n    \"\"\"\n\n    def __init__(self, person: Person):\n        self.pids = PIDs()\n        self.pid_values = self._create_pid_values(person)\n        super().__init__(tag=\"div\")\n        self.person = person\n        with self:\n            with ui.item() as self.person_card:\n                with ui.item_section().props(\"avatar\"):\n                    with ui.avatar():\n                        if person.image:\n                            ui.image(source=person.image)\n                with ui.item_section():\n                    with ui.row():\n                        self.person_label = ui.label(self.person.label)\n                    with ui.row():\n                        self.person_name = ui.label(f\"{self.person.given_name} {self.person.family_name}\")\n                    with ui.row():\n                        self._show_identifier()\n\n    def _create_pid_values(self, person: Person) -&gt; List[PIDValue]:\n        \"\"\"\n        Create PIDValue instances for the person's identifiers\n        \"\"\"\n        pid_values = []\n        for pid_key, pid in self.pids.pids.items():\n            attr = f\"{pid_key}_id\"\n            pid_value = getattr(person, attr, None)\n            if pid_value:\n                pid_values.append(PIDValue(pid=pid, value=pid_value))\n        return pid_values\n\n    def _show_identifier(self):\n        \"\"\"\n        Display all identifiers of the person\n        \"\"\"\n        for pid_value in self.pid_values:\n            with ui.element(\"div\"):\n                ui.avatar(\n                    icon=f\"img:{pid_value.pid.logo}\",\n                    color=None,\n                    size=\"sm\",\n                    square=True,\n                )\n                ui.link(\n                    text=pid_value.value,\n                    target=pid_value.url,\n                    new_tab=True,\n                )\n</code></pre>"},{"location":"#snapquery.pid","title":"<code>pid</code>","text":"<p>Created on 2024-05-26 @author: wf</p>"},{"location":"#snapquery.pid.PID","title":"<code>PID</code>  <code>dataclass</code>","text":"<p>A persistent identifier source e.g. ORCID, dblpID or wikidata id</p> Source code in <code>snapquery/pid.py</code> <pre><code>@dataclass\nclass PID:\n    \"\"\"\n    A persistent identifier source e.g. ORCID, dblpID or wikidata id\n    \"\"\"\n\n    name: str\n    logo: str\n    formatter_url: str\n    regex: str\n</code></pre>"},{"location":"#snapquery.pid.PIDValue","title":"<code>PIDValue</code>  <code>dataclass</code>","text":"<p>Represents a specific instance of a persistent identifier with its value.</p> Source code in <code>snapquery/pid.py</code> <pre><code>@dataclass\nclass PIDValue:\n    \"\"\"\n    Represents a specific instance of a persistent identifier with its value.\n    \"\"\"\n\n    pid: PID\n    value: str\n\n    @property\n    def url(self) -&gt; str:\n        return self.pid.formatter_url.format(self.value)\n\n    @property\n    def html(self) -&gt; str:\n        return f'&lt;a href=\"{self.url}\"&gt;&lt;img src=\"{self.pid.logo}\" alt=\"{self.pid.name} logo\"&gt; {self.value}&lt;/a&gt;'\n\n    def is_valid(self) -&gt; bool:\n        return re.match(self.pid.regex, self.value) is not None\n</code></pre>"},{"location":"#snapquery.pid.PIDs","title":"<code>PIDs</code>","text":"<p>Available PIDs</p> Source code in <code>snapquery/pid.py</code> <pre><code>class PIDs:\n    \"\"\"\n    Available PIDs\n    \"\"\"\n\n    def __init__(self):\n        self.pids = {\n            \"orcid\": PID(\n                name=\"ORCID\",\n                logo=\"https://orcid.org/sites/default/files/images/orcid_16x16.png\",\n                formatter_url=\"https://orcid.org/{}\",\n                regex=r\"^\\d{4}-\\d{4}-\\d{4}-\\d{3}[0-9X]$\",\n            ),\n            \"dblp\": PID(\n                name=\"dblp\",\n                logo=\"https://dblp.org/img/dblp-icon-64x64.png\",\n                formatter_url=\"https://dblp.org/pid/{}\",\n                regex=r\"^[a-z0-9/]+$\",\n            ),\n            \"wikidata\": PID(\n                name=\"Wikidata\",\n                logo=\"https://www.wikidata.org/static/favicon/wikidata.ico\",\n                formatter_url=\"https://www.wikidata.org/wiki/{}\",\n                regex=r\"^Q[0-9]+$\",\n            ),\n        }\n\n    def pid4id(self, identifier: str) -&gt; Optional[PIDValue]:\n        \"\"\"\n        Create a PIDValue instance based on the identifier type.\n        \"\"\"\n        for _key, pid in self.pids.items():\n            if re.match(pid.regex, identifier):\n                return PIDValue(pid=pid, value=identifier)\n        return None\n</code></pre>"},{"location":"#snapquery.pid.PIDs.pid4id","title":"<code>pid4id(identifier)</code>","text":"<p>Create a PIDValue instance based on the identifier type.</p> Source code in <code>snapquery/pid.py</code> <pre><code>def pid4id(self, identifier: str) -&gt; Optional[PIDValue]:\n    \"\"\"\n    Create a PIDValue instance based on the identifier type.\n    \"\"\"\n    for _key, pid in self.pids.items():\n        if re.match(pid.regex, identifier):\n            return PIDValue(pid=pid, value=identifier)\n    return None\n</code></pre>"},{"location":"#snapquery.pid_lookup","title":"<code>pid_lookup</code>","text":"<p>Created on 2024-05-26 @author: wf</p>"},{"location":"#snapquery.pid_lookup.PersonLookup","title":"<code>PersonLookup</code>","text":"<p>Lookup potential persons from various databases such as Wikidata, ORCID, and DBLP.</p> Source code in <code>snapquery/pid_lookup.py</code> <pre><code>class PersonLookup:\n    \"\"\"\n    Lookup potential persons from various\n    databases such as Wikidata, ORCID, and DBLP.\n    \"\"\"\n\n    def __init__(self, nqm: NamedQueryManager):\n        \"\"\"\n        Initialize the PersonLookup with a Named Query Manager.\n\n        Args:\n            nqm (NamedQueryManager): The named query manager to execute SPARQL queries.\n        \"\"\"\n        self.pids = PIDs()\n        self.nqm = nqm\n        self.wikidata_search = WikidataSearch()\n        self.dblp_person_lookup = DblpPersonLookup(self.nqm)\n\n    def suggest_from_wikidata(self, search_name: str, limit: int = 10) -&gt; List[Person]:\n        \"\"\"\n        Suggest persons using WikidataSearch.\n\n        Args:\n            search_name (str): The name to search for suggestions.\n            limit (int): The maximum number of results to return.\n\n        Returns:\n            List[Person]: A list of suggested persons from Wikidata.\n        \"\"\"\n        persons = []\n        suggestions = self.wikidata_search.searchOptions(search_name, limit=limit)\n        qid_list = \"\"\n        delim = \"\"\n        for qid, _plabel, _pdesc in suggestions:\n            qid_list += f\"{delim}wd:{qid}\"\n            delim = \" \"\n        named_query = NamedQuery(\n            domain=\"wikidata.org\",\n            namespace=\"pid-lookup\",\n            name=\"person-by-qid\",\n            title=\"Lookup persons with the given qids\",\n            description=\"based on a pre-search with wikidata search select persons\",\n            sparql=\"\"\"# snapquery person lookup \nSELECT *\nWHERE \n{\n  VALUES ?scholar {\n    {{ qid_list }}\n  } \n  ?scholar wdt:P31 wd:Q5 .\n  ?scholar wdt:P735 ?given_name_qid .\n  ?given_name_qid rdfs:label ?given_name .\n  ?scholar wdt:P734 ?family_name_qid .\n  ?family_name_qid rdfs:label ?family_name .\n  OPTIONAL{{ ?scholar rdfs:label ?label FILTER(lang(?label) = \"en\") }}.\n  OPTIONAL{{?scholar wdt:P2456 ?dblp_author_id .}}\n  OPTIONAL{{?scholar wdt:P496 ?orcid_id . }}\n  OPTIONAL{{?scholar wdt:P18 ?image . }}\n  FILTER(lang(?given_name) = \"en\")\n  FILTER(lang(?family_name) = \"en\")\n}\n            \"\"\",\n        )\n        params_dict = {\"qid_list\": qid_list}\n        person_lod, stats = self.nqm.execute_query(\n            named_query=named_query,\n            params_dict=params_dict,\n            limit=limit,\n            with_stats=False,\n        )\n        for pr in person_lod:\n            person = Person(\n                label=pr.get(\"label\"),\n                given_name=pr.get(\"given_name\"),\n                family_name=pr.get(\"family_name\"),\n                wikidata_id=pr.get(\"scholar\").split(\"/\")[-1],\n                dblp_author_id=pr.get(\"dblp_author_id\"),\n                orcid_id=pr.get(\"orcid_id\"),\n                image=pr.get(\"image\"),\n            )\n            persons.append(person)\n\n        return persons\n\n    def suggest_from_orcid(self, search_name: str, limit: int = 10) -&gt; List[Person]:\n        \"\"\"\n        Suggest persons using the ORCID registry search.\n\n        Args:\n            search_name (str): The name to search for suggestions.\n            limit (int): The maximum number of results to return.\n\n        Returns:\n            List[Person]: A list of suggested persons from ORCID.\n        \"\"\"\n        orcid = OrcidAuth()\n        persons = []\n        if orcid.available():\n            persons = orcid.search(OrcidSearchParams(family_name=search_name), limit=limit)\n        return persons\n\n    def suggest_from_dblp(self, search_name: str, limit: int = 10) -&gt; List[Person]:\n        \"\"\"\n        Suggest persons using DBLP author search.\n\n        Args:\n            search_name (str): The name to search for suggestions.\n            limit (int): The maximum number of results to return.\n\n        Returns:\n            List[Person]: A list of suggested persons from DBLP.\n        \"\"\"\n        persons = self.dblp_person_lookup.search(name_part=search_name, limit=limit)\n        return persons\n</code></pre>"},{"location":"#snapquery.pid_lookup.PersonLookup.__init__","title":"<code>__init__(nqm)</code>","text":"<p>Initialize the PersonLookup with a Named Query Manager.</p> <p>Parameters:</p> Name Type Description Default <code>nqm</code> <code>NamedQueryManager</code> <p>The named query manager to execute SPARQL queries.</p> required Source code in <code>snapquery/pid_lookup.py</code> <pre><code>def __init__(self, nqm: NamedQueryManager):\n    \"\"\"\n    Initialize the PersonLookup with a Named Query Manager.\n\n    Args:\n        nqm (NamedQueryManager): The named query manager to execute SPARQL queries.\n    \"\"\"\n    self.pids = PIDs()\n    self.nqm = nqm\n    self.wikidata_search = WikidataSearch()\n    self.dblp_person_lookup = DblpPersonLookup(self.nqm)\n</code></pre>"},{"location":"#snapquery.pid_lookup.PersonLookup.suggest_from_dblp","title":"<code>suggest_from_dblp(search_name, limit=10)</code>","text":"<p>Suggest persons using DBLP author search.</p> <p>Parameters:</p> Name Type Description Default <code>search_name</code> <code>str</code> <p>The name to search for suggestions.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>List[Person]</code> <p>List[Person]: A list of suggested persons from DBLP.</p> Source code in <code>snapquery/pid_lookup.py</code> <pre><code>def suggest_from_dblp(self, search_name: str, limit: int = 10) -&gt; List[Person]:\n    \"\"\"\n    Suggest persons using DBLP author search.\n\n    Args:\n        search_name (str): The name to search for suggestions.\n        limit (int): The maximum number of results to return.\n\n    Returns:\n        List[Person]: A list of suggested persons from DBLP.\n    \"\"\"\n    persons = self.dblp_person_lookup.search(name_part=search_name, limit=limit)\n    return persons\n</code></pre>"},{"location":"#snapquery.pid_lookup.PersonLookup.suggest_from_orcid","title":"<code>suggest_from_orcid(search_name, limit=10)</code>","text":"<p>Suggest persons using the ORCID registry search.</p> <p>Parameters:</p> Name Type Description Default <code>search_name</code> <code>str</code> <p>The name to search for suggestions.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>List[Person]</code> <p>List[Person]: A list of suggested persons from ORCID.</p> Source code in <code>snapquery/pid_lookup.py</code> <pre><code>def suggest_from_orcid(self, search_name: str, limit: int = 10) -&gt; List[Person]:\n    \"\"\"\n    Suggest persons using the ORCID registry search.\n\n    Args:\n        search_name (str): The name to search for suggestions.\n        limit (int): The maximum number of results to return.\n\n    Returns:\n        List[Person]: A list of suggested persons from ORCID.\n    \"\"\"\n    orcid = OrcidAuth()\n    persons = []\n    if orcid.available():\n        persons = orcid.search(OrcidSearchParams(family_name=search_name), limit=limit)\n    return persons\n</code></pre>"},{"location":"#snapquery.pid_lookup.PersonLookup.suggest_from_wikidata","title":"<code>suggest_from_wikidata(search_name, limit=10)</code>","text":"<p>Suggest persons using WikidataSearch.</p> <p>Parameters:</p> Name Type Description Default <code>search_name</code> <code>str</code> <p>The name to search for suggestions.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>List[Person]</code> <p>List[Person]: A list of suggested persons from Wikidata.</p> Source code in <code>snapquery/pid_lookup.py</code> <pre><code>    def suggest_from_wikidata(self, search_name: str, limit: int = 10) -&gt; List[Person]:\n        \"\"\"\n        Suggest persons using WikidataSearch.\n\n        Args:\n            search_name (str): The name to search for suggestions.\n            limit (int): The maximum number of results to return.\n\n        Returns:\n            List[Person]: A list of suggested persons from Wikidata.\n        \"\"\"\n        persons = []\n        suggestions = self.wikidata_search.searchOptions(search_name, limit=limit)\n        qid_list = \"\"\n        delim = \"\"\n        for qid, _plabel, _pdesc in suggestions:\n            qid_list += f\"{delim}wd:{qid}\"\n            delim = \" \"\n        named_query = NamedQuery(\n            domain=\"wikidata.org\",\n            namespace=\"pid-lookup\",\n            name=\"person-by-qid\",\n            title=\"Lookup persons with the given qids\",\n            description=\"based on a pre-search with wikidata search select persons\",\n            sparql=\"\"\"# snapquery person lookup \nSELECT *\nWHERE \n{\n  VALUES ?scholar {\n    {{ qid_list }}\n  } \n  ?scholar wdt:P31 wd:Q5 .\n  ?scholar wdt:P735 ?given_name_qid .\n  ?given_name_qid rdfs:label ?given_name .\n  ?scholar wdt:P734 ?family_name_qid .\n  ?family_name_qid rdfs:label ?family_name .\n  OPTIONAL{{ ?scholar rdfs:label ?label FILTER(lang(?label) = \"en\") }}.\n  OPTIONAL{{?scholar wdt:P2456 ?dblp_author_id .}}\n  OPTIONAL{{?scholar wdt:P496 ?orcid_id . }}\n  OPTIONAL{{?scholar wdt:P18 ?image . }}\n  FILTER(lang(?given_name) = \"en\")\n  FILTER(lang(?family_name) = \"en\")\n}\n            \"\"\",\n        )\n        params_dict = {\"qid_list\": qid_list}\n        person_lod, stats = self.nqm.execute_query(\n            named_query=named_query,\n            params_dict=params_dict,\n            limit=limit,\n            with_stats=False,\n        )\n        for pr in person_lod:\n            person = Person(\n                label=pr.get(\"label\"),\n                given_name=pr.get(\"given_name\"),\n                family_name=pr.get(\"family_name\"),\n                wikidata_id=pr.get(\"scholar\").split(\"/\")[-1],\n                dblp_author_id=pr.get(\"dblp_author_id\"),\n                orcid_id=pr.get(\"orcid_id\"),\n                image=pr.get(\"image\"),\n            )\n            persons.append(person)\n\n        return persons\n</code></pre>"},{"location":"#snapquery.qimport","title":"<code>qimport</code>","text":"<p>Created on 2024-05-05</p> <p>@author: wf</p>"},{"location":"#snapquery.qimport.QueryImport","title":"<code>QueryImport</code>","text":"<p>Import named queries from a given URL or file.</p> Source code in <code>snapquery/qimport.py</code> <pre><code>class QueryImport:\n    \"\"\"\n    Import named queries from a given URL or file.\n    \"\"\"\n\n    def __init__(self, nqm: NamedQueryManager = None):\n        \"\"\"\n        Constructor\n\n        Args:\n            nqm (NamedQueryManager, optional): The NamedQueryManager to use for storing queries.\n        \"\"\"\n        self.nqm = nqm\n        pass\n\n    def import_samples(self, with_store: bool = True, show_progress: bool = False):\n        \"\"\"\n        import all sample json files\n\n        Args:\n            with_store(bool): if True store the result\n            show_progress(bool): if True show a tqdm progress bar\n        \"\"\"\n        for json_file in glob.glob(os.path.join(self.nqm.samples_path, \"*.json\")):\n            try:\n                nq_list = self.import_from_json_file(json_file, with_store, show_progress)\n            except Exception as ex:\n                print(f\"could not load json_file {json_file}\")\n                raise ex\n            if \"ceur\" in json_file:\n                json_file_name = os.path.basename(json_file)\n                output_path = os.path.join(\"/tmp\", json_file_name)\n                nq_list.save_to_json_file(output_path, indent=2)\n                pass\n\n    def import_from_json_file(\n        self, json_file: str, with_store: bool = False, show_progress: bool = False\n    ) -&gt; NamedQuerySet:\n        \"\"\"\n        Import named queries from a JSON file.\n\n        Args:\n            json_file (str): Path to the JSON file.\n            with_store (bool): If True, store the results in the NamedQueryManager.\n            show_progress (bool): If True, show a progress bar during the import.\n\n        Returns:\n            NamedQuerySet: A NamedQuerySet object containing the imported NamedQuery objects.\n        \"\"\"\n        nq_set = NamedQuerySet.load_from_json_file(json_file)\n        iterable = (\n            tqdm(\n                nq_set.queries,\n                desc=f\"Importing Namespace {nq_set.namespace}@{nq_set.domain}\",\n            )\n            if show_progress\n            else nq_set.queries\n        )\n\n        for nq in iterable:\n            if not nq.sparql:\n                if nq.url and nq.url.startswith(\"https://w.wiki/\"):\n                    short_url = ShortUrl(nq.url)\n                    nq.sparql = short_url.read_query()\n                else:\n                    raise Exception(f\"invalid named query with no url: {nq}\")\n                    # what now?\n                    continue\n            if with_store and self.nqm:\n                self.nqm.add_and_store(nq)\n        return nq_set\n</code></pre>"},{"location":"#snapquery.qimport.QueryImport.__init__","title":"<code>__init__(nqm=None)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>nqm</code> <code>NamedQueryManager</code> <p>The NamedQueryManager to use for storing queries.</p> <code>None</code> Source code in <code>snapquery/qimport.py</code> <pre><code>def __init__(self, nqm: NamedQueryManager = None):\n    \"\"\"\n    Constructor\n\n    Args:\n        nqm (NamedQueryManager, optional): The NamedQueryManager to use for storing queries.\n    \"\"\"\n    self.nqm = nqm\n    pass\n</code></pre>"},{"location":"#snapquery.qimport.QueryImport.import_from_json_file","title":"<code>import_from_json_file(json_file, with_store=False, show_progress=False)</code>","text":"<p>Import named queries from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>json_file</code> <code>str</code> <p>Path to the JSON file.</p> required <code>with_store</code> <code>bool</code> <p>If True, store the results in the NamedQueryManager.</p> <code>False</code> <code>show_progress</code> <code>bool</code> <p>If True, show a progress bar during the import.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>NamedQuerySet</code> <code>NamedQuerySet</code> <p>A NamedQuerySet object containing the imported NamedQuery objects.</p> Source code in <code>snapquery/qimport.py</code> <pre><code>def import_from_json_file(\n    self, json_file: str, with_store: bool = False, show_progress: bool = False\n) -&gt; NamedQuerySet:\n    \"\"\"\n    Import named queries from a JSON file.\n\n    Args:\n        json_file (str): Path to the JSON file.\n        with_store (bool): If True, store the results in the NamedQueryManager.\n        show_progress (bool): If True, show a progress bar during the import.\n\n    Returns:\n        NamedQuerySet: A NamedQuerySet object containing the imported NamedQuery objects.\n    \"\"\"\n    nq_set = NamedQuerySet.load_from_json_file(json_file)\n    iterable = (\n        tqdm(\n            nq_set.queries,\n            desc=f\"Importing Namespace {nq_set.namespace}@{nq_set.domain}\",\n        )\n        if show_progress\n        else nq_set.queries\n    )\n\n    for nq in iterable:\n        if not nq.sparql:\n            if nq.url and nq.url.startswith(\"https://w.wiki/\"):\n                short_url = ShortUrl(nq.url)\n                nq.sparql = short_url.read_query()\n            else:\n                raise Exception(f\"invalid named query with no url: {nq}\")\n                # what now?\n                continue\n        if with_store and self.nqm:\n            self.nqm.add_and_store(nq)\n    return nq_set\n</code></pre>"},{"location":"#snapquery.qimport.QueryImport.import_samples","title":"<code>import_samples(with_store=True, show_progress=False)</code>","text":"<p>import all sample json files</p> <p>Parameters:</p> Name Type Description Default <code>with_store(bool)</code> <p>if True store the result</p> required <code>show_progress(bool)</code> <p>if True show a tqdm progress bar</p> required Source code in <code>snapquery/qimport.py</code> <pre><code>def import_samples(self, with_store: bool = True, show_progress: bool = False):\n    \"\"\"\n    import all sample json files\n\n    Args:\n        with_store(bool): if True store the result\n        show_progress(bool): if True show a tqdm progress bar\n    \"\"\"\n    for json_file in glob.glob(os.path.join(self.nqm.samples_path, \"*.json\")):\n        try:\n            nq_list = self.import_from_json_file(json_file, with_store, show_progress)\n        except Exception as ex:\n            print(f\"could not load json_file {json_file}\")\n            raise ex\n        if \"ceur\" in json_file:\n            json_file_name = os.path.basename(json_file)\n            output_path = os.path.join(\"/tmp\", json_file_name)\n            nq_list.save_to_json_file(output_path, indent=2)\n            pass\n</code></pre>"},{"location":"#snapquery.qimport_view","title":"<code>qimport_view</code>","text":"<p>Created on 2024-05-05</p> <p>@author: wf</p>"},{"location":"#snapquery.qimport_view.QueryImportView","title":"<code>QueryImportView</code>","text":"<p>display Query Import UI</p> Source code in <code>snapquery/qimport_view.py</code> <pre><code>class QueryImportView:\n    \"\"\"\n    display Query Import UI\n    \"\"\"\n\n    def __init__(\n        self,\n        solution=None,\n        person: Optional[Person] = None,\n        allow_importing_from_url: bool = True,\n    ):\n        self.person = person\n        self.solution = solution\n        self.allow_importing_from_url = allow_importing_from_url\n        self.namespace = \"\"\n        self.name = \"\"\n        self.url = \"\"\n        self.title = \"\"\n        self.description = \"\"\n        self.comment = \"\"\n        self.query = None\n        if self.solution:\n            self.qimport = QueryImport()\n            self.nqm = self.solution.nqm\n            self.setup_ui()\n\n    def setup_ui(self):\n        \"\"\"\n        setup the user interface\n        \"\"\"\n        with self.solution.container:\n            with ui.row() as self.input_row:\n                self.input_row.classes(\"h-full\")\n                ui.input(label=\"namespace\", placeholder=\"e.g. wikidata-examples\").bind_value(self, \"namespace\")\n                with ui.input(label=\"name\", placeholder=\"e.g. all proceedings of CEUR-WS\").bind_value(self, \"name\"):\n                    ui.tooltip(\"short name for query; needs to be unique within the namespace\")\n                ui.input(label=\"url\", placeholder=\"e.g. short url to the query\").props(\"size=80\").bind_value(\n                    self, \"url\"\n                )\n                if self.allow_importing_from_url:\n                    ui.button(icon=\"input\", text=\"Import Query\", on_click=self.on_input_button)\n                ui.button(icon=\"publish\", text=\"Publish Query\", on_click=self.on_import_button)\n                with ui.input(label=\"title\").props(\"size=80\").bind_value(self, \"title\"):\n                    ui.tooltip(\"Descriptive title of the query\")\n            self.query_row = ui.row().classes(\"w-full h-full flex \")\n            with self.query_row:\n                ui.textarea(label=\"query\").bind_value(self, \"query\").classes(\n                    \"w-full h-full resize min-h-80 border-solid m-5 border-gray-dark border-2 rounded-md\"\n                )\n            with ui.row() as self.details_row:\n                self.details_row.classes(\"flex\")\n                ui.textarea(label=\"description\").bind_value(self, \"description\").classes(\n                    \"w-1/2 border-solid m-5 border-gray-dark border-2 rounded-md\"\n                )\n                ui.textarea(label=\"comment\").bind_value(self, \"comment\").classes(\n                    \"w-2/5 border-solid m-5 border-gray-dark border-2 rounded-md\"\n                )\n                self.named_query_link = ui.html()\n\n    def on_import_button(self, _args):\n        \"\"\"\n        import a query\n        \"\"\"\n        if self.query is None:\n            with self.query_row:\n                ui.notify(\"input a query first\")\n            return\n        if self.person:\n            self.comment = f\"[query nominated by {self.person}] {self.comment}\"\n        nq_record = {\n            \"namespace\": self.namespace,\n            \"name\": self.name,\n            \"title\": self.title,\n            \"url\": self.url,\n            \"description\": self.description,\n            \"comment\": self.comment,\n            \"sparql\": self.query.query if isinstance(self.query, Query) else self.query,\n        }\n        nq = NamedQuery.from_record(nq_record)\n        self.nqm.add_and_store(nq)\n        with self.query_row:\n            ui.notify(f\"added named query {self.name}\")\n            self.named_query_link.content = nq.as_link()\n        self.clear_inputs()\n\n    def clear_inputs(self):\n        self.query = None\n        self.name = None\n        self.url = None\n        self.title = None\n        self.description = None\n        self.comment = None\n\n    def on_input_button(self, _args):\n        \"\"\"\n        imput a query\n        \"\"\"\n        self.query_row.clear()\n        with self.query_row:\n            ui.notify(f\"importing named query from {self.url}\")\n            sparql_query = self.qimport.read_from_short_url(self.url)\n            self.query = Query(name=self.name, title=self.title, lang=\"sparql\", query=sparql_query)\n            query_syntax_highlight = QuerySyntaxHighlight(self.query)\n            syntax_highlight_css = query_syntax_highlight.formatter.get_style_defs()\n            ui.add_css(syntax_highlight_css)\n            ui.html(query_syntax_highlight.highlight())\n</code></pre>"},{"location":"#snapquery.qimport_view.QueryImportView.on_import_button","title":"<code>on_import_button(_args)</code>","text":"<p>import a query</p> Source code in <code>snapquery/qimport_view.py</code> <pre><code>def on_import_button(self, _args):\n    \"\"\"\n    import a query\n    \"\"\"\n    if self.query is None:\n        with self.query_row:\n            ui.notify(\"input a query first\")\n        return\n    if self.person:\n        self.comment = f\"[query nominated by {self.person}] {self.comment}\"\n    nq_record = {\n        \"namespace\": self.namespace,\n        \"name\": self.name,\n        \"title\": self.title,\n        \"url\": self.url,\n        \"description\": self.description,\n        \"comment\": self.comment,\n        \"sparql\": self.query.query if isinstance(self.query, Query) else self.query,\n    }\n    nq = NamedQuery.from_record(nq_record)\n    self.nqm.add_and_store(nq)\n    with self.query_row:\n        ui.notify(f\"added named query {self.name}\")\n        self.named_query_link.content = nq.as_link()\n    self.clear_inputs()\n</code></pre>"},{"location":"#snapquery.qimport_view.QueryImportView.on_input_button","title":"<code>on_input_button(_args)</code>","text":"<p>imput a query</p> Source code in <code>snapquery/qimport_view.py</code> <pre><code>def on_input_button(self, _args):\n    \"\"\"\n    imput a query\n    \"\"\"\n    self.query_row.clear()\n    with self.query_row:\n        ui.notify(f\"importing named query from {self.url}\")\n        sparql_query = self.qimport.read_from_short_url(self.url)\n        self.query = Query(name=self.name, title=self.title, lang=\"sparql\", query=sparql_query)\n        query_syntax_highlight = QuerySyntaxHighlight(self.query)\n        syntax_highlight_css = query_syntax_highlight.formatter.get_style_defs()\n        ui.add_css(syntax_highlight_css)\n        ui.html(query_syntax_highlight.highlight())\n</code></pre>"},{"location":"#snapquery.qimport_view.QueryImportView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>setup the user interface</p> Source code in <code>snapquery/qimport_view.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    setup the user interface\n    \"\"\"\n    with self.solution.container:\n        with ui.row() as self.input_row:\n            self.input_row.classes(\"h-full\")\n            ui.input(label=\"namespace\", placeholder=\"e.g. wikidata-examples\").bind_value(self, \"namespace\")\n            with ui.input(label=\"name\", placeholder=\"e.g. all proceedings of CEUR-WS\").bind_value(self, \"name\"):\n                ui.tooltip(\"short name for query; needs to be unique within the namespace\")\n            ui.input(label=\"url\", placeholder=\"e.g. short url to the query\").props(\"size=80\").bind_value(\n                self, \"url\"\n            )\n            if self.allow_importing_from_url:\n                ui.button(icon=\"input\", text=\"Import Query\", on_click=self.on_input_button)\n            ui.button(icon=\"publish\", text=\"Publish Query\", on_click=self.on_import_button)\n            with ui.input(label=\"title\").props(\"size=80\").bind_value(self, \"title\"):\n                ui.tooltip(\"Descriptive title of the query\")\n        self.query_row = ui.row().classes(\"w-full h-full flex \")\n        with self.query_row:\n            ui.textarea(label=\"query\").bind_value(self, \"query\").classes(\n                \"w-full h-full resize min-h-80 border-solid m-5 border-gray-dark border-2 rounded-md\"\n            )\n        with ui.row() as self.details_row:\n            self.details_row.classes(\"flex\")\n            ui.textarea(label=\"description\").bind_value(self, \"description\").classes(\n                \"w-1/2 border-solid m-5 border-gray-dark border-2 rounded-md\"\n            )\n            ui.textarea(label=\"comment\").bind_value(self, \"comment\").classes(\n                \"w-2/5 border-solid m-5 border-gray-dark border-2 rounded-md\"\n            )\n            self.named_query_link = ui.html()\n</code></pre>"},{"location":"#snapquery.qlever","title":"<code>qlever</code>","text":"<p>Created on 2024-06-20</p> <p>@author: wf</p>"},{"location":"#snapquery.qlever.QLever","title":"<code>QLever</code>","text":"<p>handle https://github.com/ad-freiburg/qlever specifics</p> Source code in <code>snapquery/qlever.py</code> <pre><code>class QLever:\n    \"\"\"\n    handle https://github.com/ad-freiburg/qlever specifics\n    \"\"\"\n\n    def __init__(self, with_progress=True):\n        self.url = \"https://github.com/ad-freiburg/qlever\"\n        self.with_progress = with_progress\n        # Regex pattern to find URLs starting with the specified prefix\n        self.wd_url_pattern = re.compile(r\"https://qlever\\.cs\\.uni-freiburg\\.de/wikidata/[A-Za-z0-9]+\")\n        self.osproject = OsProject.fromUrl(self.url)\n\n    def wd_urls_for_ticket(self, ticket: Ticket) -&gt; List[str]:\n        \"\"\"\n        Extracts and returns all URLs from a ticket's body and comments that match the specified pattern.\n        \"\"\"\n        extracted_urls = []\n\n        # Extract URLs from the ticket body\n        if ticket.body:\n            found_urls = self.wd_url_pattern.findall(ticket.body)\n            extracted_urls.extend(found_urls)\n\n        # Fetch and extract URLs from comments\n        comments = self.osproject.ticketSystem.getComments(self.osproject, ticket.number)\n        for comment in comments:\n            found_urls = self.wd_url_pattern.findall(comment[\"body\"])\n            extracted_urls.extend(found_urls)\n\n        return extracted_urls\n\n    def named_queries_for_tickets(self, ticket_dict):\n        \"\"\"\n        Create named queries for each ticket's extracted URLs.\n\n        Args:\n            ticket_dict (dict): Dictionary mapping tickets to a list of URLs.\n\n        Returns:\n            NamedQuerySet: A set of named queries generated from the URLs.\n        \"\"\"\n        named_query_set = NamedQuerySet(\n            domain=\"qlever.cs.uni-freiburg.de\",\n            namespace=\"issues.wikidata\",\n            target_graph_name=\"wikidata\",\n        )\n        for ticket, urls in ticket_dict.items():\n            for i, url in enumerate(urls, 1):\n                # Assuming URLs are like 'https://qlever.cs.uni-freiburg.de/wikidata/iTzJwQ'\n                # Customizing ShortUrl instance for QLever specific URLs\n                short_url_handler = QLeverUrl(url)\n                short_url_handler.read_query()\n                if short_url_handler.sparql:\n                    # Example placeholder logic to create a NamedQuery for each URL\n                    query = NamedQuery(\n                        domain=named_query_set.domain,\n                        name=f\"Issue{ticket.number}-query{i}\",\n                        namespace=named_query_set.namespace,\n                        url=url,\n                        sparql=short_url_handler.sparql,\n                        title=f\"QLever github issue #{ticket.number}-query{i}\",\n                        description=ticket.title,\n                        comment=f\"See ticket {ticket.url} and query {url}\",\n                    )\n                    named_query_set.queries.append(query)\n        return named_query_set\n</code></pre>"},{"location":"#snapquery.qlever.QLever.named_queries_for_tickets","title":"<code>named_queries_for_tickets(ticket_dict)</code>","text":"<p>Create named queries for each ticket's extracted URLs.</p> <p>Parameters:</p> Name Type Description Default <code>ticket_dict</code> <code>dict</code> <p>Dictionary mapping tickets to a list of URLs.</p> required <p>Returns:</p> Name Type Description <code>NamedQuerySet</code> <p>A set of named queries generated from the URLs.</p> Source code in <code>snapquery/qlever.py</code> <pre><code>def named_queries_for_tickets(self, ticket_dict):\n    \"\"\"\n    Create named queries for each ticket's extracted URLs.\n\n    Args:\n        ticket_dict (dict): Dictionary mapping tickets to a list of URLs.\n\n    Returns:\n        NamedQuerySet: A set of named queries generated from the URLs.\n    \"\"\"\n    named_query_set = NamedQuerySet(\n        domain=\"qlever.cs.uni-freiburg.de\",\n        namespace=\"issues.wikidata\",\n        target_graph_name=\"wikidata\",\n    )\n    for ticket, urls in ticket_dict.items():\n        for i, url in enumerate(urls, 1):\n            # Assuming URLs are like 'https://qlever.cs.uni-freiburg.de/wikidata/iTzJwQ'\n            # Customizing ShortUrl instance for QLever specific URLs\n            short_url_handler = QLeverUrl(url)\n            short_url_handler.read_query()\n            if short_url_handler.sparql:\n                # Example placeholder logic to create a NamedQuery for each URL\n                query = NamedQuery(\n                    domain=named_query_set.domain,\n                    name=f\"Issue{ticket.number}-query{i}\",\n                    namespace=named_query_set.namespace,\n                    url=url,\n                    sparql=short_url_handler.sparql,\n                    title=f\"QLever github issue #{ticket.number}-query{i}\",\n                    description=ticket.title,\n                    comment=f\"See ticket {ticket.url} and query {url}\",\n                )\n                named_query_set.queries.append(query)\n    return named_query_set\n</code></pre>"},{"location":"#snapquery.qlever.QLever.wd_urls_for_ticket","title":"<code>wd_urls_for_ticket(ticket)</code>","text":"<p>Extracts and returns all URLs from a ticket's body and comments that match the specified pattern.</p> Source code in <code>snapquery/qlever.py</code> <pre><code>def wd_urls_for_ticket(self, ticket: Ticket) -&gt; List[str]:\n    \"\"\"\n    Extracts and returns all URLs from a ticket's body and comments that match the specified pattern.\n    \"\"\"\n    extracted_urls = []\n\n    # Extract URLs from the ticket body\n    if ticket.body:\n        found_urls = self.wd_url_pattern.findall(ticket.body)\n        extracted_urls.extend(found_urls)\n\n    # Fetch and extract URLs from comments\n    comments = self.osproject.ticketSystem.getComments(self.osproject, ticket.number)\n    for comment in comments:\n        found_urls = self.wd_url_pattern.findall(comment[\"body\"])\n        extracted_urls.extend(found_urls)\n\n    return extracted_urls\n</code></pre>"},{"location":"#snapquery.qlever.QLeverUrl","title":"<code>QLeverUrl</code>","text":"<p>               Bases: <code>ShortUrl</code></p> <p>Handles operations related to QLever short URLs.</p> Source code in <code>snapquery/qlever.py</code> <pre><code>class QLeverUrl(ShortUrl):\n    \"\"\"\n    Handles operations related to QLever short URLs.\n    \"\"\"\n\n    def __init__(self, short_url: str):\n        super().__init__(short_url, scheme=\"https\", netloc=\"qlever.cs.uni-freiburg.de\")\n\n    def read_query(self) -&gt; str:\n        \"\"\"\n        Read a query from a QLever short URL.\n\n        Returns:\n            str: The SPARQL query extracted from the short URL.\n        \"\"\"\n        self.fetch_final_url()\n        if self.url:\n            try:\n                response = requests.get(self.url)\n                response.raise_for_status()\n                soup = BeautifulSoup(response.content, \"html.parser\")\n                query_element = soup.find(\"textarea\", {\"id\": \"query\"})\n                if query_element and query_element.text:\n                    self.sparql = query_element.text.strip()\n            except Exception as ex:\n                self.error = ex\n        return self.sparql\n</code></pre>"},{"location":"#snapquery.qlever.QLeverUrl.read_query","title":"<code>read_query()</code>","text":"<p>Read a query from a QLever short URL.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The SPARQL query extracted from the short URL.</p> Source code in <code>snapquery/qlever.py</code> <pre><code>def read_query(self) -&gt; str:\n    \"\"\"\n    Read a query from a QLever short URL.\n\n    Returns:\n        str: The SPARQL query extracted from the short URL.\n    \"\"\"\n    self.fetch_final_url()\n    if self.url:\n        try:\n            response = requests.get(self.url)\n            response.raise_for_status()\n            soup = BeautifulSoup(response.content, \"html.parser\")\n            query_element = soup.find(\"textarea\", {\"id\": \"query\"})\n            if query_element and query_element.text:\n                self.sparql = query_element.text.strip()\n        except Exception as ex:\n            self.error = ex\n    return self.sparql\n</code></pre>"},{"location":"#snapquery.query_annotate","title":"<code>query_annotate</code>","text":"<p>Created on 2024-05-15</p> <p>@author: tholzheim</p>"},{"location":"#snapquery.query_annotate.NamespaceStat","title":"<code>NamespaceStat</code>","text":"<p>contains namespace information</p> Source code in <code>snapquery/query_annotate.py</code> <pre><code>@lod_storable\nclass NamespaceStat:\n    \"\"\"\n    contains namespace information\n    \"\"\"\n\n    name: str\n    count: int = 0\n</code></pre>"},{"location":"#snapquery.query_annotate.SparqlQueryAnnotater","title":"<code>SparqlQueryAnnotater</code>","text":"<p>Annotate a query</p> Source code in <code>snapquery/query_annotate.py</code> <pre><code>class SparqlQueryAnnotater:\n    \"\"\"\n    Annotate a query\n    \"\"\"\n\n    def __init__(self, query: Query):\n        self.query = query\n        query_syntax_highlight = QuerySyntaxHighlight(query)\n        html = query_syntax_highlight.highlight()\n        self.soup = BeautifulSoup(html, \"html.parser\")\n        self.stats = QUERY_ITEM_STATS\n\n    def get_used_properties(self):\n        prefix_element = self.soup.find_all(\"span\", {\"class\": \"nn\"})\n        properties = []\n        for element in prefix_element:\n            item = element.next_sibling.next_sibling\n            if hasattr(item, \"attrs\") and \"nt\" in item.attrs.get(\"class\"):\n                properties.append(f\"{element.text}:{item.text}\")\n        return properties\n\n    def annotate(self) -&gt; str:\n        prefix_element = self.soup.find_all(\"span\", {\"class\": \"nn\"})\n        for element in prefix_element:\n            prefix = element\n            colon = element.next_sibling\n            item = element.next_sibling.next_sibling\n            if hasattr(item, \"attrs\") and \"nt\" in item.attrs.get(\"class\"):\n                identifier = item.text\n                if not identifier.startswith((\"P\", \"Q\")):\n                    identifier = f\"{prefix.text}:{identifier}\"\n                item_stat = self.stats.get_by_id(identifier)\n                title = item_stat.label if item_stat else item.text\n                annotation_element = self.soup.new_tag(\n                    \"a\",\n                    href=\"http://www.wikidata.org/entity/\" + item.text,\n                    title=title,\n                    target=\"_blank\",\n                )\n                prefix.insert_before(annotation_element)\n                annotation_element.insert(0, prefix)\n                annotation_element.insert(1, colon)\n                annotation_element.insert(2, item)\n        return str(self.soup)\n</code></pre>"},{"location":"#snapquery.query_selector","title":"<code>query_selector</code>","text":"<p>Created on 2024-07-04 @author: wf</p>"},{"location":"#snapquery.query_selector.QuerySelector","title":"<code>QuerySelector</code>","text":"<p>A class to select domain, namespace, and name for a query using comboboxes. Uses a single change handler to update selections dynamically.</p> Source code in <code>snapquery/query_selector.py</code> <pre><code>class QuerySelector:\n    \"\"\"\n    A class to select domain, namespace, and name for a query using comboboxes.\n    Uses a single change handler to update selections dynamically.\n    \"\"\"\n\n    def __init__(self, solution: WebSolution, on_change):\n        self.solution = solution\n        self.nqm = self.solution.nqm\n        self.qns = QueryNameSet(self.nqm)  # Initialize QueryNameSet\n        self.qn = QueryName(domain=\"\", namespace=\"\", name=\"\")  # Current selection state\n        self.qns.update(domain=self.qn.domain, namespace=self.qn.namespace)\n        self.on_change = on_change\n        self.setup_ui()\n\n    def setup_ui(self):\n        \"\"\"\n        Setup the user interface for query selection using comboboxes.\n        \"\"\"\n        with ui.row() as self.select_row:\n            self.domain_select = self.create_combobox(\"Domain\", self.qns.domains, 25)\n            self.namespace_select = self.create_combobox(\"Namespace\", self.qns.namespaces, 40)\n            self.name_select = self.create_combobox(\"Name\", self.qns.names, 80)\n\n    def create_combobox(self, label: str, options: List[str], width_chars: int) -&gt; ComboBox:\n        \"\"\"Create a ComboBox with the given label, options, and width.\"\"\"\n        return ComboBox(\n            label=label,\n            options=options,\n            width_chars=width_chars,\n            clearable=True,\n            on_change=self.handle_change,\n        )\n\n    async def handle_change(self):\n        \"\"\"\n        Update self.qn and call the provided on_change callback\n        \"\"\"\n        self.qn.domain = self.domain_select.select.value or \"\"\n        self.qn.namespace = self.namespace_select.select.value or \"\"\n        self.qn.name = self.name_select.select.value or \"\"\n\n        self.qns.update(domain=self.qn.domain, namespace=self.qn.namespace)\n        self.update_ui()\n\n        if self.on_change:\n            await self.on_change()\n\n    def update_options(self, select_widget, options):\n        select_widget.update_options(options)\n\n    def update_ui(self):\n        \"\"\"\n        Update UI components based on filtered results using the custom update_options method for safe sorting.\n        \"\"\"\n        self.update_options(self.domain_select, self.qns.domains)\n        self.update_options(self.namespace_select, self.qns.namespaces)\n        self.update_options(self.name_select, self.qns.names)\n</code></pre>"},{"location":"#snapquery.query_selector.QuerySelector.create_combobox","title":"<code>create_combobox(label, options, width_chars)</code>","text":"<p>Create a ComboBox with the given label, options, and width.</p> Source code in <code>snapquery/query_selector.py</code> <pre><code>def create_combobox(self, label: str, options: List[str], width_chars: int) -&gt; ComboBox:\n    \"\"\"Create a ComboBox with the given label, options, and width.\"\"\"\n    return ComboBox(\n        label=label,\n        options=options,\n        width_chars=width_chars,\n        clearable=True,\n        on_change=self.handle_change,\n    )\n</code></pre>"},{"location":"#snapquery.query_selector.QuerySelector.handle_change","title":"<code>handle_change()</code>  <code>async</code>","text":"<p>Update self.qn and call the provided on_change callback</p> Source code in <code>snapquery/query_selector.py</code> <pre><code>async def handle_change(self):\n    \"\"\"\n    Update self.qn and call the provided on_change callback\n    \"\"\"\n    self.qn.domain = self.domain_select.select.value or \"\"\n    self.qn.namespace = self.namespace_select.select.value or \"\"\n    self.qn.name = self.name_select.select.value or \"\"\n\n    self.qns.update(domain=self.qn.domain, namespace=self.qn.namespace)\n    self.update_ui()\n\n    if self.on_change:\n        await self.on_change()\n</code></pre>"},{"location":"#snapquery.query_selector.QuerySelector.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Setup the user interface for query selection using comboboxes.</p> Source code in <code>snapquery/query_selector.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    Setup the user interface for query selection using comboboxes.\n    \"\"\"\n    with ui.row() as self.select_row:\n        self.domain_select = self.create_combobox(\"Domain\", self.qns.domains, 25)\n        self.namespace_select = self.create_combobox(\"Namespace\", self.qns.namespaces, 40)\n        self.name_select = self.create_combobox(\"Name\", self.qns.names, 80)\n</code></pre>"},{"location":"#snapquery.query_selector.QuerySelector.update_ui","title":"<code>update_ui()</code>","text":"<p>Update UI components based on filtered results using the custom update_options method for safe sorting.</p> Source code in <code>snapquery/query_selector.py</code> <pre><code>def update_ui(self):\n    \"\"\"\n    Update UI components based on filtered results using the custom update_options method for safe sorting.\n    \"\"\"\n    self.update_options(self.domain_select, self.qns.domains)\n    self.update_options(self.namespace_select, self.qns.namespaces)\n    self.update_options(self.name_select, self.qns.names)\n</code></pre>"},{"location":"#snapquery.scholia","title":"<code>scholia</code>","text":"<p>Created on 2024-05-04</p> <p>@author: wf</p>"},{"location":"#snapquery.scholia.ScholiaQueries","title":"<code>ScholiaQueries</code>","text":"<p>A class to handle the extraction and management of Scholia queries.</p> Source code in <code>snapquery/scholia.py</code> <pre><code>class ScholiaQueries:\n    \"\"\"\n    A class to handle the extraction and management of Scholia queries.\n    \"\"\"\n\n    repository_url = \"https://api.github.com/repos/WDscholia/scholia/contents/scholia/app/templates\"\n\n    def __init__(self, nqm: NamedQueryManager, debug: bool = False):\n        \"\"\"\n        Constructor\n\n        Args:\n            nqm (NamedQueryManager): The NamedQueryManager to use for storing queries.\n            debug (bool): Enable debug output. Defaults to False.\n        \"\"\"\n        self.nqm = nqm\n        self.named_query_set = NamedQuerySet(\n            domain=\"scholia.toolforge.org\",\n            namespace=\"named_queries\",\n            target_graph_name=\"wikidata\",\n        )\n        self.debug = debug\n\n    def get_scholia_file_list(self):\n        \"\"\"\n        Retrieve the list of SPARQL files from the Scholia repository.\n\n        Returns:\n            list: List of dictionaries representing file information.\n        \"\"\"\n        headers = {\"Accept\": \"application/vnd.github.v3+json\"}\n        response = requests.get(self.repository_url, headers=headers)\n        response.raise_for_status()  # Ensure we notice bad responses\n        return response.json()\n\n    def extract_query(self, file_info) -&gt; NamedQuery:\n        \"\"\"\n        Extract a single query from file information.\n\n        Args:\n            file_info (dict): Dictionary containing information about the file.\n\n        Returns:\n            NamedQuery: The extracted NamedQuery object.\n        \"\"\"\n        file_name = file_info[\"name\"]\n        if file_name.endswith(\".sparql\") and file_name[:-7]:\n            file_response = requests.get(file_info[\"download_url\"])\n            file_response.raise_for_status()\n            query_str = file_response.text\n            name = file_name[:-7]\n            return NamedQuery(\n                domain=self.named_query_set.domain,\n                namespace=self.named_query_set.namespace,\n                name=name,\n                url=file_info[\"download_url\"],\n                title=name,\n                description=name,\n                comment=\"\",\n                sparql=query_str,\n            )\n\n    def extract_queries(self, limit: int = None):\n        \"\"\"\n        Extract all queries from the Scholia repository.\n\n        Args:\n            limit (int, optional): Limit the number of queries fetched. Defaults to None.\n        \"\"\"\n        file_list_json = self.get_scholia_file_list()\n        for i, file_info in enumerate(file_list_json, start=1):\n            named_query = self.extract_query(file_info)\n            if named_query:\n                self.named_query_set.queries.append(named_query)\n                if self.debug:\n                    if i % 80 == 0:\n                        print(f\"{i}\")\n                    print(\".\", end=\"\", flush=True)\n                if limit and len(self.named_query_set.queries) &gt;= limit:\n                    break\n\n        if self.debug:\n            print(f\"found {len(self.named_query_set.queries)} scholia queries\")\n\n    def save_to_json(self, file_path: str = \"/tmp/scholia-queries.json\"):\n        \"\"\"\n        Save the NamedQueryList to a JSON file.\n\n        Args:\n            file_path (str): Path to the JSON file.\n        \"\"\"\n        self.named_query_set.save_to_json_file(file_path, indent=2)\n\n    def store_queries(self):\n        \"\"\"\n        Store the named queries into the database.\n        \"\"\"\n        self.nqm.store_named_query_list(self.named_query_set)\n</code></pre>"},{"location":"#snapquery.scholia.ScholiaQueries.__init__","title":"<code>__init__(nqm, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>nqm</code> <code>NamedQueryManager</code> <p>The NamedQueryManager to use for storing queries.</p> required <code>debug</code> <code>bool</code> <p>Enable debug output. Defaults to False.</p> <code>False</code> Source code in <code>snapquery/scholia.py</code> <pre><code>def __init__(self, nqm: NamedQueryManager, debug: bool = False):\n    \"\"\"\n    Constructor\n\n    Args:\n        nqm (NamedQueryManager): The NamedQueryManager to use for storing queries.\n        debug (bool): Enable debug output. Defaults to False.\n    \"\"\"\n    self.nqm = nqm\n    self.named_query_set = NamedQuerySet(\n        domain=\"scholia.toolforge.org\",\n        namespace=\"named_queries\",\n        target_graph_name=\"wikidata\",\n    )\n    self.debug = debug\n</code></pre>"},{"location":"#snapquery.scholia.ScholiaQueries.extract_queries","title":"<code>extract_queries(limit=None)</code>","text":"<p>Extract all queries from the Scholia repository.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Limit the number of queries fetched. Defaults to None.</p> <code>None</code> Source code in <code>snapquery/scholia.py</code> <pre><code>def extract_queries(self, limit: int = None):\n    \"\"\"\n    Extract all queries from the Scholia repository.\n\n    Args:\n        limit (int, optional): Limit the number of queries fetched. Defaults to None.\n    \"\"\"\n    file_list_json = self.get_scholia_file_list()\n    for i, file_info in enumerate(file_list_json, start=1):\n        named_query = self.extract_query(file_info)\n        if named_query:\n            self.named_query_set.queries.append(named_query)\n            if self.debug:\n                if i % 80 == 0:\n                    print(f\"{i}\")\n                print(\".\", end=\"\", flush=True)\n            if limit and len(self.named_query_set.queries) &gt;= limit:\n                break\n\n    if self.debug:\n        print(f\"found {len(self.named_query_set.queries)} scholia queries\")\n</code></pre>"},{"location":"#snapquery.scholia.ScholiaQueries.extract_query","title":"<code>extract_query(file_info)</code>","text":"<p>Extract a single query from file information.</p> <p>Parameters:</p> Name Type Description Default <code>file_info</code> <code>dict</code> <p>Dictionary containing information about the file.</p> required <p>Returns:</p> Name Type Description <code>NamedQuery</code> <code>NamedQuery</code> <p>The extracted NamedQuery object.</p> Source code in <code>snapquery/scholia.py</code> <pre><code>def extract_query(self, file_info) -&gt; NamedQuery:\n    \"\"\"\n    Extract a single query from file information.\n\n    Args:\n        file_info (dict): Dictionary containing information about the file.\n\n    Returns:\n        NamedQuery: The extracted NamedQuery object.\n    \"\"\"\n    file_name = file_info[\"name\"]\n    if file_name.endswith(\".sparql\") and file_name[:-7]:\n        file_response = requests.get(file_info[\"download_url\"])\n        file_response.raise_for_status()\n        query_str = file_response.text\n        name = file_name[:-7]\n        return NamedQuery(\n            domain=self.named_query_set.domain,\n            namespace=self.named_query_set.namespace,\n            name=name,\n            url=file_info[\"download_url\"],\n            title=name,\n            description=name,\n            comment=\"\",\n            sparql=query_str,\n        )\n</code></pre>"},{"location":"#snapquery.scholia.ScholiaQueries.get_scholia_file_list","title":"<code>get_scholia_file_list()</code>","text":"<p>Retrieve the list of SPARQL files from the Scholia repository.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of dictionaries representing file information.</p> Source code in <code>snapquery/scholia.py</code> <pre><code>def get_scholia_file_list(self):\n    \"\"\"\n    Retrieve the list of SPARQL files from the Scholia repository.\n\n    Returns:\n        list: List of dictionaries representing file information.\n    \"\"\"\n    headers = {\"Accept\": \"application/vnd.github.v3+json\"}\n    response = requests.get(self.repository_url, headers=headers)\n    response.raise_for_status()  # Ensure we notice bad responses\n    return response.json()\n</code></pre>"},{"location":"#snapquery.scholia.ScholiaQueries.save_to_json","title":"<code>save_to_json(file_path='/tmp/scholia-queries.json')</code>","text":"<p>Save the NamedQueryList to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the JSON file.</p> <code>'/tmp/scholia-queries.json'</code> Source code in <code>snapquery/scholia.py</code> <pre><code>def save_to_json(self, file_path: str = \"/tmp/scholia-queries.json\"):\n    \"\"\"\n    Save the NamedQueryList to a JSON file.\n\n    Args:\n        file_path (str): Path to the JSON file.\n    \"\"\"\n    self.named_query_set.save_to_json_file(file_path, indent=2)\n</code></pre>"},{"location":"#snapquery.scholia.ScholiaQueries.store_queries","title":"<code>store_queries()</code>","text":"<p>Store the named queries into the database.</p> Source code in <code>snapquery/scholia.py</code> <pre><code>def store_queries(self):\n    \"\"\"\n    Store the named queries into the database.\n    \"\"\"\n    self.nqm.store_named_query_list(self.named_query_set)\n</code></pre>"},{"location":"#snapquery.snapquery_cmd","title":"<code>snapquery_cmd</code>","text":"<p>Created on 2024-05-03</p> <p>@author: wf</p>"},{"location":"#snapquery.snapquery_cmd.SnapQueryCmd","title":"<code>SnapQueryCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>Command line for diagrams server</p> Source code in <code>snapquery/snapquery_cmd.py</code> <pre><code>class SnapQueryCmd(WebserverCmd):\n    \"\"\"\n    Command line for diagrams server\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        # see https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/querymain.py\n        parser.add_argument(\n            \"-ep\",\n            \"--endpointPath\",\n            default=None,\n            help=\"path to yaml file to configure endpoints to use for queries\",\n        )\n        parser.add_argument(\n            \"-en\",\n            \"--endpointName\",\n            default=\"wikidata\",\n            choices=list(NamedQueryManager.from_samples().endpoints.keys()),\n            help=\"Name of the endpoint to use for queries - use --listEndpoints to list available endpoints\",\n        )\n        parser.add_argument(\n            \"-idb\",\n            \"--initDatabase\",\n            action=\"store_true\",\n            help=\"initialize the database\",\n        )\n        parser.add_argument(\n            \"-le\",\n            \"--listEndpoints\",\n            action=\"store_true\",\n            help=\"show the list of available endpoints\",\n        )\n        parser.add_argument(\n            \"-lm\",\n            \"--listMetaqueries\",\n            action=\"store_true\",\n            help=\"show the list of available metaqueries\",\n        )\n        parser.add_argument(\n            \"-ln\",\n            \"--listNamespaces\",\n            action=\"store_true\",\n            help=\"show the list of available namespaces\",\n        )\n        parser.add_argument(\n            \"-lg\",\n            \"--listGraphs\",\n            action=\"store_true\",\n            help=\"show the list of available graphs\",\n        )\n        parser.add_argument(\n            \"-tq\",\n            \"--testQueries\",\n            action=\"store_true\",\n            help=\"test run the queries\",\n        )\n        parser.add_argument(\"--limit\", type=int, default=None, help=\"set limit parameter of query\")\n        parser.add_argument(\n            \"--params\",\n            action=StoreDictKeyPair,\n            help=\"query parameters as Key-value pairs in the format key1=value1,key2=value2\",\n        )\n        parser.add_argument(\n            \"--domain\",\n            type=str,\n            default=\"wikidata.org\",\n            help=\"domain to filter queries\",\n        )\n        parser.add_argument(\n            \"--namespace\",\n            type=str,\n            default=\"examples\",\n            help=\"namespace to filter queries\",\n        )\n        parser.add_argument(\"-qn\", \"--queryName\", help=\"run a named query\")\n        parser.add_argument(\n            \"query_id\",\n            nargs=\"?\",  # Make it optional\n            help=\"Query ID in the format 'name[--namespace[@domain]]'\",\n        )\n        parser.add_argument(\"-f\", \"--format\", type=Format, choices=list(Format))\n        parser.add_argument(\n            \"--import\",\n            dest=\"import_file\",\n            help=\"Import named queries from a JSON file.\",\n        )\n        parser.add_argument(\n            \"--context\",\n            type=str,\n            default=\"test\",\n            help=\"context name to store the execution statistics with\",\n        )\n        parser.add_argument(\n            \"--prefix_merger\",\n            type=str,\n            default=QueryPrefixMerger.default_merger().name,\n            choices=[merger.name for merger in QueryPrefixMerger],\n            help=\"query prefix merger to use\",\n        )\n        return parser\n\n    def cmd_parse(self, argv: Optional[list] = None):\n        \"\"\"\n        parse the argument lists and prepare\n\n        Args:\n            argv(list): list of command line arguments\n\n        \"\"\"\n        super().cmd_parse(argv)\n        if self.args.debug:\n            level = logging.DEBUG\n        else:\n            level = logging.INFO\n        logging.basicConfig(level=level)\n        if hasattr(self.args, \"func\"):\n            self.args.func(self.args)\n        return self.args\n\n    def handle_args(self) -&gt; bool:\n        \"\"\"\n        handle the command line args\n        \"\"\"\n        # Call the superclass handle_args to maintain base class behavior\n        handled = super().handle_args()\n        self.debug = self.args.debug\n        nqm = NamedQueryManager.from_samples()\n        self.nqm = nqm\n        # Check args functions\n        nqm = NamedQueryManager.from_samples(force_init=self.args.initDatabase)\n        if self.args.listEndpoints:\n            # List endpoints\n            for endpoint in self.nqm.endpoints.values():\n                print(endpoint)\n            handled = True  # Operation handled\n        elif self.args.listGraphs:\n            print(self.nqm.gm.to_json(indent=2))\n            handled = True\n        elif self.args.listMetaqueries:\n            meta_qm = self.nqm.meta_qm\n            for name, query in meta_qm.queriesByName.items():\n                print(f\"{name}:{query.title}\")\n            handled = True\n        elif self.args.listNamespaces:\n            namespaces = self.nqm.get_namespaces()\n            for namespace, count in namespaces.items():\n                print(f\"{namespace}:{count}\")\n            handled = True\n        elif self.args.testQueries:\n            if self.args.endpointName:\n                endpoint_names = [self.args.endpointName]\n            else:\n                endpoint_names = list(nqm.endpoints.keys())\n            queries = self.nqm.get_all_queries(domain=self.args.domain, namespace=self.args.namespace)\n            execution = Execution(self.nqm, debug=self.args.debug)\n            for i, nq in enumerate(queries, start=1):\n                for endpoint_name in endpoint_names:\n                    execution.execute(\n                        nq,\n                        endpoint_name=endpoint_name,\n                        context=self.args.context,\n                        title=f\"query {i:3}/{len(queries)}::{endpoint_name}\",\n                        prefix_merger=QueryPrefixMerger.get_by_name(self.args.prefix_merger),\n                    )\n        elif self.args.queryName is not None or self.args.query_id is not None:\n            if self.args.query_id is not None:\n                query_name = QueryName.from_query_id(self.args.query_id)\n            else:\n                query_name = QueryName(\n                    name=self.args.queryName,\n                    namespace=self.args.namespace,\n                    domain=self.args.domain,\n                )\n            endpoint_name = self.args.endpointName\n            r_format = self.args.format\n            limit = self.args.limit\n            qb = nqm.get_query(query_name=query_name, endpoint_name=endpoint_name, limit=limit)\n            query = qb.query\n            params = Params(query.query)\n            if params.has_params:\n                if not self.args.params:\n                    raise Exception(f\"{query.name} needs parameters\")\n                else:\n                    params.set(self.args.params)\n                    query.query = params.apply_parameters()\n            if r_format == Format.raw:\n                formatted_result = qb.raw_query()\n            else:\n                qlod = qb.get_lod()\n                formatted_result = qb.format_result(qlod=qlod, r_format=r_format)\n            print(formatted_result)\n        elif self.args.import_file:\n            self.handle_import(self.args.import_file)\n            handled = True\n        return handled\n\n    def handle_import(self, json_file: str):\n        \"\"\"\n        Handle the import of named queries from a JSON file.\n\n        Args:\n            json_file (str): Path to the JSON file to import.\n        \"\"\"\n        nqm = NamedQueryManager.from_samples()\n        qimport = QueryImport(nqm=nqm)\n        nq_list = qimport.import_from_json_file(json_file, with_store=True, show_progress=True)\n        print(f\"Imported {len(nq_list.queries)} named queries from {json_file}.\")\n</code></pre>"},{"location":"#snapquery.snapquery_cmd.SnapQueryCmd.cmd_parse","title":"<code>cmd_parse(argv=None)</code>","text":"<p>parse the argument lists and prepare</p> <p>Parameters:</p> Name Type Description Default <code>argv(list)</code> <p>list of command line arguments</p> required Source code in <code>snapquery/snapquery_cmd.py</code> <pre><code>def cmd_parse(self, argv: Optional[list] = None):\n    \"\"\"\n    parse the argument lists and prepare\n\n    Args:\n        argv(list): list of command line arguments\n\n    \"\"\"\n    super().cmd_parse(argv)\n    if self.args.debug:\n        level = logging.DEBUG\n    else:\n        level = logging.INFO\n    logging.basicConfig(level=level)\n    if hasattr(self.args, \"func\"):\n        self.args.func(self.args)\n    return self.args\n</code></pre>"},{"location":"#snapquery.snapquery_cmd.SnapQueryCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>snapquery/snapquery_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    # see https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/querymain.py\n    parser.add_argument(\n        \"-ep\",\n        \"--endpointPath\",\n        default=None,\n        help=\"path to yaml file to configure endpoints to use for queries\",\n    )\n    parser.add_argument(\n        \"-en\",\n        \"--endpointName\",\n        default=\"wikidata\",\n        choices=list(NamedQueryManager.from_samples().endpoints.keys()),\n        help=\"Name of the endpoint to use for queries - use --listEndpoints to list available endpoints\",\n    )\n    parser.add_argument(\n        \"-idb\",\n        \"--initDatabase\",\n        action=\"store_true\",\n        help=\"initialize the database\",\n    )\n    parser.add_argument(\n        \"-le\",\n        \"--listEndpoints\",\n        action=\"store_true\",\n        help=\"show the list of available endpoints\",\n    )\n    parser.add_argument(\n        \"-lm\",\n        \"--listMetaqueries\",\n        action=\"store_true\",\n        help=\"show the list of available metaqueries\",\n    )\n    parser.add_argument(\n        \"-ln\",\n        \"--listNamespaces\",\n        action=\"store_true\",\n        help=\"show the list of available namespaces\",\n    )\n    parser.add_argument(\n        \"-lg\",\n        \"--listGraphs\",\n        action=\"store_true\",\n        help=\"show the list of available graphs\",\n    )\n    parser.add_argument(\n        \"-tq\",\n        \"--testQueries\",\n        action=\"store_true\",\n        help=\"test run the queries\",\n    )\n    parser.add_argument(\"--limit\", type=int, default=None, help=\"set limit parameter of query\")\n    parser.add_argument(\n        \"--params\",\n        action=StoreDictKeyPair,\n        help=\"query parameters as Key-value pairs in the format key1=value1,key2=value2\",\n    )\n    parser.add_argument(\n        \"--domain\",\n        type=str,\n        default=\"wikidata.org\",\n        help=\"domain to filter queries\",\n    )\n    parser.add_argument(\n        \"--namespace\",\n        type=str,\n        default=\"examples\",\n        help=\"namespace to filter queries\",\n    )\n    parser.add_argument(\"-qn\", \"--queryName\", help=\"run a named query\")\n    parser.add_argument(\n        \"query_id\",\n        nargs=\"?\",  # Make it optional\n        help=\"Query ID in the format 'name[--namespace[@domain]]'\",\n    )\n    parser.add_argument(\"-f\", \"--format\", type=Format, choices=list(Format))\n    parser.add_argument(\n        \"--import\",\n        dest=\"import_file\",\n        help=\"Import named queries from a JSON file.\",\n    )\n    parser.add_argument(\n        \"--context\",\n        type=str,\n        default=\"test\",\n        help=\"context name to store the execution statistics with\",\n    )\n    parser.add_argument(\n        \"--prefix_merger\",\n        type=str,\n        default=QueryPrefixMerger.default_merger().name,\n        choices=[merger.name for merger in QueryPrefixMerger],\n        help=\"query prefix merger to use\",\n    )\n    return parser\n</code></pre>"},{"location":"#snapquery.snapquery_cmd.SnapQueryCmd.handle_args","title":"<code>handle_args()</code>","text":"<p>handle the command line args</p> Source code in <code>snapquery/snapquery_cmd.py</code> <pre><code>def handle_args(self) -&gt; bool:\n    \"\"\"\n    handle the command line args\n    \"\"\"\n    # Call the superclass handle_args to maintain base class behavior\n    handled = super().handle_args()\n    self.debug = self.args.debug\n    nqm = NamedQueryManager.from_samples()\n    self.nqm = nqm\n    # Check args functions\n    nqm = NamedQueryManager.from_samples(force_init=self.args.initDatabase)\n    if self.args.listEndpoints:\n        # List endpoints\n        for endpoint in self.nqm.endpoints.values():\n            print(endpoint)\n        handled = True  # Operation handled\n    elif self.args.listGraphs:\n        print(self.nqm.gm.to_json(indent=2))\n        handled = True\n    elif self.args.listMetaqueries:\n        meta_qm = self.nqm.meta_qm\n        for name, query in meta_qm.queriesByName.items():\n            print(f\"{name}:{query.title}\")\n        handled = True\n    elif self.args.listNamespaces:\n        namespaces = self.nqm.get_namespaces()\n        for namespace, count in namespaces.items():\n            print(f\"{namespace}:{count}\")\n        handled = True\n    elif self.args.testQueries:\n        if self.args.endpointName:\n            endpoint_names = [self.args.endpointName]\n        else:\n            endpoint_names = list(nqm.endpoints.keys())\n        queries = self.nqm.get_all_queries(domain=self.args.domain, namespace=self.args.namespace)\n        execution = Execution(self.nqm, debug=self.args.debug)\n        for i, nq in enumerate(queries, start=1):\n            for endpoint_name in endpoint_names:\n                execution.execute(\n                    nq,\n                    endpoint_name=endpoint_name,\n                    context=self.args.context,\n                    title=f\"query {i:3}/{len(queries)}::{endpoint_name}\",\n                    prefix_merger=QueryPrefixMerger.get_by_name(self.args.prefix_merger),\n                )\n    elif self.args.queryName is not None or self.args.query_id is not None:\n        if self.args.query_id is not None:\n            query_name = QueryName.from_query_id(self.args.query_id)\n        else:\n            query_name = QueryName(\n                name=self.args.queryName,\n                namespace=self.args.namespace,\n                domain=self.args.domain,\n            )\n        endpoint_name = self.args.endpointName\n        r_format = self.args.format\n        limit = self.args.limit\n        qb = nqm.get_query(query_name=query_name, endpoint_name=endpoint_name, limit=limit)\n        query = qb.query\n        params = Params(query.query)\n        if params.has_params:\n            if not self.args.params:\n                raise Exception(f\"{query.name} needs parameters\")\n            else:\n                params.set(self.args.params)\n                query.query = params.apply_parameters()\n        if r_format == Format.raw:\n            formatted_result = qb.raw_query()\n        else:\n            qlod = qb.get_lod()\n            formatted_result = qb.format_result(qlod=qlod, r_format=r_format)\n        print(formatted_result)\n    elif self.args.import_file:\n        self.handle_import(self.args.import_file)\n        handled = True\n    return handled\n</code></pre>"},{"location":"#snapquery.snapquery_cmd.SnapQueryCmd.handle_import","title":"<code>handle_import(json_file)</code>","text":"<p>Handle the import of named queries from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>json_file</code> <code>str</code> <p>Path to the JSON file to import.</p> required Source code in <code>snapquery/snapquery_cmd.py</code> <pre><code>def handle_import(self, json_file: str):\n    \"\"\"\n    Handle the import of named queries from a JSON file.\n\n    Args:\n        json_file (str): Path to the JSON file to import.\n    \"\"\"\n    nqm = NamedQueryManager.from_samples()\n    qimport = QueryImport(nqm=nqm)\n    nq_list = qimport.import_from_json_file(json_file, with_store=True, show_progress=True)\n    print(f\"Imported {len(nq_list.queries)} named queries from {json_file}.\")\n</code></pre>"},{"location":"#snapquery.snapquery_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>snapquery/snapquery_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = SnapQueryCmd(\n        config=SnapQueryWebServer.get_config(),\n        webserver_cls=SnapQueryWebServer,\n    )\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#snapquery.snapquery_core","title":"<code>snapquery_core</code>","text":"<p>Created on 2024-05-03</p> <p>@author: wf</p>"},{"location":"#snapquery.snapquery_core.NamedQuery","title":"<code>NamedQuery</code>  <code>dataclass</code>","text":"<p>               Bases: <code>QueryName</code></p> <p>A named query that encapsulates the details and SPARQL query for a specific purpose.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <p>A brief one-line title that describes the query.</p> <code>description</code> <code>str</code> <p>A detailed multiline description of what the query does and the data it accesses.</p> <code>sparql</code> <code>str</code> <p>The SPARQL query string. This might be hidden in future to encapsulate query details.</p> <code>query_id</code> <code>str</code> <p>A unique identifier for the query, generated from namespace and name, used as a primary key.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@dataclass\nclass NamedQuery(QueryName):\n    \"\"\"\n    A named query that encapsulates the details and SPARQL query for a specific purpose.\n\n    Attributes:\n        title (str): A brief one-line title that describes the query.\n        description (str): A detailed multiline description of what the query does and the data it accesses.\n        sparql (str): The SPARQL query string. This might be hidden in future to encapsulate query details.\n        query_id (str): A unique identifier for the query, generated from namespace and name, used as a primary key.\n    \"\"\"\n\n    # sparql query (to be hidden later)\n    sparql: Optional[str] = None\n    # the url of the source code of the query\n    url: Optional[str] = None\n    # one line title\n    title: Optional[str] = None\n    # multiline description\n    description: Optional[str] = None\n    comment: Optional[str] = None\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"NamedQuery\"]:\n        \"\"\"\n        get samples\n        \"\"\"\n        samples = {\n            \"snapquery-examples\": [\n                NamedQuery(\n                    domain=\"wikidata.org\",\n                    namespace=\"snapquery-examples\",\n                    name=\"cats\",\n                    url=\"https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service/queries/examples#Cats\",\n                    title=\"Cats on Wikidata\",\n                    description=\"This query retrieves all items classified under 'house cat' (Q146) on Wikidata.\",\n                    comment=\"modified cats query from wikidata-examples\",\n                    sparql=\"\"\"# snapquery cats example\nSELECT ?item ?itemLabel\nWHERE {\n  ?item wdt:P31 wd:Q146. # Must be a cat\n  OPTIONAL { ?item rdfs:label ?itemLabel. }\n  FILTER (LANG(?itemLabel) = \"en\")\n}\n\"\"\",\n                ),\n                NamedQuery(\n                    domain=\"wikidata.org\",\n                    namespace=\"snapquery-examples\",\n                    name=\"bands\",\n                    title=\"Rock bands\",\n                    url=\"https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service/queries/examples#Rock_bands_that_start_with_%22M%22\",\n                    description=\"\"\"Rock bands that start with \"M\" \"\"\",\n                    comment=\"\",\n                    sparql=\"\"\"SELECT ?band ?bandLabel\nWHERE {\n  ?band wdt:P31 wd:Q5741069.\n  ?band rdfs:label ?bandLabel.\n  FILTER(LANG(?bandLabel)=\"en\").\n  FILTER(STRSTARTS(?bandLabel,\"M\")).\n}\"\"\",\n                ),\n                NamedQuery(\n                    domain=\"wikidata.org\",\n                    namespace=\"snapquery-examples\",\n                    name=\"horses\",\n                    url=\"https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service/queries/examples#Horses_(showing_some_info_about_them)\",\n                    title=\"Horses on Wikidata\",\n                    description=\"This query retrieves information about horses, including parents, gender, and approximate birth and death years.\",\n                    sparql=\"\"\"# snapquery example horses\nSELECT DISTINCT ?horse ?horseLabel ?mother ?motherLabel ?father ?fatherLabel \n(year(?birthdate) as ?birthyear) (year(?deathdate) as ?deathyear) ?genderLabel\nWHERE {\n  ?horse wdt:P31/wdt:P279* wd:Q726 .     # Instance and subclasses of horse (Q726)\n  OPTIONAL{?horse wdt:P25 ?mother .}     # Mother\n  OPTIONAL{?horse wdt:P22 ?father .}     # Father\n  OPTIONAL{?horse wdt:P569 ?birthdate .} # Birth date\n  OPTIONAL{?horse wdt:P570 ?deathdate .} # Death date\n  OPTIONAL{?horse wdt:P21 ?gender .}     # Gender\n  OPTIONAL { ?horse rdfs:label ?horseLabel . FILTER (lang(?horseLabel) = \"en\") }\n  OPTIONAL { ?mother rdfs:label ?motherLabel . FILTER (lang(?motherLabel) = \"en\") }\n  OPTIONAL { ?father rdfs:label ?fatherLabel . FILTER (lang(?fatherLabel) = \"en\") }\n  OPTIONAL { ?gender rdfs:label ?genderLabel . FILTER (lang(?genderLabel) = \"en\") }\n}\nORDER BY ?horse\n\"\"\",\n                ),\n            ]\n        }\n        return samples\n\n    def as_link(self) -&gt; str:\n        \"\"\"\n        get me as a link\n        \"\"\"\n        url = f\"/query/{self.domain}/{self.namespace}/{self.name}\"\n        text = self.name\n        tooltip = \"query details\"\n        link = Link.create(url, text, tooltip)\n        return link\n\n    @classmethod\n    def from_record(cls, record: Dict) -&gt; \"NamedQuery\":\n        \"\"\"\n        Class method to instantiate NamedQuery\n        from a dictionary record.\n        \"\"\"\n        return cls(\n            domain=record[\"domain\"],\n            namespace=record[\"namespace\"],\n            name=record[\"name\"],\n            title=record.get(\"title\"),\n            url=record.get(\"url\"),\n            description=record.get(\"description\"),\n            sparql=record.get(\"sparql\"),\n        )\n\n    def as_record(self) -&gt; Dict:\n        record = {\n            \"query_id\": self.query_id,\n            \"domain\": self.domain,\n            \"namespace\": self.namespace,\n            \"name\": self.name,\n            \"url\": self.url,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"sparql\": self.sparql,\n        }\n        return record\n\n    def as_viewrecord(self) -&gt; Dict:\n        \"\"\"\n        Return a dictionary representing the NamedQuery with keys ordered as Name, Namespace, Title, Description.\n        \"\"\"\n        url_link = Link.create(self.url, self.url)\n        return {\n            \"domain\": self.domain,\n            \"namespace\": self.namespace,\n            \"name\": self.as_link(),\n            \"title\": self.title,\n            \"url\": url_link,\n        }\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQuery.as_link","title":"<code>as_link()</code>","text":"<p>get me as a link</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def as_link(self) -&gt; str:\n    \"\"\"\n    get me as a link\n    \"\"\"\n    url = f\"/query/{self.domain}/{self.namespace}/{self.name}\"\n    text = self.name\n    tooltip = \"query details\"\n    link = Link.create(url, text, tooltip)\n    return link\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQuery.as_viewrecord","title":"<code>as_viewrecord()</code>","text":"<p>Return a dictionary representing the NamedQuery with keys ordered as Name, Namespace, Title, Description.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def as_viewrecord(self) -&gt; Dict:\n    \"\"\"\n    Return a dictionary representing the NamedQuery with keys ordered as Name, Namespace, Title, Description.\n    \"\"\"\n    url_link = Link.create(self.url, self.url)\n    return {\n        \"domain\": self.domain,\n        \"namespace\": self.namespace,\n        \"name\": self.as_link(),\n        \"title\": self.title,\n        \"url\": url_link,\n    }\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQuery.from_record","title":"<code>from_record(record)</code>  <code>classmethod</code>","text":"<p>Class method to instantiate NamedQuery from a dictionary record.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef from_record(cls, record: Dict) -&gt; \"NamedQuery\":\n    \"\"\"\n    Class method to instantiate NamedQuery\n    from a dictionary record.\n    \"\"\"\n    return cls(\n        domain=record[\"domain\"],\n        namespace=record[\"namespace\"],\n        name=record[\"name\"],\n        title=record.get(\"title\"),\n        url=record.get(\"url\"),\n        description=record.get(\"description\"),\n        sparql=record.get(\"sparql\"),\n    )\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQuery.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>get samples</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"NamedQuery\"]:\n        \"\"\"\n        get samples\n        \"\"\"\n        samples = {\n            \"snapquery-examples\": [\n                NamedQuery(\n                    domain=\"wikidata.org\",\n                    namespace=\"snapquery-examples\",\n                    name=\"cats\",\n                    url=\"https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service/queries/examples#Cats\",\n                    title=\"Cats on Wikidata\",\n                    description=\"This query retrieves all items classified under 'house cat' (Q146) on Wikidata.\",\n                    comment=\"modified cats query from wikidata-examples\",\n                    sparql=\"\"\"# snapquery cats example\nSELECT ?item ?itemLabel\nWHERE {\n  ?item wdt:P31 wd:Q146. # Must be a cat\n  OPTIONAL { ?item rdfs:label ?itemLabel. }\n  FILTER (LANG(?itemLabel) = \"en\")\n}\n\"\"\",\n                ),\n                NamedQuery(\n                    domain=\"wikidata.org\",\n                    namespace=\"snapquery-examples\",\n                    name=\"bands\",\n                    title=\"Rock bands\",\n                    url=\"https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service/queries/examples#Rock_bands_that_start_with_%22M%22\",\n                    description=\"\"\"Rock bands that start with \"M\" \"\"\",\n                    comment=\"\",\n                    sparql=\"\"\"SELECT ?band ?bandLabel\nWHERE {\n  ?band wdt:P31 wd:Q5741069.\n  ?band rdfs:label ?bandLabel.\n  FILTER(LANG(?bandLabel)=\"en\").\n  FILTER(STRSTARTS(?bandLabel,\"M\")).\n}\"\"\",\n                ),\n                NamedQuery(\n                    domain=\"wikidata.org\",\n                    namespace=\"snapquery-examples\",\n                    name=\"horses\",\n                    url=\"https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service/queries/examples#Horses_(showing_some_info_about_them)\",\n                    title=\"Horses on Wikidata\",\n                    description=\"This query retrieves information about horses, including parents, gender, and approximate birth and death years.\",\n                    sparql=\"\"\"# snapquery example horses\nSELECT DISTINCT ?horse ?horseLabel ?mother ?motherLabel ?father ?fatherLabel \n(year(?birthdate) as ?birthyear) (year(?deathdate) as ?deathyear) ?genderLabel\nWHERE {\n  ?horse wdt:P31/wdt:P279* wd:Q726 .     # Instance and subclasses of horse (Q726)\n  OPTIONAL{?horse wdt:P25 ?mother .}     # Mother\n  OPTIONAL{?horse wdt:P22 ?father .}     # Father\n  OPTIONAL{?horse wdt:P569 ?birthdate .} # Birth date\n  OPTIONAL{?horse wdt:P570 ?deathdate .} # Death date\n  OPTIONAL{?horse wdt:P21 ?gender .}     # Gender\n  OPTIONAL { ?horse rdfs:label ?horseLabel . FILTER (lang(?horseLabel) = \"en\") }\n  OPTIONAL { ?mother rdfs:label ?motherLabel . FILTER (lang(?motherLabel) = \"en\") }\n  OPTIONAL { ?father rdfs:label ?fatherLabel . FILTER (lang(?fatherLabel) = \"en\") }\n  OPTIONAL { ?gender rdfs:label ?genderLabel . FILTER (lang(?genderLabel) = \"en\") }\n}\nORDER BY ?horse\n\"\"\",\n                ),\n            ]\n        }\n        return samples\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager","title":"<code>NamedQueryManager</code>","text":"<p>Manages the storage, retrieval, and execution of named SPARQL queries.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>class NamedQueryManager:\n    \"\"\"\n    Manages the storage, retrieval, and execution of named SPARQL queries.\n    \"\"\"\n\n    def __init__(self, db_path: str = None, debug: bool = False):\n        \"\"\"\n        Initializes the NamedQueryManager with a specific database path and a debug mode.\n\n        Args:\n            db_path (Optional[str]): The file path to the SQLite database. If None, the default cache path is used.\n            debug (bool): If True, enables debug mode which may provide additional logging and error reporting.\n\n        Attributes:\n            debug (bool): Stores the debug state.\n            sql_db (SQLDB): An instance of SQLDB to manage the SQLite database interactions.\n            endpoints (dict): A dictionary of SPARQL endpoints configured for use.\n        \"\"\"\n        if db_path is None:\n            db_path = NamedQueryManager.get_cache_path()\n        self.debug = debug\n        self.sql_db = SQLDB(dbname=db_path, check_same_thread=False, debug=debug)\n        # Get the path of the yaml_file relative to the current Python module\n        self.samples_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"samples\")\n        endpoints_path = os.path.join(self.samples_path, \"endpoints.yaml\")\n        self.endpoints = EndpointManager.getEndpoints(endpointPath=endpoints_path, lang=\"sparql\", with_default=False)\n        yaml_path = os.path.join(self.samples_path, \"meta_query.yaml\")\n        self.meta_qm = QueryManager(queriesPath=yaml_path, with_default=False, lang=\"sql\")\n        # Graph Manager\n        gm_yaml_path = GraphManager.get_yaml_path()\n        self.gm = GraphManager.load_from_yaml_file(gm_yaml_path)\n        # SQL meta data handling\n        # primary keys\n        self.primary_keys = {\n            QueryStats: \"stats_id\",\n            NamedQuery: \"query_id\",\n            QueryDetails: \"query_id\",\n        }\n        self.entity_infos = {}\n        pass\n\n    @classmethod\n    def get_cache_path(cls) -&gt; str:\n        home = str(Path.home())\n        cache_dir = f\"{home}/.solutions/snapquery/storage\"\n        os.makedirs(cache_dir, exist_ok=True)\n        cache_path = f\"{cache_dir}/named_queries.db\"\n        return cache_path\n\n    @classmethod\n    def from_samples(\n        cls,\n        db_path: Optional[str] = None,\n        force_init: bool = False,\n        with_backup: bool = True,\n        debug: bool = False,\n    ) -&gt; \"NamedQueryManager\":\n        \"\"\"\n        Creates and returns an instance of NamedQueryManager, optionally initializing it from sample data.\n\n        Args:\n            db_path (Optional[str]): Path to the database file. If None, the default path is used.\n            force_init (bool): If True, the existing database file is dropped and recreated, and backed up if with_backup is True.\n            with_backup (bool): If True and force_init is True, moves the database file to a backup location before reinitialization.\n            debug (bool): If True, enables debug mode which may provide additional logging.\n\n        Returns:\n            NamedQueryManager: An instance of the manager initialized with the database at `db_path`.\n        \"\"\"\n        if db_path is None:\n            db_path = cls.get_cache_path()\n\n        path_obj = Path(db_path)\n\n        # Handle backup and force initialization\n        if force_init and path_obj.exists():\n            if with_backup:\n                timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d_%H%M%S\")\n                backup_path = path_obj.with_name(f\"{path_obj.stem}-{timestamp}{path_obj.suffix}\")\n                path_obj.rename(backup_path)  # Move the existing file to backup\n\n        nqm = NamedQueryManager(db_path=db_path, debug=debug)\n        if force_init or not path_obj.exists() or path_obj.stat().st_size == 0:\n            for source_class, pk in [\n                (NamedQuery, \"query_id\"),\n                (QueryStats, \"stats_id\"),\n                (QueryDetails, \"quer_id\"),\n            ]:\n                # Fetch sample records from the specified class\n                sample_records = cls.get_sample_records(source_class=source_class)\n\n                # Define entity information dynamically based on the class and primary key\n                entityInfo = EntityInfo(sample_records, name=source_class.__name__, primaryKey=pk)\n\n                # Create and populate the table specific to each class\n                nqm.sql_db.createTable(sample_records, source_class.__name__, withDrop=True)\n                nqm.sql_db.store(sample_records, entityInfo, fixNone=True, replace=True)\n            # store yaml defined entities to SQL database\n            nqm.store_endpoints()\n            nqm.store_graphs()\n        return nqm\n\n    def store_named_query_list(self, nq_set: NamedQuerySet):\n        \"\"\"\n        store the given named query set\n\n        Args:\n            nq_list: NamedQueryList\n        \"\"\"\n        lod = []\n        for nq in nq_set.queries:\n            lod.append(asdict(nq))\n        self.store(lod=lod)\n\n    def store_query_details_list(self, qd_list: List[QueryDetails]):\n        \"\"\"\n        Stores a list of QueryDetails instances into the database. This function converts\n        each QueryDetails instance into a dictionary and then stores the entire list of dictionaries.\n        It utilizes the 'store' method to handle database operations based on the entity information\n        derived from the QueryDetails class.\n\n        Args:\n            qd_list (List[QueryDetails]): List of QueryDetails instances to be stored.\n        \"\"\"\n        qd_lod = []\n        for qd in qd_list:\n            qd_lod.append(asdict(qd))\n        self.store(lod=qd_lod, source_class=QueryDetails)\n\n    def store_stats(self, stats_list: List[QueryStats]):\n        \"\"\"\n        store the given list of query statistics\n        \"\"\"\n        stats_lod = []\n        for stats in stats_list:\n            stats_lod.append(asdict(stats))\n        self.store(lod=stats_lod, source_class=QueryStats)\n\n    def store_graphs(self, gm: GraphManager = None):\n        \"\"\"\n        Stores all graphs managed by the given GraphManager into my\n        SQL database\n        \"\"\"\n        if gm is None:\n            gm = self.gm\n\n        lod = [asdict(graph) for graph in gm]  # Convert each Graph instance to a dictionary using asdict()\n\n        self.store(lod=lod, source_class=Graph, with_create=True)\n\n    def store_endpoints(self, endpoints: Optional[Dict[str, Endpoint]] = None):\n        \"\"\"\n        Stores the given endpoints or self.endpoints into the SQL database.\n\n        Args:\n            endpoints (Optional[Dict[str, LODStorageEndpoint]]): A dictionary of endpoints to store.\n                If None, uses self.endpoints.\n        \"\"\"\n        # This is a compatiblity layer for pylodstorage Endpoints\n        # as of 2024-06 pylodstorage Endpoint still uses @Jsonable which is\n        # deprecated so we convert instances to our local endpoint modules Endpoint format\n        # and use our store mechanism to create SQL records\n        if endpoints is None:\n            endpoints = self.endpoints\n\n        endpoints_lod = []\n        for endpoint_name, lod_endpoint in endpoints.items():\n            # Create a dictionary with only the attributes that exist in lod_endpoint\n            endpoint_dict = {\n                \"name\": endpoint_name,\n                \"lang\": getattr(lod_endpoint, \"lang\", None),\n                \"endpoint\": getattr(lod_endpoint, \"endpoint\", None),\n                \"website\": getattr(lod_endpoint, \"website\", None),\n                \"database\": getattr(lod_endpoint, \"database\", None),\n                \"method\": getattr(lod_endpoint, \"method\", None),\n                \"prefixes\": getattr(lod_endpoint, \"prefixes\", None),\n                \"auth\": getattr(lod_endpoint, \"auth\", None),\n                \"user\": getattr(lod_endpoint, \"user\", None),\n                \"password\": getattr(lod_endpoint, \"password\", None),\n            }\n\n            # Remove None values\n            endpoint_dict = {k: v for k, v in endpoint_dict.items() if v is not None}\n\n            # Create SnapQueryEndpoint instance with only the available attributes\n            snap_endpoint = SnapQueryEndpoint(**endpoint_dict)\n            endpoints_lod.append(asdict(snap_endpoint))\n\n        # Store the list of dictionaries in the database\n        self.store(lod=endpoints_lod, source_class=SnapQueryEndpoint, with_create=True)\n\n    def execute_query(\n        self,\n        named_query: NamedQuery,\n        params_dict: Dict,\n        endpoint_name: str = \"wikidata\",\n        limit: int = None,\n        with_stats: bool = True,\n        prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n    ):\n        \"\"\"\n        execute the given named_query\n\n        Args:\n            named_query(NamedQuery): the query to execute\n            params_dict(Dict): the query parameters to apply (if any)\n            endpoint_name(str): the endpoint where to the excute the query\n            limit(int): the record limit for the results (if any)\n            with_stats(bool): if True run the stats\n            prefix_merger: prefix merger to use\n        \"\"\"\n        # Assemble the query bundle using the named query, endpoint, and limit\n        query_bundle = self.as_query_bundle(named_query, endpoint_name, limit, prefix_merger)\n        params = Params(query_bundle.query.query)\n        if params.has_params:\n            params.set(params_dict)\n            query = params.apply_parameters()\n            query_bundle.query.query = query\n        if with_stats:\n            # Execute the query\n            results, stats = query_bundle.get_lod_with_stats()\n            self.store_stats([stats])\n        else:\n            results = query_bundle.get_lod()\n            stats = None\n        return results, stats\n\n    def add_and_store(self, nq: NamedQuery):\n        \"\"\"\n        Adds a new NamedQuery instance and stores it in the database.\n\n        Args:\n            nq (NamedQuery): The NamedQuery instance to add and store.\n\n        \"\"\"\n        qd = QueryDetails.from_sparql(query_id=nq.query_id, sparql=nq.sparql)\n        lod = []\n        nq_record = asdict(nq)\n        lod.append(nq_record)\n        self.store(lod)\n        qd_list = []\n        qd_list.append(qd)\n        self.store_query_details_list(qd_list)\n\n    def get_entity_info(self, source_class: Type) -&gt; EntityInfo:\n        \"\"\"\n        Gets or creates EntityInfo for the given source class.\n        \"\"\"\n        if source_class not in self.entity_infos:\n            primary_key = self.primary_keys.get(source_class, None)\n            sample_records = self.get_sample_records(source_class)\n            self.entity_infos[source_class] = EntityInfo(\n                sample_records,\n                name=source_class.__name__,\n                primaryKey=primary_key,\n                debug=self.debug,\n            )\n        return self.entity_infos[source_class]\n\n    def store(\n        self,\n        lod: List[Dict[str, Any]],\n        source_class: Type = NamedQuery,\n        with_create: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Stores the given list of dictionaries in the database using entity information\n        derived from a specified source class.\n\n        Args:\n            lod (List[Dict[str, Any]]): List of dictionaries that represent the records to be stored.\n            source_class (Type): The class from which the entity information is derived. This class\n                should have an attribute or method that defines its primary key and must have a `__name__` attribute.\n                with_create(bool): if True create the table\n        Raises:\n            AttributeError: If the source class does not have the necessary method or attribute to define the primary key.\n        \"\"\"\n        entity_info = self.get_entity_info(source_class)\n        if with_create:\n            self.sql_db.createTable4EntityInfo(entityInfo=entity_info, withDrop=True)\n        # Store the list of dictionaries in the database using the defined entity information\n        self.sql_db.store(lod, entity_info, fixNone=True, replace=True)\n\n    @classmethod\n    def get_sample_records(cls, source_class: Type) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Generates a list of dictionary records based on the sample instances\n        provided by a source class. This method utilizes the `get_samples` method\n        of the source class, which should return a dictionary of sample instances.\n\n        Args:\n            source_class (Type): The class from which to fetch sample instances.\n                This class must implement a `get_samples` method that returns\n                a dictionary of instances categorized by some key.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries where each dictionary\n                is a record that corresponds to a sample instance from the source class.\n\n        Raises:\n            AttributeError: If the source_class does not have a `get_samples` method.\n        \"\"\"\n        if not hasattr(source_class, \"get_samples\"):\n            raise AttributeError(f\"The class {source_class.__name__} must have a 'get_samples' method.\")\n\n        sample_instances = source_class.get_samples()\n        list_of_records = []\n\n        # Assuming each key in the returned dictionary of get_samples corresponds to a list of instances\n        for instance_group in sample_instances.values():\n            for instance in instance_group:\n                # Ensure that the instance is a dataclass instance\n                if is_dataclass(instance):\n                    record = asdict(instance)\n                    list_of_records.append(record)\n                else:\n                    raise ValueError(f\"The instance of class {source_class.__name__} is not a dataclass instance\")\n\n        return list_of_records\n\n    def lookup(self, query_name: QueryName, lenient: bool = True) -&gt; NamedQuery:\n        \"\"\"\n        lookup the named query for the given structured query name\n\n\n        Args:\n            query_name(QueryName): the structured query name\n            lenient(bool): if True handle multiple entry errors as warnings\n        Returns:\n            NamedQuery: the named query\n        \"\"\"\n        qn = query_name\n        query_id = qn.query_id\n        sql_query = \"\"\"SELECT \n    *\nFROM \n    NamedQuery \nWHERE \n    query_id=?\"\"\"\n        query_records = self.sql_db.query(sql_query, (query_id,))\n        if not query_records:\n            msg = f\"NamedQuery not found for the specified query '{qn}'.\"\n            raise ValueError(msg)\n\n        query_count = len(query_records)\n        if query_count != 1:\n            msg = f\"multiple entries ({query_count}) for query '{qn.name}' namespace '{qn.namespace} and domain '{qn.domain}' the id '{qn.query_id}' is not unique\"\n            if lenient:\n                print(f\"warning: {msg}\")\n            else:\n                raise ValueError(msg)\n\n        record = query_records[0]\n        named_query = NamedQuery.from_record(record)\n        return named_query\n\n    def get_query(\n        self,\n        query_name: QueryName,\n        endpoint_name: str = \"wikidata\",\n        limit: int = None,\n        prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n    ) -&gt; QueryBundle:\n        \"\"\"\n        Get the query for the given parameters.\n\n        Args:\n            query_name: (QueryName):a structured query name\n            endpoint_name (str): The name of the endpoint to send the SPARQL query to, default is 'wikidata'.\n            limit (int): The query limit (if any).\n            prefix_merger: Prefix merger to use\n        Returns:\n            QueryBundle: named_query, query, and endpoint.\n        \"\"\"\n        named_query = self.lookup(query_name=query_name)\n        return self.as_query_bundle(named_query, endpoint_name, limit, prefix_merger)\n\n    def as_query_bundle(\n        self,\n        named_query: NamedQuery,\n        endpoint_name: str,\n        limit: int = None,\n        prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n    ) -&gt; QueryBundle:\n        \"\"\"\n        Assembles a QueryBundle from a NamedQuery, endpoint name, and optional limit.\n\n        Args:\n            named_query (NamedQuery): Named query object.\n            endpoint_name (str): Name of the endpoint where the query should be executed.\n            limit (int): Optional limit for the query.\n\n        Returns:\n            QueryBundle: A bundle containing the named query, the query object, and the endpoint.\n        \"\"\"\n        if endpoint_name not in self.endpoints:\n            raise ValueError(f\"Invalid endpoint {endpoint_name}\")\n\n        endpoint = self.endpoints[endpoint_name]\n        query = Query(\n            name=named_query.name,\n            query=named_query.sparql,\n            lang=\"sparql\",\n            endpoint=endpoint.endpoint,\n            limit=limit,\n        )\n        query.query = QueryPrefixMerger.merge_prefixes(named_query, query, endpoint, prefix_merger)\n        if limit:\n            query.query += f\"\\nLIMIT {limit}\"\n        return QueryBundle(named_query=named_query, query=query, endpoint=endpoint)\n\n    def get_namespaces(self) -&gt; Dict[str, int]:\n        \"\"\"\n        Retrieves all unique namespaces and the count of NamedQueries associated with each from the database,\n        sorted by the count of queries from lowest to highest.\n\n        Returns:\n            Dict[str, int]: A dictionary where keys are namespaces and values are the counts of associated queries, sorted by count.\n        \"\"\"\n        # Multi-line SQL query for better readability\n        query = \"\"\"\n        SELECT domain,namespace, COUNT(*) AS query_count\n        FROM NamedQuery\n        GROUP BY domain,namespace\n        ORDER BY COUNT(*)\n        \"\"\"\n        result = self.sql_db.query(query)\n        namespaces: Dict[str, int] = {}\n        for row in result:\n            domain = row[\"domain\"]\n            namespace = row[\"namespace\"]\n            count = int(row[\"query_count\"])\n            namespaces[f\"{namespace}@{domain}\"] = count\n        return namespaces\n\n    def get_all_queries(\n        self,\n        namespace: str = \"snapquery-examples\",\n        domain: str = \"wikidata.org\",\n        limit: int = None,  # Default limit is None, meaning no limit\n    ) -&gt; List[NamedQuery]:\n        \"\"\"\n        Retrieves named queries stored in the database, filtered by domain and namespace with pattern matching.\n        Optionally limits the number of results.\n\n        Args:\n            namespace (str): Namespace filter, supports wildcard '%', e.g., 'example%' for partial matches.\n            domain (str): Domain filter, supports wildcard '%', e.g., 'wikidata%' for partial matches.\n            limit (int): Maximum number of NamedQueries to retrieve, defaults to None for unlimited.\n\n        Returns:\n            List[NamedQuery]: A list of NamedQuery instances in the database.\n        \"\"\"\n        sql_query = \"\"\"SELECT * FROM NamedQuery \nWHERE domain LIKE ? AND namespace LIKE ?\nORDER BY domain,namespace,name\"\"\"\n        params = (f\"{domain}%\", f\"{namespace}%\")\n\n        if limit is not None:\n            sql_query += \" LIMIT ?\"\n            params += (limit,)\n\n        query_records = self.sql_db.query(sql_query, params)\n        named_queries = []\n        for record in query_records:\n            named_query = NamedQuery.from_record(record)\n            named_queries.append(named_query)\n\n        return named_queries\n\n    def get_query_stats(self, query_id: str) -&gt; list[QueryStats]:\n        \"\"\"\n        Get query stats for the given query name\n        Args:\n            query_id: id of the query\n\n        Returns:\n            list of query stats\n        \"\"\"\n        sql_query = \"\"\"\n        SELECT *\n        FROM QueryStats\n        WHERE query_id = ?\n        \"\"\"\n        query_records = self.sql_db.query(sql_query, (query_id,))\n        stats = []\n        if query_records:\n            for record in query_records:\n                query_stat = QueryStats.from_record(record)\n                stats.append(query_stat)\n        return stats\n\n    def get_query_stats_by_context(self, context: str) -&gt; list[QueryStats]:\n        \"\"\"\n        Get query stats for the given query name\n        Args:\n            query_id: id of the query\n\n        Returns:\n            list of query stats\n        \"\"\"\n        sql_query = \"\"\"\n        SELECT *\n        FROM QueryStats\n        WHERE context = ?\n        \"\"\"\n        query_records = self.sql_db.query(sql_query, (context,))\n        stats = [QueryStats.from_record(record) for record in query_records]\n        return stats\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.__init__","title":"<code>__init__(db_path=None, debug=False)</code>","text":"<p>Initializes the NamedQueryManager with a specific database path and a debug mode.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Optional[str]</code> <p>The file path to the SQLite database. If None, the default cache path is used.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, enables debug mode which may provide additional logging and error reporting.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>debug</code> <code>bool</code> <p>Stores the debug state.</p> <code>sql_db</code> <code>SQLDB</code> <p>An instance of SQLDB to manage the SQLite database interactions.</p> <code>endpoints</code> <code>dict</code> <p>A dictionary of SPARQL endpoints configured for use.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def __init__(self, db_path: str = None, debug: bool = False):\n    \"\"\"\n    Initializes the NamedQueryManager with a specific database path and a debug mode.\n\n    Args:\n        db_path (Optional[str]): The file path to the SQLite database. If None, the default cache path is used.\n        debug (bool): If True, enables debug mode which may provide additional logging and error reporting.\n\n    Attributes:\n        debug (bool): Stores the debug state.\n        sql_db (SQLDB): An instance of SQLDB to manage the SQLite database interactions.\n        endpoints (dict): A dictionary of SPARQL endpoints configured for use.\n    \"\"\"\n    if db_path is None:\n        db_path = NamedQueryManager.get_cache_path()\n    self.debug = debug\n    self.sql_db = SQLDB(dbname=db_path, check_same_thread=False, debug=debug)\n    # Get the path of the yaml_file relative to the current Python module\n    self.samples_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"samples\")\n    endpoints_path = os.path.join(self.samples_path, \"endpoints.yaml\")\n    self.endpoints = EndpointManager.getEndpoints(endpointPath=endpoints_path, lang=\"sparql\", with_default=False)\n    yaml_path = os.path.join(self.samples_path, \"meta_query.yaml\")\n    self.meta_qm = QueryManager(queriesPath=yaml_path, with_default=False, lang=\"sql\")\n    # Graph Manager\n    gm_yaml_path = GraphManager.get_yaml_path()\n    self.gm = GraphManager.load_from_yaml_file(gm_yaml_path)\n    # SQL meta data handling\n    # primary keys\n    self.primary_keys = {\n        QueryStats: \"stats_id\",\n        NamedQuery: \"query_id\",\n        QueryDetails: \"query_id\",\n    }\n    self.entity_infos = {}\n    pass\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.add_and_store","title":"<code>add_and_store(nq)</code>","text":"<p>Adds a new NamedQuery instance and stores it in the database.</p> <p>Parameters:</p> Name Type Description Default <code>nq</code> <code>NamedQuery</code> <p>The NamedQuery instance to add and store.</p> required Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def add_and_store(self, nq: NamedQuery):\n    \"\"\"\n    Adds a new NamedQuery instance and stores it in the database.\n\n    Args:\n        nq (NamedQuery): The NamedQuery instance to add and store.\n\n    \"\"\"\n    qd = QueryDetails.from_sparql(query_id=nq.query_id, sparql=nq.sparql)\n    lod = []\n    nq_record = asdict(nq)\n    lod.append(nq_record)\n    self.store(lod)\n    qd_list = []\n    qd_list.append(qd)\n    self.store_query_details_list(qd_list)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.as_query_bundle","title":"<code>as_query_bundle(named_query, endpoint_name, limit=None, prefix_merger=QueryPrefixMerger.SIMPLE_MERGER)</code>","text":"<p>Assembles a QueryBundle from a NamedQuery, endpoint name, and optional limit.</p> <p>Parameters:</p> Name Type Description Default <code>named_query</code> <code>NamedQuery</code> <p>Named query object.</p> required <code>endpoint_name</code> <code>str</code> <p>Name of the endpoint where the query should be executed.</p> required <code>limit</code> <code>int</code> <p>Optional limit for the query.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QueryBundle</code> <code>QueryBundle</code> <p>A bundle containing the named query, the query object, and the endpoint.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def as_query_bundle(\n    self,\n    named_query: NamedQuery,\n    endpoint_name: str,\n    limit: int = None,\n    prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n) -&gt; QueryBundle:\n    \"\"\"\n    Assembles a QueryBundle from a NamedQuery, endpoint name, and optional limit.\n\n    Args:\n        named_query (NamedQuery): Named query object.\n        endpoint_name (str): Name of the endpoint where the query should be executed.\n        limit (int): Optional limit for the query.\n\n    Returns:\n        QueryBundle: A bundle containing the named query, the query object, and the endpoint.\n    \"\"\"\n    if endpoint_name not in self.endpoints:\n        raise ValueError(f\"Invalid endpoint {endpoint_name}\")\n\n    endpoint = self.endpoints[endpoint_name]\n    query = Query(\n        name=named_query.name,\n        query=named_query.sparql,\n        lang=\"sparql\",\n        endpoint=endpoint.endpoint,\n        limit=limit,\n    )\n    query.query = QueryPrefixMerger.merge_prefixes(named_query, query, endpoint, prefix_merger)\n    if limit:\n        query.query += f\"\\nLIMIT {limit}\"\n    return QueryBundle(named_query=named_query, query=query, endpoint=endpoint)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.execute_query","title":"<code>execute_query(named_query, params_dict, endpoint_name='wikidata', limit=None, with_stats=True, prefix_merger=QueryPrefixMerger.SIMPLE_MERGER)</code>","text":"<p>execute the given named_query</p> <p>Parameters:</p> Name Type Description Default <code>named_query(NamedQuery)</code> <p>the query to execute</p> required <code>params_dict(Dict)</code> <p>the query parameters to apply (if any)</p> required <code>endpoint_name(str)</code> <p>the endpoint where to the excute the query</p> required <code>limit(int)</code> <p>the record limit for the results (if any)</p> required <code>with_stats(bool)</code> <p>if True run the stats</p> required <code>prefix_merger</code> <code>QueryPrefixMerger</code> <p>prefix merger to use</p> <code>SIMPLE_MERGER</code> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def execute_query(\n    self,\n    named_query: NamedQuery,\n    params_dict: Dict,\n    endpoint_name: str = \"wikidata\",\n    limit: int = None,\n    with_stats: bool = True,\n    prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n):\n    \"\"\"\n    execute the given named_query\n\n    Args:\n        named_query(NamedQuery): the query to execute\n        params_dict(Dict): the query parameters to apply (if any)\n        endpoint_name(str): the endpoint where to the excute the query\n        limit(int): the record limit for the results (if any)\n        with_stats(bool): if True run the stats\n        prefix_merger: prefix merger to use\n    \"\"\"\n    # Assemble the query bundle using the named query, endpoint, and limit\n    query_bundle = self.as_query_bundle(named_query, endpoint_name, limit, prefix_merger)\n    params = Params(query_bundle.query.query)\n    if params.has_params:\n        params.set(params_dict)\n        query = params.apply_parameters()\n        query_bundle.query.query = query\n    if with_stats:\n        # Execute the query\n        results, stats = query_bundle.get_lod_with_stats()\n        self.store_stats([stats])\n    else:\n        results = query_bundle.get_lod()\n        stats = None\n    return results, stats\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.from_samples","title":"<code>from_samples(db_path=None, force_init=False, with_backup=True, debug=False)</code>  <code>classmethod</code>","text":"<p>Creates and returns an instance of NamedQueryManager, optionally initializing it from sample data.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Optional[str]</code> <p>Path to the database file. If None, the default path is used.</p> <code>None</code> <code>force_init</code> <code>bool</code> <p>If True, the existing database file is dropped and recreated, and backed up if with_backup is True.</p> <code>False</code> <code>with_backup</code> <code>bool</code> <p>If True and force_init is True, moves the database file to a backup location before reinitialization.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>If True, enables debug mode which may provide additional logging.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>NamedQueryManager</code> <code>NamedQueryManager</code> <p>An instance of the manager initialized with the database at <code>db_path</code>.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef from_samples(\n    cls,\n    db_path: Optional[str] = None,\n    force_init: bool = False,\n    with_backup: bool = True,\n    debug: bool = False,\n) -&gt; \"NamedQueryManager\":\n    \"\"\"\n    Creates and returns an instance of NamedQueryManager, optionally initializing it from sample data.\n\n    Args:\n        db_path (Optional[str]): Path to the database file. If None, the default path is used.\n        force_init (bool): If True, the existing database file is dropped and recreated, and backed up if with_backup is True.\n        with_backup (bool): If True and force_init is True, moves the database file to a backup location before reinitialization.\n        debug (bool): If True, enables debug mode which may provide additional logging.\n\n    Returns:\n        NamedQueryManager: An instance of the manager initialized with the database at `db_path`.\n    \"\"\"\n    if db_path is None:\n        db_path = cls.get_cache_path()\n\n    path_obj = Path(db_path)\n\n    # Handle backup and force initialization\n    if force_init and path_obj.exists():\n        if with_backup:\n            timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d_%H%M%S\")\n            backup_path = path_obj.with_name(f\"{path_obj.stem}-{timestamp}{path_obj.suffix}\")\n            path_obj.rename(backup_path)  # Move the existing file to backup\n\n    nqm = NamedQueryManager(db_path=db_path, debug=debug)\n    if force_init or not path_obj.exists() or path_obj.stat().st_size == 0:\n        for source_class, pk in [\n            (NamedQuery, \"query_id\"),\n            (QueryStats, \"stats_id\"),\n            (QueryDetails, \"quer_id\"),\n        ]:\n            # Fetch sample records from the specified class\n            sample_records = cls.get_sample_records(source_class=source_class)\n\n            # Define entity information dynamically based on the class and primary key\n            entityInfo = EntityInfo(sample_records, name=source_class.__name__, primaryKey=pk)\n\n            # Create and populate the table specific to each class\n            nqm.sql_db.createTable(sample_records, source_class.__name__, withDrop=True)\n            nqm.sql_db.store(sample_records, entityInfo, fixNone=True, replace=True)\n        # store yaml defined entities to SQL database\n        nqm.store_endpoints()\n        nqm.store_graphs()\n    return nqm\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.get_all_queries","title":"<code>get_all_queries(namespace='snapquery-examples', domain='wikidata.org', limit=None)</code>","text":"<p>Retrieves named queries stored in the database, filtered by domain and namespace with pattern matching. Optionally limits the number of results.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Namespace filter, supports wildcard '%', e.g., 'example%' for partial matches.</p> <code>'snapquery-examples'</code> <code>domain</code> <code>str</code> <p>Domain filter, supports wildcard '%', e.g., 'wikidata%' for partial matches.</p> <code>'wikidata.org'</code> <code>limit</code> <code>int</code> <p>Maximum number of NamedQueries to retrieve, defaults to None for unlimited.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[NamedQuery]</code> <p>List[NamedQuery]: A list of NamedQuery instances in the database.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>    def get_all_queries(\n        self,\n        namespace: str = \"snapquery-examples\",\n        domain: str = \"wikidata.org\",\n        limit: int = None,  # Default limit is None, meaning no limit\n    ) -&gt; List[NamedQuery]:\n        \"\"\"\n        Retrieves named queries stored in the database, filtered by domain and namespace with pattern matching.\n        Optionally limits the number of results.\n\n        Args:\n            namespace (str): Namespace filter, supports wildcard '%', e.g., 'example%' for partial matches.\n            domain (str): Domain filter, supports wildcard '%', e.g., 'wikidata%' for partial matches.\n            limit (int): Maximum number of NamedQueries to retrieve, defaults to None for unlimited.\n\n        Returns:\n            List[NamedQuery]: A list of NamedQuery instances in the database.\n        \"\"\"\n        sql_query = \"\"\"SELECT * FROM NamedQuery \nWHERE domain LIKE ? AND namespace LIKE ?\nORDER BY domain,namespace,name\"\"\"\n        params = (f\"{domain}%\", f\"{namespace}%\")\n\n        if limit is not None:\n            sql_query += \" LIMIT ?\"\n            params += (limit,)\n\n        query_records = self.sql_db.query(sql_query, params)\n        named_queries = []\n        for record in query_records:\n            named_query = NamedQuery.from_record(record)\n            named_queries.append(named_query)\n\n        return named_queries\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.get_entity_info","title":"<code>get_entity_info(source_class)</code>","text":"<p>Gets or creates EntityInfo for the given source class.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def get_entity_info(self, source_class: Type) -&gt; EntityInfo:\n    \"\"\"\n    Gets or creates EntityInfo for the given source class.\n    \"\"\"\n    if source_class not in self.entity_infos:\n        primary_key = self.primary_keys.get(source_class, None)\n        sample_records = self.get_sample_records(source_class)\n        self.entity_infos[source_class] = EntityInfo(\n            sample_records,\n            name=source_class.__name__,\n            primaryKey=primary_key,\n            debug=self.debug,\n        )\n    return self.entity_infos[source_class]\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.get_namespaces","title":"<code>get_namespaces()</code>","text":"<p>Retrieves all unique namespaces and the count of NamedQueries associated with each from the database, sorted by the count of queries from lowest to highest.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: A dictionary where keys are namespaces and values are the counts of associated queries, sorted by count.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def get_namespaces(self) -&gt; Dict[str, int]:\n    \"\"\"\n    Retrieves all unique namespaces and the count of NamedQueries associated with each from the database,\n    sorted by the count of queries from lowest to highest.\n\n    Returns:\n        Dict[str, int]: A dictionary where keys are namespaces and values are the counts of associated queries, sorted by count.\n    \"\"\"\n    # Multi-line SQL query for better readability\n    query = \"\"\"\n    SELECT domain,namespace, COUNT(*) AS query_count\n    FROM NamedQuery\n    GROUP BY domain,namespace\n    ORDER BY COUNT(*)\n    \"\"\"\n    result = self.sql_db.query(query)\n    namespaces: Dict[str, int] = {}\n    for row in result:\n        domain = row[\"domain\"]\n        namespace = row[\"namespace\"]\n        count = int(row[\"query_count\"])\n        namespaces[f\"{namespace}@{domain}\"] = count\n    return namespaces\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.get_query","title":"<code>get_query(query_name, endpoint_name='wikidata', limit=None, prefix_merger=QueryPrefixMerger.SIMPLE_MERGER)</code>","text":"<p>Get the query for the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>QueryName</code> <p>(QueryName):a structured query name</p> required <code>endpoint_name</code> <code>str</code> <p>The name of the endpoint to send the SPARQL query to, default is 'wikidata'.</p> <code>'wikidata'</code> <code>limit</code> <code>int</code> <p>The query limit (if any).</p> <code>None</code> <code>prefix_merger</code> <code>QueryPrefixMerger</code> <p>Prefix merger to use</p> <code>SIMPLE_MERGER</code> <p>Returns:     QueryBundle: named_query, query, and endpoint.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def get_query(\n    self,\n    query_name: QueryName,\n    endpoint_name: str = \"wikidata\",\n    limit: int = None,\n    prefix_merger: QueryPrefixMerger = QueryPrefixMerger.SIMPLE_MERGER,\n) -&gt; QueryBundle:\n    \"\"\"\n    Get the query for the given parameters.\n\n    Args:\n        query_name: (QueryName):a structured query name\n        endpoint_name (str): The name of the endpoint to send the SPARQL query to, default is 'wikidata'.\n        limit (int): The query limit (if any).\n        prefix_merger: Prefix merger to use\n    Returns:\n        QueryBundle: named_query, query, and endpoint.\n    \"\"\"\n    named_query = self.lookup(query_name=query_name)\n    return self.as_query_bundle(named_query, endpoint_name, limit, prefix_merger)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.get_query_stats","title":"<code>get_query_stats(query_id)</code>","text":"<p>Get query stats for the given query name Args:     query_id: id of the query</p> <p>Returns:</p> Type Description <code>list[QueryStats]</code> <p>list of query stats</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def get_query_stats(self, query_id: str) -&gt; list[QueryStats]:\n    \"\"\"\n    Get query stats for the given query name\n    Args:\n        query_id: id of the query\n\n    Returns:\n        list of query stats\n    \"\"\"\n    sql_query = \"\"\"\n    SELECT *\n    FROM QueryStats\n    WHERE query_id = ?\n    \"\"\"\n    query_records = self.sql_db.query(sql_query, (query_id,))\n    stats = []\n    if query_records:\n        for record in query_records:\n            query_stat = QueryStats.from_record(record)\n            stats.append(query_stat)\n    return stats\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.get_query_stats_by_context","title":"<code>get_query_stats_by_context(context)</code>","text":"<p>Get query stats for the given query name Args:     query_id: id of the query</p> <p>Returns:</p> Type Description <code>list[QueryStats]</code> <p>list of query stats</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def get_query_stats_by_context(self, context: str) -&gt; list[QueryStats]:\n    \"\"\"\n    Get query stats for the given query name\n    Args:\n        query_id: id of the query\n\n    Returns:\n        list of query stats\n    \"\"\"\n    sql_query = \"\"\"\n    SELECT *\n    FROM QueryStats\n    WHERE context = ?\n    \"\"\"\n    query_records = self.sql_db.query(sql_query, (context,))\n    stats = [QueryStats.from_record(record) for record in query_records]\n    return stats\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.get_sample_records","title":"<code>get_sample_records(source_class)</code>  <code>classmethod</code>","text":"<p>Generates a list of dictionary records based on the sample instances provided by a source class. This method utilizes the <code>get_samples</code> method of the source class, which should return a dictionary of sample instances.</p> <p>Parameters:</p> Name Type Description Default <code>source_class</code> <code>Type</code> <p>The class from which to fetch sample instances. This class must implement a <code>get_samples</code> method that returns a dictionary of instances categorized by some key.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries where each dictionary is a record that corresponds to a sample instance from the source class.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the source_class does not have a <code>get_samples</code> method.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef get_sample_records(cls, source_class: Type) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Generates a list of dictionary records based on the sample instances\n    provided by a source class. This method utilizes the `get_samples` method\n    of the source class, which should return a dictionary of sample instances.\n\n    Args:\n        source_class (Type): The class from which to fetch sample instances.\n            This class must implement a `get_samples` method that returns\n            a dictionary of instances categorized by some key.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries where each dictionary\n            is a record that corresponds to a sample instance from the source class.\n\n    Raises:\n        AttributeError: If the source_class does not have a `get_samples` method.\n    \"\"\"\n    if not hasattr(source_class, \"get_samples\"):\n        raise AttributeError(f\"The class {source_class.__name__} must have a 'get_samples' method.\")\n\n    sample_instances = source_class.get_samples()\n    list_of_records = []\n\n    # Assuming each key in the returned dictionary of get_samples corresponds to a list of instances\n    for instance_group in sample_instances.values():\n        for instance in instance_group:\n            # Ensure that the instance is a dataclass instance\n            if is_dataclass(instance):\n                record = asdict(instance)\n                list_of_records.append(record)\n            else:\n                raise ValueError(f\"The instance of class {source_class.__name__} is not a dataclass instance\")\n\n    return list_of_records\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.lookup","title":"<code>lookup(query_name, lenient=True)</code>","text":"<p>lookup the named query for the given structured query name</p> <p>Parameters:</p> Name Type Description Default <code>query_name(QueryName)</code> <p>the structured query name</p> required <code>lenient(bool)</code> <p>if True handle multiple entry errors as warnings</p> required <p>Returns:     NamedQuery: the named query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>    def lookup(self, query_name: QueryName, lenient: bool = True) -&gt; NamedQuery:\n        \"\"\"\n        lookup the named query for the given structured query name\n\n\n        Args:\n            query_name(QueryName): the structured query name\n            lenient(bool): if True handle multiple entry errors as warnings\n        Returns:\n            NamedQuery: the named query\n        \"\"\"\n        qn = query_name\n        query_id = qn.query_id\n        sql_query = \"\"\"SELECT \n    *\nFROM \n    NamedQuery \nWHERE \n    query_id=?\"\"\"\n        query_records = self.sql_db.query(sql_query, (query_id,))\n        if not query_records:\n            msg = f\"NamedQuery not found for the specified query '{qn}'.\"\n            raise ValueError(msg)\n\n        query_count = len(query_records)\n        if query_count != 1:\n            msg = f\"multiple entries ({query_count}) for query '{qn.name}' namespace '{qn.namespace} and domain '{qn.domain}' the id '{qn.query_id}' is not unique\"\n            if lenient:\n                print(f\"warning: {msg}\")\n            else:\n                raise ValueError(msg)\n\n        record = query_records[0]\n        named_query = NamedQuery.from_record(record)\n        return named_query\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.store","title":"<code>store(lod, source_class=NamedQuery, with_create=False)</code>","text":"<p>Stores the given list of dictionaries in the database using entity information derived from a specified source class.</p> <p>Parameters:</p> Name Type Description Default <code>lod</code> <code>List[Dict[str, Any]]</code> <p>List of dictionaries that represent the records to be stored.</p> required <code>source_class</code> <code>Type</code> <p>The class from which the entity information is derived. This class should have an attribute or method that defines its primary key and must have a <code>__name__</code> attribute. with_create(bool): if True create the table</p> <code>NamedQuery</code> <p>Raises:     AttributeError: If the source class does not have the necessary method or attribute to define the primary key.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def store(\n    self,\n    lod: List[Dict[str, Any]],\n    source_class: Type = NamedQuery,\n    with_create: bool = False,\n) -&gt; None:\n    \"\"\"\n    Stores the given list of dictionaries in the database using entity information\n    derived from a specified source class.\n\n    Args:\n        lod (List[Dict[str, Any]]): List of dictionaries that represent the records to be stored.\n        source_class (Type): The class from which the entity information is derived. This class\n            should have an attribute or method that defines its primary key and must have a `__name__` attribute.\n            with_create(bool): if True create the table\n    Raises:\n        AttributeError: If the source class does not have the necessary method or attribute to define the primary key.\n    \"\"\"\n    entity_info = self.get_entity_info(source_class)\n    if with_create:\n        self.sql_db.createTable4EntityInfo(entityInfo=entity_info, withDrop=True)\n    # Store the list of dictionaries in the database using the defined entity information\n    self.sql_db.store(lod, entity_info, fixNone=True, replace=True)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.store_endpoints","title":"<code>store_endpoints(endpoints=None)</code>","text":"<p>Stores the given endpoints or self.endpoints into the SQL database.</p> <p>Parameters:</p> Name Type Description Default <code>endpoints</code> <code>Optional[Dict[str, LODStorageEndpoint]]</code> <p>A dictionary of endpoints to store. If None, uses self.endpoints.</p> <code>None</code> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def store_endpoints(self, endpoints: Optional[Dict[str, Endpoint]] = None):\n    \"\"\"\n    Stores the given endpoints or self.endpoints into the SQL database.\n\n    Args:\n        endpoints (Optional[Dict[str, LODStorageEndpoint]]): A dictionary of endpoints to store.\n            If None, uses self.endpoints.\n    \"\"\"\n    # This is a compatiblity layer for pylodstorage Endpoints\n    # as of 2024-06 pylodstorage Endpoint still uses @Jsonable which is\n    # deprecated so we convert instances to our local endpoint modules Endpoint format\n    # and use our store mechanism to create SQL records\n    if endpoints is None:\n        endpoints = self.endpoints\n\n    endpoints_lod = []\n    for endpoint_name, lod_endpoint in endpoints.items():\n        # Create a dictionary with only the attributes that exist in lod_endpoint\n        endpoint_dict = {\n            \"name\": endpoint_name,\n            \"lang\": getattr(lod_endpoint, \"lang\", None),\n            \"endpoint\": getattr(lod_endpoint, \"endpoint\", None),\n            \"website\": getattr(lod_endpoint, \"website\", None),\n            \"database\": getattr(lod_endpoint, \"database\", None),\n            \"method\": getattr(lod_endpoint, \"method\", None),\n            \"prefixes\": getattr(lod_endpoint, \"prefixes\", None),\n            \"auth\": getattr(lod_endpoint, \"auth\", None),\n            \"user\": getattr(lod_endpoint, \"user\", None),\n            \"password\": getattr(lod_endpoint, \"password\", None),\n        }\n\n        # Remove None values\n        endpoint_dict = {k: v for k, v in endpoint_dict.items() if v is not None}\n\n        # Create SnapQueryEndpoint instance with only the available attributes\n        snap_endpoint = SnapQueryEndpoint(**endpoint_dict)\n        endpoints_lod.append(asdict(snap_endpoint))\n\n    # Store the list of dictionaries in the database\n    self.store(lod=endpoints_lod, source_class=SnapQueryEndpoint, with_create=True)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.store_graphs","title":"<code>store_graphs(gm=None)</code>","text":"<p>Stores all graphs managed by the given GraphManager into my SQL database</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def store_graphs(self, gm: GraphManager = None):\n    \"\"\"\n    Stores all graphs managed by the given GraphManager into my\n    SQL database\n    \"\"\"\n    if gm is None:\n        gm = self.gm\n\n    lod = [asdict(graph) for graph in gm]  # Convert each Graph instance to a dictionary using asdict()\n\n    self.store(lod=lod, source_class=Graph, with_create=True)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.store_named_query_list","title":"<code>store_named_query_list(nq_set)</code>","text":"<p>store the given named query set</p> <p>Parameters:</p> Name Type Description Default <code>nq_list</code> <p>NamedQueryList</p> required Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def store_named_query_list(self, nq_set: NamedQuerySet):\n    \"\"\"\n    store the given named query set\n\n    Args:\n        nq_list: NamedQueryList\n    \"\"\"\n    lod = []\n    for nq in nq_set.queries:\n        lod.append(asdict(nq))\n    self.store(lod=lod)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.store_query_details_list","title":"<code>store_query_details_list(qd_list)</code>","text":"<p>Stores a list of QueryDetails instances into the database. This function converts each QueryDetails instance into a dictionary and then stores the entire list of dictionaries. It utilizes the 'store' method to handle database operations based on the entity information derived from the QueryDetails class.</p> <p>Parameters:</p> Name Type Description Default <code>qd_list</code> <code>List[QueryDetails]</code> <p>List of QueryDetails instances to be stored.</p> required Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def store_query_details_list(self, qd_list: List[QueryDetails]):\n    \"\"\"\n    Stores a list of QueryDetails instances into the database. This function converts\n    each QueryDetails instance into a dictionary and then stores the entire list of dictionaries.\n    It utilizes the 'store' method to handle database operations based on the entity information\n    derived from the QueryDetails class.\n\n    Args:\n        qd_list (List[QueryDetails]): List of QueryDetails instances to be stored.\n    \"\"\"\n    qd_lod = []\n    for qd in qd_list:\n        qd_lod.append(asdict(qd))\n    self.store(lod=qd_lod, source_class=QueryDetails)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQueryManager.store_stats","title":"<code>store_stats(stats_list)</code>","text":"<p>store the given list of query statistics</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def store_stats(self, stats_list: List[QueryStats]):\n    \"\"\"\n    store the given list of query statistics\n    \"\"\"\n    stats_lod = []\n    for stats in stats_list:\n        stats_lod.append(asdict(stats))\n    self.store(lod=stats_lod, source_class=QueryStats)\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQuerySet","title":"<code>NamedQuerySet</code>","text":"<p>a list/set of named queries which defines a namespace</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@lod_storable\nclass NamedQuerySet:\n    \"\"\"\n    a list/set of named queries which defines a namespace\n    \"\"\"\n\n    domain: str  # the domain of this NamedQuerySet\n    namespace: str  # the namespace\n\n    target_graph_name: str  # the name of the target graph\n    queries: List[NamedQuery] = field(default_factory=list)\n\n    def __len__(self):\n        return len(self.queries)\n\n    def __post_init__(self):\n        \"\"\"\n        Initialize the dictionary after the object is created\n        \"\"\"\n        self._query_dict = {query.query_id: query for query in self.queries}\n\n    def add(self, query: NamedQuery):\n        \"\"\"\n        Add a query to both the list and dictionary\n        \"\"\"\n        if query.query_id not in self._query_dict:\n            self.queries.append(query)\n            self._query_dict[query.query_id] = query\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQuerySet.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the dictionary after the object is created</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Initialize the dictionary after the object is created\n    \"\"\"\n    self._query_dict = {query.query_id: query for query in self.queries}\n</code></pre>"},{"location":"#snapquery.snapquery_core.NamedQuerySet.add","title":"<code>add(query)</code>","text":"<p>Add a query to both the list and dictionary</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def add(self, query: NamedQuery):\n    \"\"\"\n    Add a query to both the list and dictionary\n    \"\"\"\n    if query.query_id not in self._query_dict:\n        self.queries.append(query)\n        self._query_dict[query.query_id] = query\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryBundle","title":"<code>QueryBundle</code>","text":"<p>Bundles a named query, a query, and an endpoint into a single manageable object, facilitating the execution of SPARQL queries.</p> <p>Attributes:</p> Name Type Description <code>named_query</code> <code>NamedQuery</code> <p>The named query object, which includes metadata about the query.</p> <code>query</code> <code>Query</code> <p>The actual query object that contains the SPARQL query string.</p> <code>endpoint</code> <code>Endpoint</code> <p>The endpoint object where the SPARQL query should be executed.</p> <code>sparql</code> <code>SPARQL</code> <p>A SPARQL service object initialized with the endpoint URL.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>class QueryBundle:\n    \"\"\"\n    Bundles a named query, a query, and an endpoint into a single manageable object, facilitating the execution of SPARQL queries.\n\n    Attributes:\n        named_query (NamedQuery): The named query object, which includes metadata about the query.\n        query (Query): The actual query object that contains the SPARQL query string.\n        endpoint (Endpoint): The endpoint object where the SPARQL query should be executed.\n        sparql (SPARQL): A SPARQL service object initialized with the endpoint URL.\n    \"\"\"\n\n    def __init__(self, named_query: NamedQuery, query: Query, endpoint: Endpoint = None):\n        \"\"\"\n        Initializes a new instance of the QueryBundle class.\n\n        Args:\n            named_query (NamedQuery): An instance of NamedQuery that provides a named reference to the query.\n            query (Query): An instance of Query containing the SPARQL query string.\n            endpoint (Endpoint): An instance of Endpoint representing the SPARQL endpoint URL.\n        \"\"\"\n        self.named_query = named_query\n        self.query = query\n        self.update_endpoint(endpoint)\n\n    def update_endpoint(self, endpoint):\n        self.endpoint = endpoint\n        if endpoint:\n            self.sparql = SPARQL(endpoint.endpoint, method=self.endpoint.method)\n\n    def raw_query(self, resultFormat, mime_type: str = None, timeout: float = 10.0):\n        \"\"\"\n        returns raw result of the endpoint\n\n        Args:\n            resultFormat(str): format of the result\n            mime_type(str): mime_type to use (if any)\n            timeout(float): timeout in seconds\n\n        Returns:\n            raw result of the query\n        \"\"\"\n        params = {\"query\": self.query.query, \"format\": resultFormat}\n        payload = {}\n        if mime_type:\n            headers = {\"Accept\": mime_type}\n        else:\n            headers = {}\n        endpoint_url = self.endpoint.endpoint\n        method = self.endpoint.method\n        response = requests.request(\n            method,\n            endpoint_url,\n            headers=headers,\n            data=payload,\n            params=params,\n            timeout=timeout,\n        )\n        return response.text\n\n    def get_lod(self) -&gt; List[dict]:\n        \"\"\"\n        Executes the stored query using the SPARQL service and returns the results as a list of dictionaries.\n\n        Returns:\n            List[dict]: A list where each dictionary represents a row of results from the SPARQL query.\n        \"\"\"\n        lod = self.sparql.queryAsListOfDicts(self.query.query)\n        return lod\n\n    def get_lod_with_stats(self) -&gt; tuple[list[dict], QueryStats]:\n        \"\"\"\n        Executes the stored query using the SPARQL service and returns the results as a list of dictionaries.\n\n        Returns:\n            List[dict]: A list where each dictionary represents a row of results from the SPARQL query.\n        \"\"\"\n        logger.info(f\"Querying {self.endpoint.name} with query {self.named_query.name}\")\n        query_stat = QueryStats(query_id=self.named_query.query_id, endpoint_name=self.endpoint.name)\n        try:\n            lod = self.sparql.queryAsListOfDicts(self.query.query)\n            query_stat.records = len(lod) if lod else -1\n            query_stat.done()\n        except Exception as ex:\n            lod = []\n            logger.debug(f\"Execution of query failed: {ex}\")\n            query_stat.error(ex)\n        return (lod, query_stat)\n\n    def format_result(\n        self,\n        qlod: List[Dict[str, Any]] = None,\n        r_format: Format = Format.json,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Formats the query results based on the specified format and prints them.\n\n        Args:\n            qlod (List[Dict[str, Any]]): The list of dictionaries that represent the query results.\n            query (Query): The query object which contains details like the endpoint and the database.\n            r_format(Format): The format in which to print the results.\n\n        Returns:\n            Optional[str]: The formatted string representation of the query results, or None if printed directly.\n        \"\"\"\n        if qlod is None:\n            qlod = self.get_lod()\n        if r_format is None:\n            r_format = Format.json\n        if r_format == Format.csv:\n            csv_output = CSV.toCSV(qlod)\n            return csv_output\n        elif r_format in [Format.latex, Format.github, Format.mediawiki, Format.html]:\n            doc = self.query.documentQueryResult(qlod, tablefmt=str(r_format), floatfmt=\".1f\")\n            return doc.asText()\n        elif r_format == Format.json:\n            return json.dumps(qlod, indent=2, sort_keys=True, default=str)\n        return None  # In case no format is matched or needed\n\n    def set_limit(self, limit: int = None):\n        \"\"\"\n        set the limit of my query\n\n        Args:\n            limit(int): the limit to set - default: None\n        \"\"\"\n        if limit:\n            sparql_query = self.query.query\n            # @TODO - this is too naive for cases where\n            # there are SPARQL elements hat have a \"limit\" in the name e.g. \"height_limit\"\n            # or if there is a LIMIT in a subquery\n            if \"limit\" in sparql_query or \"LIMIT\" in sparql_query:\n                sparql_query = re.sub(r\"(limit|LIMIT)\\s+(\\d+)\", f\"LIMIT {limit}\", sparql_query)\n            else:\n                sparql_query += f\"\\nLIMIT {limit}\"\n            self.query.query = sparql_query\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryBundle.__init__","title":"<code>__init__(named_query, query, endpoint=None)</code>","text":"<p>Initializes a new instance of the QueryBundle class.</p> <p>Parameters:</p> Name Type Description Default <code>named_query</code> <code>NamedQuery</code> <p>An instance of NamedQuery that provides a named reference to the query.</p> required <code>query</code> <code>Query</code> <p>An instance of Query containing the SPARQL query string.</p> required <code>endpoint</code> <code>Endpoint</code> <p>An instance of Endpoint representing the SPARQL endpoint URL.</p> <code>None</code> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def __init__(self, named_query: NamedQuery, query: Query, endpoint: Endpoint = None):\n    \"\"\"\n    Initializes a new instance of the QueryBundle class.\n\n    Args:\n        named_query (NamedQuery): An instance of NamedQuery that provides a named reference to the query.\n        query (Query): An instance of Query containing the SPARQL query string.\n        endpoint (Endpoint): An instance of Endpoint representing the SPARQL endpoint URL.\n    \"\"\"\n    self.named_query = named_query\n    self.query = query\n    self.update_endpoint(endpoint)\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryBundle.format_result","title":"<code>format_result(qlod=None, r_format=Format.json)</code>","text":"<p>Formats the query results based on the specified format and prints them.</p> <p>Parameters:</p> Name Type Description Default <code>qlod</code> <code>List[Dict[str, Any]]</code> <p>The list of dictionaries that represent the query results.</p> <code>None</code> <code>query</code> <code>Query</code> <p>The query object which contains details like the endpoint and the database.</p> required <code>r_format(Format)</code> <p>The format in which to print the results.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The formatted string representation of the query results, or None if printed directly.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def format_result(\n    self,\n    qlod: List[Dict[str, Any]] = None,\n    r_format: Format = Format.json,\n) -&gt; Optional[str]:\n    \"\"\"\n    Formats the query results based on the specified format and prints them.\n\n    Args:\n        qlod (List[Dict[str, Any]]): The list of dictionaries that represent the query results.\n        query (Query): The query object which contains details like the endpoint and the database.\n        r_format(Format): The format in which to print the results.\n\n    Returns:\n        Optional[str]: The formatted string representation of the query results, or None if printed directly.\n    \"\"\"\n    if qlod is None:\n        qlod = self.get_lod()\n    if r_format is None:\n        r_format = Format.json\n    if r_format == Format.csv:\n        csv_output = CSV.toCSV(qlod)\n        return csv_output\n    elif r_format in [Format.latex, Format.github, Format.mediawiki, Format.html]:\n        doc = self.query.documentQueryResult(qlod, tablefmt=str(r_format), floatfmt=\".1f\")\n        return doc.asText()\n    elif r_format == Format.json:\n        return json.dumps(qlod, indent=2, sort_keys=True, default=str)\n    return None  # In case no format is matched or needed\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryBundle.get_lod","title":"<code>get_lod()</code>","text":"<p>Executes the stored query using the SPARQL service and returns the results as a list of dictionaries.</p> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: A list where each dictionary represents a row of results from the SPARQL query.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def get_lod(self) -&gt; List[dict]:\n    \"\"\"\n    Executes the stored query using the SPARQL service and returns the results as a list of dictionaries.\n\n    Returns:\n        List[dict]: A list where each dictionary represents a row of results from the SPARQL query.\n    \"\"\"\n    lod = self.sparql.queryAsListOfDicts(self.query.query)\n    return lod\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryBundle.get_lod_with_stats","title":"<code>get_lod_with_stats()</code>","text":"<p>Executes the stored query using the SPARQL service and returns the results as a list of dictionaries.</p> <p>Returns:</p> Type Description <code>tuple[list[dict], QueryStats]</code> <p>List[dict]: A list where each dictionary represents a row of results from the SPARQL query.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def get_lod_with_stats(self) -&gt; tuple[list[dict], QueryStats]:\n    \"\"\"\n    Executes the stored query using the SPARQL service and returns the results as a list of dictionaries.\n\n    Returns:\n        List[dict]: A list where each dictionary represents a row of results from the SPARQL query.\n    \"\"\"\n    logger.info(f\"Querying {self.endpoint.name} with query {self.named_query.name}\")\n    query_stat = QueryStats(query_id=self.named_query.query_id, endpoint_name=self.endpoint.name)\n    try:\n        lod = self.sparql.queryAsListOfDicts(self.query.query)\n        query_stat.records = len(lod) if lod else -1\n        query_stat.done()\n    except Exception as ex:\n        lod = []\n        logger.debug(f\"Execution of query failed: {ex}\")\n        query_stat.error(ex)\n    return (lod, query_stat)\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryBundle.raw_query","title":"<code>raw_query(resultFormat, mime_type=None, timeout=10.0)</code>","text":"<p>returns raw result of the endpoint</p> <p>Parameters:</p> Name Type Description Default <code>resultFormat(str)</code> <p>format of the result</p> required <code>mime_type(str)</code> <p>mime_type to use (if any)</p> required <code>timeout(float)</code> <p>timeout in seconds</p> required <p>Returns:</p> Type Description <p>raw result of the query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def raw_query(self, resultFormat, mime_type: str = None, timeout: float = 10.0):\n    \"\"\"\n    returns raw result of the endpoint\n\n    Args:\n        resultFormat(str): format of the result\n        mime_type(str): mime_type to use (if any)\n        timeout(float): timeout in seconds\n\n    Returns:\n        raw result of the query\n    \"\"\"\n    params = {\"query\": self.query.query, \"format\": resultFormat}\n    payload = {}\n    if mime_type:\n        headers = {\"Accept\": mime_type}\n    else:\n        headers = {}\n    endpoint_url = self.endpoint.endpoint\n    method = self.endpoint.method\n    response = requests.request(\n        method,\n        endpoint_url,\n        headers=headers,\n        data=payload,\n        params=params,\n        timeout=timeout,\n    )\n    return response.text\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryBundle.set_limit","title":"<code>set_limit(limit=None)</code>","text":"<p>set the limit of my query</p> <p>Parameters:</p> Name Type Description Default <code>limit(int)</code> <p>the limit to set - default: None</p> required Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def set_limit(self, limit: int = None):\n    \"\"\"\n    set the limit of my query\n\n    Args:\n        limit(int): the limit to set - default: None\n    \"\"\"\n    if limit:\n        sparql_query = self.query.query\n        # @TODO - this is too naive for cases where\n        # there are SPARQL elements hat have a \"limit\" in the name e.g. \"height_limit\"\n        # or if there is a LIMIT in a subquery\n        if \"limit\" in sparql_query or \"LIMIT\" in sparql_query:\n            sparql_query = re.sub(r\"(limit|LIMIT)\\s+(\\d+)\", f\"LIMIT {limit}\", sparql_query)\n        else:\n            sparql_query += f\"\\nLIMIT {limit}\"\n        self.query.query = sparql_query\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryDetails","title":"<code>QueryDetails</code>","text":"<p>Details for a named query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@lod_storable\nclass QueryDetails:\n    \"\"\"\n    Details for a named query\n    \"\"\"\n\n    query_id: str\n    params: str  # e.g. q - q1,q2,\n    default_params: str  # e.g. Q80 - Q58631663, Q125422124\n    default_param_types: str  # e.g. Q5 - Q191067,Q43229\n    param_count: int\n    lines: int\n    size: int\n\n    @classmethod\n    def from_sparql(cls, query_id: str, sparql: str) -&gt; \"QueryDetails\":\n        \"\"\"\n        Creates an instance of QueryDetails from a SPARQL query string.\n\n        This method parses the SPARQL query to determine the number of lines and the size of the query.\n        It also identifies and lists the parameters used within the SPARQL query.\n\n        Args:\n            query_id (str): The identifier of the query.\n            sparql (str): The SPARQL query string from which to generate the query details.\n\n        Returns:\n            QueryDetails: An instance containing details about the SPARQL query.\n        \"\"\"\n        # Calculate the number of lines and the size of the sparql string\n        lines = sparql.count(\"\\n\") + 1\n        size = len(sparql.encode(\"utf-8\"))\n\n        # Example to extract parameters - this may need to be replaced with actual parameter extraction logic\n        sparql_params = Params(\n            query=sparql\n        )  # Assuming Params is a class that can parse SPARQL queries to extract parameters\n        params = \",\".join(sparql_params.params) if sparql_params.params else None\n        param_count = len(sparql_params.params)\n        # @TODO get parameters\n        default_params = None\n        default_param_types = None\n        # Create and return the QueryDetails instance\n        return cls(\n            query_id=query_id,\n            params=params,\n            default_params=default_params,\n            default_param_types=default_param_types,\n            param_count=param_count,\n            lines=lines,\n            size=size,\n        )\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"QueryDetails\"]:\n        \"\"\"\n        get samples\n        \"\"\"\n        samples = {\n            \"snapquery-examples\": [\n                QueryDetails(\n                    query_id=\"scholia.test\",\n                    params=\"q\",\n                    default_params=\"Q80\",\n                    default_param_types=\"Q5\",\n                    param_count=1,\n                    lines=1,\n                    size=50,\n                )\n            ]\n        }\n        return samples\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryDetails.from_sparql","title":"<code>from_sparql(query_id, sparql)</code>  <code>classmethod</code>","text":"<p>Creates an instance of QueryDetails from a SPARQL query string.</p> <p>This method parses the SPARQL query to determine the number of lines and the size of the query. It also identifies and lists the parameters used within the SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query_id</code> <code>str</code> <p>The identifier of the query.</p> required <code>sparql</code> <code>str</code> <p>The SPARQL query string from which to generate the query details.</p> required <p>Returns:</p> Name Type Description <code>QueryDetails</code> <code>QueryDetails</code> <p>An instance containing details about the SPARQL query.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef from_sparql(cls, query_id: str, sparql: str) -&gt; \"QueryDetails\":\n    \"\"\"\n    Creates an instance of QueryDetails from a SPARQL query string.\n\n    This method parses the SPARQL query to determine the number of lines and the size of the query.\n    It also identifies and lists the parameters used within the SPARQL query.\n\n    Args:\n        query_id (str): The identifier of the query.\n        sparql (str): The SPARQL query string from which to generate the query details.\n\n    Returns:\n        QueryDetails: An instance containing details about the SPARQL query.\n    \"\"\"\n    # Calculate the number of lines and the size of the sparql string\n    lines = sparql.count(\"\\n\") + 1\n    size = len(sparql.encode(\"utf-8\"))\n\n    # Example to extract parameters - this may need to be replaced with actual parameter extraction logic\n    sparql_params = Params(\n        query=sparql\n    )  # Assuming Params is a class that can parse SPARQL queries to extract parameters\n    params = \",\".join(sparql_params.params) if sparql_params.params else None\n    param_count = len(sparql_params.params)\n    # @TODO get parameters\n    default_params = None\n    default_param_types = None\n    # Create and return the QueryDetails instance\n    return cls(\n        query_id=query_id,\n        params=params,\n        default_params=default_params,\n        default_param_types=default_param_types,\n        param_count=param_count,\n        lines=lines,\n        size=size,\n    )\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryDetails.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>get samples</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, \"QueryDetails\"]:\n    \"\"\"\n    get samples\n    \"\"\"\n    samples = {\n        \"snapquery-examples\": [\n            QueryDetails(\n                query_id=\"scholia.test\",\n                params=\"q\",\n                default_params=\"Q80\",\n                default_param_types=\"Q5\",\n                param_count=1,\n                lines=1,\n                size=50,\n            )\n        ]\n    }\n    return samples\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryName","title":"<code>QueryName</code>","text":"<p>A structured query name with a fully qualifying query id that is URL-friendly Attributes:     domain(str): the domain of the owner of this namespace     namespace (str): The namespace of the query, which helps in categorizing the query.     name (str): The unique name or identifier of the query within its namespace.     query_id(str): encoded id e.g. cats--examples@wikidata.org</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@lod_storable\nclass QueryName:\n    \"\"\"\n    A structured query name with a fully qualifying query id that is URL-friendly\n    Attributes:\n        domain(str): the domain of the owner of this namespace\n        namespace (str): The namespace of the query, which helps in categorizing the query.\n        name (str): The unique name or identifier of the query within its namespace.\n        query_id(str): encoded id e.g. cats--examples@wikidata.org\n    \"\"\"\n\n    # name\n    name: str\n    # namespace\n    namespace: str = \"examples\"\n    # domain\n    domain: str = \"wikidata.org\"\n    # query_id\n    query_id: str = field(init=False)\n\n    def __post_init__(self):\n        self.query_id = self.get_query_id(self.name, self.namespace, self.domain)\n\n    @classmethod\n    def get_query_id(cls, name: str, namespace: str, domain: str) -&gt; str:\n        \"\"\"\n        Generate a URL-friendly query_id\n        \"\"\"\n        # Convert None to empty string (or use any other default logic)\n        name, namespace, domain = (name or \"\"), (namespace or \"\"), (domain or \"\")\n\n        # Apply slugify with Unicode support and basic cleanup\n        encoded_name = slugify(name, allow_unicode=True)\n\n        # Create a combined query_id\n        query_id = f\"{encoded_name}--{namespace}@{domain}\"\n\n        return query_id\n\n    @classmethod\n    def from_query_id(\n        cls,\n        query_id: str,\n        namespace: str = \"examples\",  # default namespace\n        domain: str = \"wikidata.org\",  # default domain\n    ) -&gt; \"QueryName\":\n        \"\"\"\n        Parse a URL-friendly query_id string into a QueryName object.\n        Args:\n            query_id (str): The URL-friendly query_id string to parse.\n            namespace (str): Default namespace if not specified in query_id\n            domain (str): Default domain if not specified in query_id\n        Returns:\n            QueryName: A QueryName object containing name, namespace, and domain.\n        \"\"\"\n        parts = query_id.split(\"--\")\n        name = urllib.parse.unquote(parts[0])\n\n        if len(parts) &gt; 1:\n            ns_domain = parts[1].split(\"@\")\n            namespace = urllib.parse.unquote(ns_domain[0])\n            if len(ns_domain) &gt; 1:\n                domain = urllib.parse.unquote(ns_domain[1])\n        return cls(name=name, namespace=namespace, domain=domain)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the QueryName object to a dictionary\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"namespace\": self.namespace,\n            \"domain\": self.domain,\n            \"query_id\": self.query_id,\n        }\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryName.from_query_id","title":"<code>from_query_id(query_id, namespace='examples', domain='wikidata.org')</code>  <code>classmethod</code>","text":"<p>Parse a URL-friendly query_id string into a QueryName object. Args:     query_id (str): The URL-friendly query_id string to parse.     namespace (str): Default namespace if not specified in query_id     domain (str): Default domain if not specified in query_id Returns:     QueryName: A QueryName object containing name, namespace, and domain.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef from_query_id(\n    cls,\n    query_id: str,\n    namespace: str = \"examples\",  # default namespace\n    domain: str = \"wikidata.org\",  # default domain\n) -&gt; \"QueryName\":\n    \"\"\"\n    Parse a URL-friendly query_id string into a QueryName object.\n    Args:\n        query_id (str): The URL-friendly query_id string to parse.\n        namespace (str): Default namespace if not specified in query_id\n        domain (str): Default domain if not specified in query_id\n    Returns:\n        QueryName: A QueryName object containing name, namespace, and domain.\n    \"\"\"\n    parts = query_id.split(\"--\")\n    name = urllib.parse.unquote(parts[0])\n\n    if len(parts) &gt; 1:\n        ns_domain = parts[1].split(\"@\")\n        namespace = urllib.parse.unquote(ns_domain[0])\n        if len(ns_domain) &gt; 1:\n            domain = urllib.parse.unquote(ns_domain[1])\n    return cls(name=name, namespace=namespace, domain=domain)\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryName.get_query_id","title":"<code>get_query_id(name, namespace, domain)</code>  <code>classmethod</code>","text":"<p>Generate a URL-friendly query_id</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef get_query_id(cls, name: str, namespace: str, domain: str) -&gt; str:\n    \"\"\"\n    Generate a URL-friendly query_id\n    \"\"\"\n    # Convert None to empty string (or use any other default logic)\n    name, namespace, domain = (name or \"\"), (namespace or \"\"), (domain or \"\")\n\n    # Apply slugify with Unicode support and basic cleanup\n    encoded_name = slugify(name, allow_unicode=True)\n\n    # Create a combined query_id\n    query_id = f\"{encoded_name}--{namespace}@{domain}\"\n\n    return query_id\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryName.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the QueryName object to a dictionary</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the QueryName object to a dictionary\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"namespace\": self.namespace,\n        \"domain\": self.domain,\n        \"query_id\": self.query_id,\n    }\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryNameSet","title":"<code>QueryNameSet</code>","text":"<p>Manages a set of QueryNames filtered by domain and namespaces SQL like patterns</p> <p>Attributes:</p> <pre><code>nqm (NamedQueryManager): A manager to handle named queries and interactions with the database.\nlimit(int): the maximum number of names and top_queries\n</code></pre> Calculated on update <p>total (int): Total number of queries that match the current filter criteria. domains (set): A set of domains that match the current filter criteria. namespaces (set): A set of namespaces that match the current filter criteria. names (set): A set of names that match the current filter criteria. top_queries (list): List of top queries based on the specified limit.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>class QueryNameSet:\n    \"\"\"\n    Manages a set of QueryNames filtered by domain and namespaces SQL like patterns\n\n    Attributes:\n\n        nqm (NamedQueryManager): A manager to handle named queries and interactions with the database.\n        limit(int): the maximum number of names and top_queries\n\n    Calculated on update:\n        total (int): Total number of queries that match the current filter criteria.\n        domains (set): A set of domains that match the current filter criteria.\n        namespaces (set): A set of namespaces that match the current filter criteria.\n        names (set): A set of names that match the current filter criteria.\n        top_queries (list): List of top queries based on the specified limit.\n    \"\"\"\n\n    def __init__(self, nqm: \"NamedQueryManager\", limit: int = None):\n        self.nqm = nqm\n        self.limit = limit\n        self.total = 0\n        self.domains = set()\n        self.namespaces = set()\n        self.names = set()\n        self.update(\"\", \"\")\n\n    def __str__(self):\n        return (\n            f\"QueryNameSet(Total: {self.total}, Domains: {sorted(self.domains)}, \"\n            f\"Namespaces: {sorted(self.namespaces)}, Names: {sorted(self.names)}, \"\n            f\"Top Queries: [{', '.join(query.name for query in self.top_queries)}])\"\n        )\n\n    def update(self, domain: str, namespace: str, limit: int = None):\n        \"\"\"\n        update my attributes\n\n        Args:\n            domain (str): The domain part of the filter, supports SQL-like wildcards.\n            namespace (str): The namespace part of the filter, supports SQL-like wildcards.\n            limit (int, optional): Maximum number of queries to fetch. If None, no limit is applied.\n\n        \"\"\"\n        if limit is None:\n            limit = self.limit\n        query = self.nqm.meta_qm.queriesByName[\"domain_namespace_stats\"]\n        params = (f\"{domain}%\", f\"{namespace}%\")\n        results = self.nqm.sql_db.query(query.query, params)\n\n        self.total = 0  # Reset total for each update call\n        self.domains.clear()  # Clear previous domains\n        self.namespaces.clear()  # Clear previous namespaces\n        self.names.clear()  # Clear previous names\n\n        for record in results:\n            self.domains.add(record[\"domain\"])\n            self.namespaces.add(record[\"namespace\"])\n            self.total += record[\"query_count\"]\n        self.top_queries = self.nqm.get_all_queries(namespace=namespace, domain=domain, limit=limit)\n        for query in self.top_queries:\n            self.names.add(query.name)\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryNameSet.update","title":"<code>update(domain, namespace, limit=None)</code>","text":"<p>update my attributes</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain part of the filter, supports SQL-like wildcards.</p> required <code>namespace</code> <code>str</code> <p>The namespace part of the filter, supports SQL-like wildcards.</p> required <code>limit</code> <code>int</code> <p>Maximum number of queries to fetch. If None, no limit is applied.</p> <code>None</code> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def update(self, domain: str, namespace: str, limit: int = None):\n    \"\"\"\n    update my attributes\n\n    Args:\n        domain (str): The domain part of the filter, supports SQL-like wildcards.\n        namespace (str): The namespace part of the filter, supports SQL-like wildcards.\n        limit (int, optional): Maximum number of queries to fetch. If None, no limit is applied.\n\n    \"\"\"\n    if limit is None:\n        limit = self.limit\n    query = self.nqm.meta_qm.queriesByName[\"domain_namespace_stats\"]\n    params = (f\"{domain}%\", f\"{namespace}%\")\n    results = self.nqm.sql_db.query(query.query, params)\n\n    self.total = 0  # Reset total for each update call\n    self.domains.clear()  # Clear previous domains\n    self.namespaces.clear()  # Clear previous namespaces\n    self.names.clear()  # Clear previous names\n\n    for record in results:\n        self.domains.add(record[\"domain\"])\n        self.namespaces.add(record[\"namespace\"])\n        self.total += record[\"query_count\"]\n    self.top_queries = self.nqm.get_all_queries(namespace=namespace, domain=domain, limit=limit)\n    for query in self.top_queries:\n        self.names.add(query.name)\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryPrefixMerger","title":"<code>QueryPrefixMerger</code>","text":"<p>               Bases: <code>Enum</code></p> <p>SPARQL Query prefix merger</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>class QueryPrefixMerger(Enum):\n    \"\"\"\n    SPARQL Query prefix merger\n    \"\"\"\n\n    RAW = \"raw\"\n    SIMPLE_MERGER = \"simple merger\"\n    ANALYSIS_MERGER = \"analysis merger\"\n\n    @classmethod\n    def _missing_(cls, key):\n        return cls.default_merger()\n\n    @classmethod\n    def default_merger(cls) -&gt; \"QueryPrefixMerger\":\n        return cls.SIMPLE_MERGER\n\n    @classmethod\n    def get_by_name(cls, name: str) -&gt; \"QueryPrefixMerger\":\n        merger_map = {merger.name: merger.value for merger in QueryPrefixMerger}\n        merger_value = merger_map.get(name, None)\n        merger = QueryPrefixMerger(merger_value)\n        return merger\n\n    @classmethod\n    def merge_prefixes(\n        cls, named_query: NamedQuery, query: Query, endpoint: Endpoint, merger: \"QueryPrefixMerger\"\n    ) -&gt; str:\n        \"\"\"\n        Merge prefixes with the given merger\n        Args:\n            named_query:\n            query:\n            endpoint:\n            merger:\n\n        Returns:\n            merged query\n        \"\"\"\n        if merger == QueryPrefixMerger.SIMPLE_MERGER:\n            return cls.simple_prefix_merger(query.query, endpoint)\n        elif merger == QueryPrefixMerger.ANALYSIS_MERGER:\n            return cls.analysis_prefix_merger(query.query)\n        else:\n            return query.query\n\n    @classmethod\n    def simple_prefix_merger(cls, query_str: str, endpoint: Endpoint) -&gt; str:\n        \"\"\"\n        Simple prefix merger\n        Args:\n            query_str:\n            endpoint:\n\n        Returns:\n            merged query\n        \"\"\"\n        prefixes = endpoint.prefixes if hasattr(endpoint, \"prefixes\") else None\n        merged_query = query_str\n        if prefixes:\n            merged_query = f\"{prefixes}\\n{merged_query}\"\n        return merged_query\n\n    @classmethod\n    def analysis_prefix_merger(cls, query_str: str) -&gt; str:\n        \"\"\"\n        Analysis prefix merger\n        Args:\n            query_str\n\n        Returns:\n            merged query\n        \"\"\"\n        merged_query = SparqlAnalyzer.add_missing_prefixes(query_str)\n        return merged_query\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryPrefixMerger.analysis_prefix_merger","title":"<code>analysis_prefix_merger(query_str)</code>  <code>classmethod</code>","text":"<p>Analysis prefix merger Args:     query_str</p> <p>Returns:</p> Type Description <code>str</code> <p>merged query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef analysis_prefix_merger(cls, query_str: str) -&gt; str:\n    \"\"\"\n    Analysis prefix merger\n    Args:\n        query_str\n\n    Returns:\n        merged query\n    \"\"\"\n    merged_query = SparqlAnalyzer.add_missing_prefixes(query_str)\n    return merged_query\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryPrefixMerger.merge_prefixes","title":"<code>merge_prefixes(named_query, query, endpoint, merger)</code>  <code>classmethod</code>","text":"<p>Merge prefixes with the given merger Args:     named_query:     query:     endpoint:     merger:</p> <p>Returns:</p> Type Description <code>str</code> <p>merged query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef merge_prefixes(\n    cls, named_query: NamedQuery, query: Query, endpoint: Endpoint, merger: \"QueryPrefixMerger\"\n) -&gt; str:\n    \"\"\"\n    Merge prefixes with the given merger\n    Args:\n        named_query:\n        query:\n        endpoint:\n        merger:\n\n    Returns:\n        merged query\n    \"\"\"\n    if merger == QueryPrefixMerger.SIMPLE_MERGER:\n        return cls.simple_prefix_merger(query.query, endpoint)\n    elif merger == QueryPrefixMerger.ANALYSIS_MERGER:\n        return cls.analysis_prefix_merger(query.query)\n    else:\n        return query.query\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryPrefixMerger.simple_prefix_merger","title":"<code>simple_prefix_merger(query_str, endpoint)</code>  <code>classmethod</code>","text":"<p>Simple prefix merger Args:     query_str:     endpoint:</p> <p>Returns:</p> Type Description <code>str</code> <p>merged query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef simple_prefix_merger(cls, query_str: str, endpoint: Endpoint) -&gt; str:\n    \"\"\"\n    Simple prefix merger\n    Args:\n        query_str:\n        endpoint:\n\n    Returns:\n        merged query\n    \"\"\"\n    prefixes = endpoint.prefixes if hasattr(endpoint, \"prefixes\") else None\n    merged_query = query_str\n    if prefixes:\n        merged_query = f\"{prefixes}\\n{merged_query}\"\n    return merged_query\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats","title":"<code>QueryStats</code>","text":"<p>statistics about a query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@lod_storable\nclass QueryStats:\n    \"\"\"\n    statistics about a query\n    \"\"\"\n\n    stats_id: str = field(init=False)\n    query_id: str  # foreign key\n    endpoint_name: str  # foreign key\n\n    context: Optional[str] = None  # a context for the query stats\n    records: Optional[int] = None\n    time_stamp: datetime.datetime = field(init=False)\n    duration: Optional[float] = field(init=False, default=None)  # duration in seconds\n    error_msg: Optional[str] = None\n    error_category: Optional[str] = None\n\n    filtered_msg: Optional[str] = None\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization processing to construct a unique identifier for the query\n        and record the timestamp when the query stats object is created.\n        \"\"\"\n        self.stats_id = str(uuid.uuid4())\n        self.time_stamp = datetime.datetime.now()\n\n    def done(self):\n        \"\"\"\n        Set the duration by calculating the elapsed time since the `time_stamp`.\n        \"\"\"\n        self.duration = (datetime.datetime.now() - self.time_stamp).total_seconds()\n\n    def apply_error_filter(self, for_html: bool = False) -&gt; ErrorFilter:\n        \"\"\"\n        Applies an error filter to the error message and sets the filtered message.\n\n        Args:\n            for_html (bool): If True, formats the message for HTML output.\n\n        Returns:\n            ErrorFilter: the error filter that has been applied\n        \"\"\"\n        error_filter = ErrorFilter(self.error_msg)\n        self.filtered_msg = error_filter.get_message(for_html=for_html)\n        self.error_category = error_filter.category\n        return error_filter\n\n    def error(self, ex: Exception):\n        \"\"\"\n        Handle exception of query\n        \"\"\"\n        self.duration = None\n        self.error_msg = str(ex)\n        self.apply_error_filter()\n\n    @classmethod\n    def from_record(cls, record: Dict) -&gt; \"QueryStats\":\n        \"\"\"\n        Class method to instantiate NamedQuery\n        from a dictionary record.\n        \"\"\"\n        stat = cls(\n            query_id=record.get(\"query_id\", None),\n            endpoint_name=record.get(\"endpoint_name\", None),\n            records=record.get(\"records\", None),\n            error_msg=record.get(\"error_msg\", None),\n            error_category=record.get(\"error_category\", None),\n            filtered_msg=record.get(\"filtered_msg\", None),\n        )\n        stat.stats_id = record.get(\"stats_id\", stat.stats_id)\n        stat.time_stamp = record.get(\"time_stamp\", stat.time_stamp)\n        stat.duration = record.get(\"duration\", None)\n        return stat\n\n    def as_record(self) -&gt; Dict:\n        \"\"\"\n        convert my declared attributes to a dict\n        @TODO may be use asdict from dataclasses instead?\n        \"\"\"\n        record = {}\n        for _field in fields(self):\n            # Include field in the record dictionary if it has already been initialized (i.e., not None or has default)\n            if hasattr(self, _field.name):\n                record[_field.name] = getattr(self, _field.name)\n        return record\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"QueryStats\"]:\n        \"\"\"\n        get samples for QueryStats\n        \"\"\"\n        samples = {\n            \"snapquery-examples\": [\n                cls(\n                    query_id=\"horses--snapquery-examples@wikidata.org\",\n                    endpoint_name=\"wikidata\",\n                    context=\"samples\",\n                    records=0,\n                    error_msg=\"HTTP Error 504: Query has timed out.\",\n                    filtered_msg=\"Timeout: HTTP Error 504: Query has timed out.\",\n                    error_category=\"Timeout\",\n                ),\n                cls(\n                    query_id=\"cats--snapquery-examples@wikidata.org\",\n                    endpoint_name=\"wikidata\",\n                    context=\"samples\",\n                    records=223,\n                    error_msg=\"\",\n                    error_category=None,\n                    filtered_msg=\"\",\n                ),\n            ]\n        }\n        # Set the duration for each sample instance\n        for sample_list in samples.values():\n            for sample in sample_list:\n                sample.duration = 0.5\n        return samples\n\n    def is_successful(self) -&gt; bool:\n        \"\"\"\n        Returns True if the query was successful\n        \"\"\"\n        return self.duration and self.error_msg is None\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization processing to construct a unique identifier for the query and record the timestamp when the query stats object is created.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization processing to construct a unique identifier for the query\n    and record the timestamp when the query stats object is created.\n    \"\"\"\n    self.stats_id = str(uuid.uuid4())\n    self.time_stamp = datetime.datetime.now()\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.apply_error_filter","title":"<code>apply_error_filter(for_html=False)</code>","text":"<p>Applies an error filter to the error message and sets the filtered message.</p> <p>Parameters:</p> Name Type Description Default <code>for_html</code> <code>bool</code> <p>If True, formats the message for HTML output.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ErrorFilter</code> <code>ErrorFilter</code> <p>the error filter that has been applied</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def apply_error_filter(self, for_html: bool = False) -&gt; ErrorFilter:\n    \"\"\"\n    Applies an error filter to the error message and sets the filtered message.\n\n    Args:\n        for_html (bool): If True, formats the message for HTML output.\n\n    Returns:\n        ErrorFilter: the error filter that has been applied\n    \"\"\"\n    error_filter = ErrorFilter(self.error_msg)\n    self.filtered_msg = error_filter.get_message(for_html=for_html)\n    self.error_category = error_filter.category\n    return error_filter\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.as_record","title":"<code>as_record()</code>","text":"<p>convert my declared attributes to a dict @TODO may be use asdict from dataclasses instead?</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def as_record(self) -&gt; Dict:\n    \"\"\"\n    convert my declared attributes to a dict\n    @TODO may be use asdict from dataclasses instead?\n    \"\"\"\n    record = {}\n    for _field in fields(self):\n        # Include field in the record dictionary if it has already been initialized (i.e., not None or has default)\n        if hasattr(self, _field.name):\n            record[_field.name] = getattr(self, _field.name)\n    return record\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.done","title":"<code>done()</code>","text":"<p>Set the duration by calculating the elapsed time since the <code>time_stamp</code>.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def done(self):\n    \"\"\"\n    Set the duration by calculating the elapsed time since the `time_stamp`.\n    \"\"\"\n    self.duration = (datetime.datetime.now() - self.time_stamp).total_seconds()\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.error","title":"<code>error(ex)</code>","text":"<p>Handle exception of query</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def error(self, ex: Exception):\n    \"\"\"\n    Handle exception of query\n    \"\"\"\n    self.duration = None\n    self.error_msg = str(ex)\n    self.apply_error_filter()\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.from_record","title":"<code>from_record(record)</code>  <code>classmethod</code>","text":"<p>Class method to instantiate NamedQuery from a dictionary record.</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef from_record(cls, record: Dict) -&gt; \"QueryStats\":\n    \"\"\"\n    Class method to instantiate NamedQuery\n    from a dictionary record.\n    \"\"\"\n    stat = cls(\n        query_id=record.get(\"query_id\", None),\n        endpoint_name=record.get(\"endpoint_name\", None),\n        records=record.get(\"records\", None),\n        error_msg=record.get(\"error_msg\", None),\n        error_category=record.get(\"error_category\", None),\n        filtered_msg=record.get(\"filtered_msg\", None),\n    )\n    stat.stats_id = record.get(\"stats_id\", stat.stats_id)\n    stat.time_stamp = record.get(\"time_stamp\", stat.time_stamp)\n    stat.duration = record.get(\"duration\", None)\n    return stat\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>get samples for QueryStats</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, \"QueryStats\"]:\n    \"\"\"\n    get samples for QueryStats\n    \"\"\"\n    samples = {\n        \"snapquery-examples\": [\n            cls(\n                query_id=\"horses--snapquery-examples@wikidata.org\",\n                endpoint_name=\"wikidata\",\n                context=\"samples\",\n                records=0,\n                error_msg=\"HTTP Error 504: Query has timed out.\",\n                filtered_msg=\"Timeout: HTTP Error 504: Query has timed out.\",\n                error_category=\"Timeout\",\n            ),\n            cls(\n                query_id=\"cats--snapquery-examples@wikidata.org\",\n                endpoint_name=\"wikidata\",\n                context=\"samples\",\n                records=223,\n                error_msg=\"\",\n                error_category=None,\n                filtered_msg=\"\",\n            ),\n        ]\n    }\n    # Set the duration for each sample instance\n    for sample_list in samples.values():\n        for sample in sample_list:\n            sample.duration = 0.5\n    return samples\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStats.is_successful","title":"<code>is_successful()</code>","text":"<p>Returns True if the query was successful</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>def is_successful(self) -&gt; bool:\n    \"\"\"\n    Returns True if the query was successful\n    \"\"\"\n    return self.duration and self.error_msg is None\n</code></pre>"},{"location":"#snapquery.snapquery_core.QueryStatsList","title":"<code>QueryStatsList</code>","text":"<p>a list of query statistics</p> Source code in <code>snapquery/snapquery_core.py</code> <pre><code>@lod_storable\nclass QueryStatsList:\n    \"\"\"\n    a list of query statistics\n    \"\"\"\n\n    name: str  # the name of the list\n    stats: List[QueryStats] = field(default_factory=list)\n</code></pre>"},{"location":"#snapquery.snapquery_view","title":"<code>snapquery_view</code>","text":"<p>Created on 2024-05-03</p> <p>@author: wf</p>"},{"location":"#snapquery.snapquery_view.NamedQuerySearch","title":"<code>NamedQuerySearch</code>","text":"<p>               Bases: <code>BaseQueryView</code></p> <p>search for namedqueries</p> Source code in <code>snapquery/snapquery_view.py</code> <pre><code>class NamedQuerySearch(BaseQueryView):\n    \"\"\"\n    search for namedqueries\n    \"\"\"\n\n    def __init__(self, solution: InputWebSolution):\n        super().__init__(solution)\n</code></pre>"},{"location":"#snapquery.snapquery_view.NamedQueryView","title":"<code>NamedQueryView</code>","text":"<p>display a named Query</p> Source code in <code>snapquery/snapquery_view.py</code> <pre><code>class NamedQueryView:\n    \"\"\"\n    display a named Query\n    \"\"\"\n\n    def __init__(\n        self,\n        solution: InputWebSolution,\n        query_bundle: QueryBundle,\n        r_format_str: str = \"html\",\n    ):\n        self.solution = solution\n        self.endpoint_name = \"wikidata\"\n        self.nqm: NamedQueryManager = self.solution.nqm\n        self.query_bundle = query_bundle\n        self.r_format_str = r_format_str\n        self.load_task = None\n        self.limit = 200\n        self.timeout = 20.0\n        # preload ValueFormatter\n        ValueFormatter.getFormats()\n        self.setup_ui()\n\n    def setup_ui(self):\n        \"\"\"\n        setup my user interface\n        \"\"\"\n        nq = self.query_bundle.named_query\n        url = self.query_bundle.query.tryItUrl\n        text = nq.title\n        tooltip = \"try it!\"\n        link = Link.create(url, text, tooltip, target=\"_blank\")\n        with self.solution.container:\n            with ui.column():\n                with ui.row() as self.query_settings_row:\n                    self.query_settings_row.classes(\"w-full\")\n                    ui.number(label=\"limit\").bind_value(self, \"limit\")\n                    ui.number(label=\"time out\").bind_value(self, \"timeout\")\n                    endpoint_selector = ui.select(\n                        list(self.nqm.endpoints.keys()),\n                        value=self.solution.endpoint_name,\n                        label=\"endpoint\",\n                    )\n                    endpoint_selector.bind_value(\n                        self,\n                        \"endpoint_name\",\n                    )\n                    endpoint_selector.classes(\"w-64\")\n                with ui.row() as self.query_row:\n                    self.try_it_link = ui.html(link)\n                    ui.label(nq.description)\n                    self.params = Params(nq.sparql)\n                    if self.params.has_params:\n                        self.params_view = ParamsView(self, self.params)\n                        self.params_edit = self.params_view.get_dict_edit()\n                        pass\n                    ui.button(icon=\"play_arrow\", on_click=self.run_query)\n                    self.stats_html = ui.html()\n                with ui.row():\n                    with ui.expansion(\"Show Query\", icon=\"manage_search\").classes(\"w-full\"):\n                        query_syntax_highlight = QuerySyntaxHighlight(self.query_bundle.query)\n                        syntax_highlight_css = query_syntax_highlight.formatter.get_style_defs()\n                        annotated_query = SparqlQueryAnnotater(self.query_bundle.query)\n                        ui.add_css(syntax_highlight_css)\n                        # ui.html(query_syntax_highlight.highlight())\n                        ui.html(annotated_query.annotate())\n                if self.solution.webserver.authenticated():\n                    with ui.row().classes(\"w-full\"):\n                        with ui.expansion(\"Show Query Stats\", icon=\"query_stats\") as self.stats_container:\n                            self.stats_container.classes(\"w-full\")\n                            self.load_stats()\n                self.grid_row = ui.expansion(\"Query Results\", icon=\"table_rows\", value=True)\n                self.grid_row.classes(\"w-full\")\n                with self.grid_row:\n                    ui.label(\"Not yet executed \")\n                    ui.button(\"Run Query\", icon=\"play_arrow\", on_click=self.run_query)\n                pass\n\n    def load_stats(self):\n        \"\"\"\n        display query stats\n        \"\"\"\n        self.stats_container.clear()\n        with self.stats_container:\n            container = ui.row()\n        query_stats = self.nqm.get_query_stats(self.query_bundle.named_query.query_id)\n        errors = [stat for stat in query_stats if not stat.is_successful()]\n        successful = [stat for stat in query_stats if stat.is_successful()]\n        if successful:\n            exec_times_by_endpoint: dict[str, list[QueryStats]] = {}\n            for stat in successful:\n                if stat.endpoint_name not in exec_times_by_endpoint:\n                    exec_times_by_endpoint[stat.endpoint_name] = []\n                exec_times_by_endpoint[stat.endpoint_name].append(stat)\n            data = []\n            for endpoint_name, stats in exec_times_by_endpoint.items():\n                record = {\n                    \"type\": \"box\",\n                    \"name\": endpoint_name,\n                    \"x\": [stat.duration for stat in stats],\n                }\n                data.append(record)\n            fig = {\n                \"data\": data,\n                \"layout\": {\n                    \"margin\": {\"l\": 200, \"r\": 15, \"t\": 30, \"b\": 30},\n                    \"plot_bgcolor\": \"#E5ECF6\",\n                    \"xaxis\": {\"gridcolor\": \"white\", \"title\": \"Execution Time [s]\"},\n                    \"yaxis\": {\"gridcolor\": \"white\", \"title\": \"Endpoint\"},\n                    \"title\": \"Query Execution Times by Endpoint\",\n                },\n                \"config\": {\n                    \"staticPlot\": True,\n                },\n            }\n            with container:\n                ui.plotly(fig)\n        if errors:\n            error_records = [stat.as_record() for stat in errors]\n            for record in error_records:\n                if record[\"error_msg\"]:\n                    record[\"error_msg\"] = record[\"error_msg\"][:16] + \"...\"\n                else:\n                    record[\"error_msg\"] = \"&lt;unkown&gt;\"\n            error_df = pd.DataFrame.from_records(error_records)\n            error_df_grouped = error_df.groupby([\"endpoint_name\", \"error_msg\"], as_index=False).count()\n            error_fig = px.bar(\n                error_df_grouped,\n                x=\"endpoint_name\",\n                y=\"query_id\",\n                title=\"Query Execution Errors\",\n                labels={\"query_id\": \"count\", \"endpoint_name\": \"Endpoint\"},\n                color=\"error_msg\",\n            )\n            error_fig.update_layout(margin=dict(l=15, r=15, t=30, b=15))\n            with container:\n                ui.plotly(error_fig)\n        if not successful and not errors:\n            with container:\n                ui.label(\"No query statistics available\")\n        with container:\n            ui.button(\"Update statistics\", icon=\"update\", on_click=self.load_stats)\n\n    async def load_query_results(self):\n        \"\"\"\n        (re) load the query results\n        \"\"\"\n        if self.params.has_params:\n            self.query_bundle.query.query = self.params.apply_parameters()\n            self.params_view.close()\n        self.query_bundle.set_limit(int(self.limit))\n        endpoint = self.nqm.endpoints[self.endpoint_name]\n        self.query_bundle.update_endpoint(endpoint)\n        result = await run.io_bound(self.query_bundle.get_lod_with_stats)\n        if not result:\n            with self.solution.container:\n                ui.notify(\"query execution failure\")\n            return\n        lod, stats = result\n        self.nqm.store_stats([stats])\n        self.grid_row.clear()\n        if stats.error_msg:\n            with self.grid_row:\n                stats.apply_error_filter()\n                markup = f'&lt;span style=\"color: red;\"&gt;{stats.filtered_msg}&lt;/span&gt;'\n                ui.html(markup)\n        else:\n            with self.query_row:\n                record_count = len(lod) if lod is not None else 0\n                markup = f'&lt;span style=\"color: green;\"&gt;{record_count} records in {stats.duration:.2f} secs&lt;/span&gt;'\n                self.stats_html.content = markup\n        if not lod:\n            with self.query_row:\n                ui.notify(\"query failed\")\n            return\n        query = self.query_bundle.query\n        query.formats = [\"*:wikidata\"]\n        tablefmt = \"html\"\n        query.preFormatWithCallBacks(lod, tablefmt=tablefmt)\n        query.formatWithValueFormatters(lod, tablefmt=tablefmt)\n        for record in lod:\n            for key, value in record.items():\n                if isinstance(value, str):\n                    if value.startswith(\"http\"):\n                        record[key] = Link.create(value, value)\n        with self.grid_row:\n            self.lod_grid = ListOfDictsGrid()\n            self.lod_grid.load_lod(lod)\n        self.grid_row.update()\n\n    async def run_query(self, _args):\n        \"\"\"\n        run the current query\n        \"\"\"\n\n        def cancel_running():\n            if self.load_task:\n                self.load_task.cancel()\n\n        self.grid_row.clear()\n        with self.grid_row:\n            ui.spinner()\n        self.grid_row.update()\n        # cancel task still running\n        cancel_running()\n        # cancel task if it takes too long\n        ui.timer(self.timeout, lambda: cancel_running(), once=True)\n        # run task in background\n        self.load_task = background_tasks.create(self.load_query_results())\n</code></pre>"},{"location":"#snapquery.snapquery_view.NamedQueryView.load_query_results","title":"<code>load_query_results()</code>  <code>async</code>","text":"<p>(re) load the query results</p> Source code in <code>snapquery/snapquery_view.py</code> <pre><code>async def load_query_results(self):\n    \"\"\"\n    (re) load the query results\n    \"\"\"\n    if self.params.has_params:\n        self.query_bundle.query.query = self.params.apply_parameters()\n        self.params_view.close()\n    self.query_bundle.set_limit(int(self.limit))\n    endpoint = self.nqm.endpoints[self.endpoint_name]\n    self.query_bundle.update_endpoint(endpoint)\n    result = await run.io_bound(self.query_bundle.get_lod_with_stats)\n    if not result:\n        with self.solution.container:\n            ui.notify(\"query execution failure\")\n        return\n    lod, stats = result\n    self.nqm.store_stats([stats])\n    self.grid_row.clear()\n    if stats.error_msg:\n        with self.grid_row:\n            stats.apply_error_filter()\n            markup = f'&lt;span style=\"color: red;\"&gt;{stats.filtered_msg}&lt;/span&gt;'\n            ui.html(markup)\n    else:\n        with self.query_row:\n            record_count = len(lod) if lod is not None else 0\n            markup = f'&lt;span style=\"color: green;\"&gt;{record_count} records in {stats.duration:.2f} secs&lt;/span&gt;'\n            self.stats_html.content = markup\n    if not lod:\n        with self.query_row:\n            ui.notify(\"query failed\")\n        return\n    query = self.query_bundle.query\n    query.formats = [\"*:wikidata\"]\n    tablefmt = \"html\"\n    query.preFormatWithCallBacks(lod, tablefmt=tablefmt)\n    query.formatWithValueFormatters(lod, tablefmt=tablefmt)\n    for record in lod:\n        for key, value in record.items():\n            if isinstance(value, str):\n                if value.startswith(\"http\"):\n                    record[key] = Link.create(value, value)\n    with self.grid_row:\n        self.lod_grid = ListOfDictsGrid()\n        self.lod_grid.load_lod(lod)\n    self.grid_row.update()\n</code></pre>"},{"location":"#snapquery.snapquery_view.NamedQueryView.load_stats","title":"<code>load_stats()</code>","text":"<p>display query stats</p> Source code in <code>snapquery/snapquery_view.py</code> <pre><code>def load_stats(self):\n    \"\"\"\n    display query stats\n    \"\"\"\n    self.stats_container.clear()\n    with self.stats_container:\n        container = ui.row()\n    query_stats = self.nqm.get_query_stats(self.query_bundle.named_query.query_id)\n    errors = [stat for stat in query_stats if not stat.is_successful()]\n    successful = [stat for stat in query_stats if stat.is_successful()]\n    if successful:\n        exec_times_by_endpoint: dict[str, list[QueryStats]] = {}\n        for stat in successful:\n            if stat.endpoint_name not in exec_times_by_endpoint:\n                exec_times_by_endpoint[stat.endpoint_name] = []\n            exec_times_by_endpoint[stat.endpoint_name].append(stat)\n        data = []\n        for endpoint_name, stats in exec_times_by_endpoint.items():\n            record = {\n                \"type\": \"box\",\n                \"name\": endpoint_name,\n                \"x\": [stat.duration for stat in stats],\n            }\n            data.append(record)\n        fig = {\n            \"data\": data,\n            \"layout\": {\n                \"margin\": {\"l\": 200, \"r\": 15, \"t\": 30, \"b\": 30},\n                \"plot_bgcolor\": \"#E5ECF6\",\n                \"xaxis\": {\"gridcolor\": \"white\", \"title\": \"Execution Time [s]\"},\n                \"yaxis\": {\"gridcolor\": \"white\", \"title\": \"Endpoint\"},\n                \"title\": \"Query Execution Times by Endpoint\",\n            },\n            \"config\": {\n                \"staticPlot\": True,\n            },\n        }\n        with container:\n            ui.plotly(fig)\n    if errors:\n        error_records = [stat.as_record() for stat in errors]\n        for record in error_records:\n            if record[\"error_msg\"]:\n                record[\"error_msg\"] = record[\"error_msg\"][:16] + \"...\"\n            else:\n                record[\"error_msg\"] = \"&lt;unkown&gt;\"\n        error_df = pd.DataFrame.from_records(error_records)\n        error_df_grouped = error_df.groupby([\"endpoint_name\", \"error_msg\"], as_index=False).count()\n        error_fig = px.bar(\n            error_df_grouped,\n            x=\"endpoint_name\",\n            y=\"query_id\",\n            title=\"Query Execution Errors\",\n            labels={\"query_id\": \"count\", \"endpoint_name\": \"Endpoint\"},\n            color=\"error_msg\",\n        )\n        error_fig.update_layout(margin=dict(l=15, r=15, t=30, b=15))\n        with container:\n            ui.plotly(error_fig)\n    if not successful and not errors:\n        with container:\n            ui.label(\"No query statistics available\")\n    with container:\n        ui.button(\"Update statistics\", icon=\"update\", on_click=self.load_stats)\n</code></pre>"},{"location":"#snapquery.snapquery_view.NamedQueryView.run_query","title":"<code>run_query(_args)</code>  <code>async</code>","text":"<p>run the current query</p> Source code in <code>snapquery/snapquery_view.py</code> <pre><code>async def run_query(self, _args):\n    \"\"\"\n    run the current query\n    \"\"\"\n\n    def cancel_running():\n        if self.load_task:\n            self.load_task.cancel()\n\n    self.grid_row.clear()\n    with self.grid_row:\n        ui.spinner()\n    self.grid_row.update()\n    # cancel task still running\n    cancel_running()\n    # cancel task if it takes too long\n    ui.timer(self.timeout, lambda: cancel_running(), once=True)\n    # run task in background\n    self.load_task = background_tasks.create(self.load_query_results())\n</code></pre>"},{"location":"#snapquery.snapquery_view.NamedQueryView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>setup my user interface</p> Source code in <code>snapquery/snapquery_view.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    setup my user interface\n    \"\"\"\n    nq = self.query_bundle.named_query\n    url = self.query_bundle.query.tryItUrl\n    text = nq.title\n    tooltip = \"try it!\"\n    link = Link.create(url, text, tooltip, target=\"_blank\")\n    with self.solution.container:\n        with ui.column():\n            with ui.row() as self.query_settings_row:\n                self.query_settings_row.classes(\"w-full\")\n                ui.number(label=\"limit\").bind_value(self, \"limit\")\n                ui.number(label=\"time out\").bind_value(self, \"timeout\")\n                endpoint_selector = ui.select(\n                    list(self.nqm.endpoints.keys()),\n                    value=self.solution.endpoint_name,\n                    label=\"endpoint\",\n                )\n                endpoint_selector.bind_value(\n                    self,\n                    \"endpoint_name\",\n                )\n                endpoint_selector.classes(\"w-64\")\n            with ui.row() as self.query_row:\n                self.try_it_link = ui.html(link)\n                ui.label(nq.description)\n                self.params = Params(nq.sparql)\n                if self.params.has_params:\n                    self.params_view = ParamsView(self, self.params)\n                    self.params_edit = self.params_view.get_dict_edit()\n                    pass\n                ui.button(icon=\"play_arrow\", on_click=self.run_query)\n                self.stats_html = ui.html()\n            with ui.row():\n                with ui.expansion(\"Show Query\", icon=\"manage_search\").classes(\"w-full\"):\n                    query_syntax_highlight = QuerySyntaxHighlight(self.query_bundle.query)\n                    syntax_highlight_css = query_syntax_highlight.formatter.get_style_defs()\n                    annotated_query = SparqlQueryAnnotater(self.query_bundle.query)\n                    ui.add_css(syntax_highlight_css)\n                    # ui.html(query_syntax_highlight.highlight())\n                    ui.html(annotated_query.annotate())\n            if self.solution.webserver.authenticated():\n                with ui.row().classes(\"w-full\"):\n                    with ui.expansion(\"Show Query Stats\", icon=\"query_stats\") as self.stats_container:\n                        self.stats_container.classes(\"w-full\")\n                        self.load_stats()\n            self.grid_row = ui.expansion(\"Query Results\", icon=\"table_rows\", value=True)\n            self.grid_row.classes(\"w-full\")\n            with self.grid_row:\n                ui.label(\"Not yet executed \")\n                ui.button(\"Run Query\", icon=\"play_arrow\", on_click=self.run_query)\n            pass\n</code></pre>"},{"location":"#snapquery.snapquery_webserver","title":"<code>snapquery_webserver</code>","text":"<p>Created on 2024-05-03 @author: wf</p>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution","title":"<code>SnapQuerySolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the Snap Query solution</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>class SnapQuerySolution(InputWebSolution):\n    \"\"\"\n    the Snap Query solution\n    \"\"\"\n\n    def __init__(self, webserver: SnapQueryWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (SnapQueryWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.webserver: SnapQueryWebServer\n        self.nqm = self.webserver.nqm\n        self.endpoint_name = self.get_user_endpoint()\n\n    def configure_settings(self):\n        \"\"\"\n        add additional settings\n        \"\"\"\n        self.add_select(\"default Endpoint\", list(self.nqm.endpoints.keys()), value=self.endpoint_name,).bind_value(\n            app.storage.user,\n            \"endpoint_name\",\n        )\n        self.add_select(\n            \"prefix merger\",\n            {merger.name: merger.value for merger in QueryPrefixMerger},\n            value=self.get_user_prefix_merger().name,\n        ).bind_value(\n            app.storage.user,\n            \"prefix_merger\",\n        )\n\n    def setup_menu(self, detailed: bool = True):\n        \"\"\"\n        setup the menu\n        \"\"\"\n        ui.button(icon=\"menu\", on_click=lambda: self.header.toggle())\n        self.webserver: SnapQueryWebServer\n        super().setup_menu(detailed=detailed)\n        with self.header:\n            self.header.value = False\n            self.link_button(\"Nominate a Query\", \"/nominate\", \"post_add\", new_tab=False)\n            self.link_button(\n                \"Queries by Namespace\",\n                \"/queries_by_namespace\",\n                \"view_list\",\n                new_tab=False,\n            )\n            if self.webserver.authenticated():\n                self.link_button(\"logout\", \"/logout\", \"logout\", new_tab=False)\n                if self.webserver.login.authenticated():\n                    self.link_button(\"admin\", \"/admin\", \"supervisor_account\", new_tab=False)\n                self.link_button(\"stats\", \"/stats\", icon_name=\"query_stats\", new_tab=False)\n            else:\n                self.link_button(\"login\", \"/login\", \"login\", new_tab=False)\n                if self.webserver.orcid_auth.available():\n                    redirect_url = self.webserver.orcid_auth.authenticate_url()\n                    self.link_button(\"login with orcid\", redirect_url, \"login\", new_tab=False)\n            if self.webserver.orcid_auth.authenticated():\n                orcid_token = self.webserver.orcid_auth.get_cached_user_access_token()\n                ui.markdown(f\"*logged in as* **{orcid_token.name} ({orcid_token.orcid})**\").props(\n                    \"flat color=white icon=folder\"\n                ).classes(\"ml-auto\")\n\n    async def nominate_ui(self):\n        \"\"\"\n        nominate a new query\n        \"\"\"\n\n        def show():\n            \"\"\"\n            show the nominate ui\n            \"\"\"\n\n            def selection_callback(person: Person):\n                self.container.clear()\n                with self.container:\n                    with ui.row().classes(\"w-full\"):\n                        with ui.column():\n                            ui.label(text=\"Nominate your Query\").classes(\"text-xl\")\n                            ui.link(\n                                text=\"see the documentation for detailed information on the nomination procedure\",\n                                new_tab=True,\n                                target=\"https://wiki.bitplan.com/index.php/Snapquery#nominate\",\n                            )\n                        PersonView(person).classes(\"ml-auto bg-slate-100 rounded-md\")\n                with ui.row().classes(\"w-full\"):\n                    self.query_import_view = QueryImportView(self, allow_importing_from_url=False, person=person)\n\n            with ui.column():\n                ui.label(text=\"Nominate your Query\").classes(\"text-xl\")\n                ui.link(\n                    text=\"see the documentation for detailed information on the nomination procedure\",\n                    new_tab=True,\n                    target=\"https://wiki.bitplan.com/index.php/Snapquery#nominate\",\n                )\n                ui.label(\"Please identify yourself by entering or looking up a valid PID(Wikidata ID, ORCID, dblp).\")\n                self.person_selector = PersonSelector(solution=self, selection_callback=selection_callback)\n\n        await self.setup_content_div(show)\n\n    async def admin_ui(self):\n        \"\"\"\n        admin ui\n        \"\"\"\n\n        def show():\n            \"\"\" \"\"\"\n            self.query_import_view = QueryImportView(self)\n\n        await self.setup_content_div(show)\n\n    async def login_ui(self):\n        \"\"\"\n        login ui\n        \"\"\"\n        await self.webserver.login.login(self)\n\n    async def stats_ui(self):\n        \"\"\"\n        stats ui\n        \"\"\"\n\n        def show():\n            \"\"\" \"\"\"\n            QueryStatsView(self)\n\n        await self.setup_content_div(show)\n\n    def setup_ui(self):\n        \"\"\"\n        setup my user interface\n        \"\"\"\n        self.search = NamedQuerySearch(self)\n\n    async def home(\n        self,\n    ):\n        \"\"\"Generates the home page\"\"\"\n        await self.setup_content_div(self.setup_ui)\n\n    async def queries_by_namespace(self):\n        def show():\n            _nsv = NamespaceStatsView(self)\n\n        await self.setup_content_div(show)\n\n    async def query_page(\n        self,\n        domain: str,\n        namespace: str,\n        name: str,\n        endpoint_name: str = \"wikidata\",\n        limit: int = None,\n        r_format_str: str = \"html\",\n    ):\n        def show():\n            query_name = QueryName(domain=domain, namespace=namespace, name=name)\n            qb = self.nqm.get_query(\n                query_name=query_name,\n                endpoint_name=endpoint_name,\n                limit=limit,\n                prefix_merger=self.get_user_prefix_merger(),\n            )\n            self.named_query_view = NamedQueryView(self, query_bundle=qb, r_format_str=r_format_str)\n\n        await self.setup_content_div(show)\n\n    @staticmethod\n    def get_user_endpoint() -&gt; str:\n        \"\"\"\n        Get the endpoint selected by the user. If no endpoint is selected return the default endpoint wikidata\n        \"\"\"\n        endpoint = app.storage.user.get(\"endpoint_name\", \"wikidata\")\n        return endpoint\n\n    @staticmethod\n    def get_user_prefix_merger() -&gt; QueryPrefixMerger:\n        \"\"\"\n        Get the prefix merger selected by the user. If no merger is selected the default merger Simple merger is used\n        \"\"\"\n        merger_name = app.storage.user.get(\"prefix_merger\", None)\n        merger = QueryPrefixMerger.get_by_name(merger_name)\n        if merger_name is None:\n            app.storage.user[\"prefix_merger\"] = merger.name\n        return merger\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (SnapQueryWebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def __init__(self, webserver: SnapQueryWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (SnapQueryWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n    self.webserver: SnapQueryWebServer\n    self.nqm = self.webserver.nqm\n    self.endpoint_name = self.get_user_endpoint()\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.admin_ui","title":"<code>admin_ui()</code>  <code>async</code>","text":"<p>admin ui</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>async def admin_ui(self):\n    \"\"\"\n    admin ui\n    \"\"\"\n\n    def show():\n        \"\"\" \"\"\"\n        self.query_import_view = QueryImportView(self)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.configure_settings","title":"<code>configure_settings()</code>","text":"<p>add additional settings</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def configure_settings(self):\n    \"\"\"\n    add additional settings\n    \"\"\"\n    self.add_select(\"default Endpoint\", list(self.nqm.endpoints.keys()), value=self.endpoint_name,).bind_value(\n        app.storage.user,\n        \"endpoint_name\",\n    )\n    self.add_select(\n        \"prefix merger\",\n        {merger.name: merger.value for merger in QueryPrefixMerger},\n        value=self.get_user_prefix_merger().name,\n    ).bind_value(\n        app.storage.user,\n        \"prefix_merger\",\n    )\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.get_user_endpoint","title":"<code>get_user_endpoint()</code>  <code>staticmethod</code>","text":"<p>Get the endpoint selected by the user. If no endpoint is selected return the default endpoint wikidata</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>@staticmethod\ndef get_user_endpoint() -&gt; str:\n    \"\"\"\n    Get the endpoint selected by the user. If no endpoint is selected return the default endpoint wikidata\n    \"\"\"\n    endpoint = app.storage.user.get(\"endpoint_name\", \"wikidata\")\n    return endpoint\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.get_user_prefix_merger","title":"<code>get_user_prefix_merger()</code>  <code>staticmethod</code>","text":"<p>Get the prefix merger selected by the user. If no merger is selected the default merger Simple merger is used</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>@staticmethod\ndef get_user_prefix_merger() -&gt; QueryPrefixMerger:\n    \"\"\"\n    Get the prefix merger selected by the user. If no merger is selected the default merger Simple merger is used\n    \"\"\"\n    merger_name = app.storage.user.get(\"prefix_merger\", None)\n    merger = QueryPrefixMerger.get_by_name(merger_name)\n    if merger_name is None:\n        app.storage.user[\"prefix_merger\"] = merger.name\n    return merger\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>Generates the home page</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>async def home(\n    self,\n):\n    \"\"\"Generates the home page\"\"\"\n    await self.setup_content_div(self.setup_ui)\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.login_ui","title":"<code>login_ui()</code>  <code>async</code>","text":"<p>login ui</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>async def login_ui(self):\n    \"\"\"\n    login ui\n    \"\"\"\n    await self.webserver.login.login(self)\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.nominate_ui","title":"<code>nominate_ui()</code>  <code>async</code>","text":"<p>nominate a new query</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>async def nominate_ui(self):\n    \"\"\"\n    nominate a new query\n    \"\"\"\n\n    def show():\n        \"\"\"\n        show the nominate ui\n        \"\"\"\n\n        def selection_callback(person: Person):\n            self.container.clear()\n            with self.container:\n                with ui.row().classes(\"w-full\"):\n                    with ui.column():\n                        ui.label(text=\"Nominate your Query\").classes(\"text-xl\")\n                        ui.link(\n                            text=\"see the documentation for detailed information on the nomination procedure\",\n                            new_tab=True,\n                            target=\"https://wiki.bitplan.com/index.php/Snapquery#nominate\",\n                        )\n                    PersonView(person).classes(\"ml-auto bg-slate-100 rounded-md\")\n            with ui.row().classes(\"w-full\"):\n                self.query_import_view = QueryImportView(self, allow_importing_from_url=False, person=person)\n\n        with ui.column():\n            ui.label(text=\"Nominate your Query\").classes(\"text-xl\")\n            ui.link(\n                text=\"see the documentation for detailed information on the nomination procedure\",\n                new_tab=True,\n                target=\"https://wiki.bitplan.com/index.php/Snapquery#nominate\",\n            )\n            ui.label(\"Please identify yourself by entering or looking up a valid PID(Wikidata ID, ORCID, dblp).\")\n            self.person_selector = PersonSelector(solution=self, selection_callback=selection_callback)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.setup_menu","title":"<code>setup_menu(detailed=True)</code>","text":"<p>setup the menu</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def setup_menu(self, detailed: bool = True):\n    \"\"\"\n    setup the menu\n    \"\"\"\n    ui.button(icon=\"menu\", on_click=lambda: self.header.toggle())\n    self.webserver: SnapQueryWebServer\n    super().setup_menu(detailed=detailed)\n    with self.header:\n        self.header.value = False\n        self.link_button(\"Nominate a Query\", \"/nominate\", \"post_add\", new_tab=False)\n        self.link_button(\n            \"Queries by Namespace\",\n            \"/queries_by_namespace\",\n            \"view_list\",\n            new_tab=False,\n        )\n        if self.webserver.authenticated():\n            self.link_button(\"logout\", \"/logout\", \"logout\", new_tab=False)\n            if self.webserver.login.authenticated():\n                self.link_button(\"admin\", \"/admin\", \"supervisor_account\", new_tab=False)\n            self.link_button(\"stats\", \"/stats\", icon_name=\"query_stats\", new_tab=False)\n        else:\n            self.link_button(\"login\", \"/login\", \"login\", new_tab=False)\n            if self.webserver.orcid_auth.available():\n                redirect_url = self.webserver.orcid_auth.authenticate_url()\n                self.link_button(\"login with orcid\", redirect_url, \"login\", new_tab=False)\n        if self.webserver.orcid_auth.authenticated():\n            orcid_token = self.webserver.orcid_auth.get_cached_user_access_token()\n            ui.markdown(f\"*logged in as* **{orcid_token.name} ({orcid_token.orcid})**\").props(\n                \"flat color=white icon=folder\"\n            ).classes(\"ml-auto\")\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.setup_ui","title":"<code>setup_ui()</code>","text":"<p>setup my user interface</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    setup my user interface\n    \"\"\"\n    self.search = NamedQuerySearch(self)\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQuerySolution.stats_ui","title":"<code>stats_ui()</code>  <code>async</code>","text":"<p>stats ui</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>async def stats_ui(self):\n    \"\"\"\n    stats ui\n    \"\"\"\n\n    def show():\n        \"\"\" \"\"\"\n        QueryStatsView(self)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQueryWebServer","title":"<code>SnapQueryWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>server to supply named Queries</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>class SnapQueryWebServer(InputWebserver):\n    \"\"\"\n    server to supply named Queries\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        \"\"\"\n        get the configuration for this Webserver\n        \"\"\"\n        copy_right = \"\"\n        config = WebserverConfig(\n            short_name=\"snapquery\",\n            copy_right=copy_right,\n            version=Version(),\n            default_port=9862,\n            timeout=6.0,\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = SnapQuerySolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(self, config=SnapQueryWebServer.get_config())\n        users = Users(\"~/.solutions/snapquery\")\n        self.login = Login(self, users)\n        self.orcid_auth = OrcidAuth(Path(self.config.base_path))\n        self.nqm = NamedQueryManager.from_samples()\n\n        @ui.page(\"/admin\")\n        async def admin(client: Client):\n            if not self.login.authenticated():\n                return RedirectResponse(\"/login\")\n            return await self.page(client, SnapQuerySolution.admin_ui)\n\n        @ui.page(\"/nominate\")\n        async def nominate(client: Client):\n            return await self.page(client, SnapQuerySolution.nominate_ui)\n\n        @ui.page(\"/stats\")\n        async def stats(client: Client):\n            if not self.authenticated():\n                return RedirectResponse(\"/login\")\n            return await self.page(client, SnapQuerySolution.stats_ui)\n\n        @ui.page(\"/login\")\n        async def login(client: Client):\n            return await self.page(client, SnapQuerySolution.login_ui)\n\n        @app.get(\"/orcid_callback\")\n        async def orcid_authenticate_callback(code: str):\n            try:\n                self.orcid_auth.login(code)\n            except Exception as e:\n                return HTTPException(status_code=401, detail=str(e))\n            return RedirectResponse(\"/\")\n\n        @ui.page(\"/logout\")\n        async def logout(client: Client) -&gt; RedirectResponse:\n            if self.login.authenticated():\n                await self.login.logout()\n            if self.orcid_auth.authenticated():\n                self.orcid_auth.logout()\n            return RedirectResponse(\"/\")\n\n        @ui.page(\"/queries_by_namespace\")\n        async def queries_by_namespace(client: Client):\n            return await self.page(client, SnapQuerySolution.queries_by_namespace)\n\n        @ui.page(\"/query/{domain}/{namespace}/{name}\")\n        async def query_page(\n            client: Client,\n            domain: str,\n            namespace: str,\n            name: str,\n            endpoint_name: str = None,\n            limit: int = None,\n            format: str = \"html\",\n        ):\n            \"\"\"\n            show the query page for the given namespace and name\n            \"\"\"\n            if endpoint_name is None:\n                endpoint_name = SnapQuerySolution.get_user_endpoint()\n            return await self.page(\n                client,\n                SnapQuerySolution.query_page,\n                domain=domain,\n                namespace=namespace,\n                name=name,\n                endpoint_name=endpoint_name,\n                limit=limit,\n                r_format_str=format,\n            )\n\n        @app.get(\"/api/endpoints\")\n        def get_endpoints():\n            \"\"\"\n            list all endpoints\n            \"\"\"\n            endpoints = self.nqm.endpoints\n            return endpoints\n\n        @app.get(\"/api/meta_query/{name}\")\n        def meta_query(name: str, limit: int = None):\n            \"\"\"\n            run the meta query with the given name\n            \"\"\"\n            name, r_format = self.get_r_format(name, \"json\")\n            if name not in self.nqm.meta_qm.queriesByName:\n                raise HTTPException(status_code=404, detail=f\"meta query {name} not known\")\n            query = self.nqm.meta_qm.queriesByName[name]\n            qb = QueryBundle(named_query=None, query=query)\n            qlod = self.nqm.sql_db.query(query.query)\n            if limit:\n                qlod = qlod[:limit]\n            content = qb.format_result(qlod, r_format)\n            # content=content.replace(\"\\n\", \"&lt;br&gt;\\n\")\n            if r_format == Format.html:\n                return HTMLResponse(content)\n            return PlainTextResponse(content)\n\n        @app.get(\"/api/sparql/{domain}/{namespace}/{name}\")\n        def sparql(\n            domain: str,\n            namespace: str,\n            name: str,\n            endpoint_name: str = \"wikidata\",\n            limit: int = None,\n        ) -&gt; PlainTextResponse:\n            \"\"\"\n            Gets a SPARQL query by name within a specified namespace\n\n            Args:\n                domain (str): The domain identifying the domain of the query.\n                namespace (str): The namespace identifying the group or category of the query.\n                name (str): The specific name of the query to be executed.\n                endpoint_name(str): the name of the endpoint to use\n                limit(int): a limit to set, default=None\n            Returns:\n                HTMLResponse: The plain text SPARQL code\n\n            Raises:\n                HTTPException: If the query cannot be found or fails to execute.\n            \"\"\"\n            query_name = QueryName(domain=domain, namespace=namespace, name=name)\n            qb = self.nqm.get_query(query_name=query_name, endpoint_name=endpoint_name, limit=limit)\n            sparql_query = qb.query.query\n            return PlainTextResponse(sparql_query)\n\n        @app.get(\"/api/query/{domain}/{namespace}/{name}\")\n        def query(\n            domain: str,\n            namespace: str,\n            name: str,\n            endpoint_name: str = \"wikidata\",\n            limit: int = None,\n        ) -&gt; HTMLResponse:\n            \"\"\"\n            Executes a SPARQL query by name within a specified namespace, formats the results, and returns them as an HTML response.\n\n            Args:\n                domain (str): The domain identifying the domain of the query.\n                namespace (str): The namespace identifying the group or category of the query.\n                name (str): The specific name of the query to be executed.\n                endpoint_name(str): the name of the endpoint to use\n                limit(int): a limit to set, default=None\n\n            Returns:\n                HTMLResponse: The HTML formatted response containing the results of the query execution.\n\n            Raises:\n                HTTPException: If the query cannot be found or fails to execute.\n            \"\"\"\n            content = self.query(\n                name=name,\n                namespace=namespace,\n                domain=domain,\n                endpoint_name=endpoint_name,\n                limit=limit,\n            )\n            if not content:\n                raise HTTPException(status_code=500, detail=\"Could not create result\")\n\n            # Return the content as an HTML response\n            return HTMLResponse(content)\n\n    def get_r_format(self, name: str, default_format_str: str = \"html\") -&gt; Format:\n        \"\"\"\n        get the result format from the given query name following the\n        dot convention that &lt;name&gt;.&lt;r_format_str&gt; specifies the result format\n        e.g. cats.json will ask for the json result format\n\n        Args:\n            name(str): the name of the query/meta query\n            default_format_str(str): the name of the default format to use\n\n        Returns:\n            Format: the result format\n        \"\"\"\n        if \".\" in name:\n            r_format_str = name.split(\".\")[-1]\n            name = name[: name.rfind(\".\")]\n        else:\n            r_format_str = default_format_str\n        r_format = Format[r_format_str]\n        return name, r_format\n\n    def query(\n        self,\n        name: str,\n        namespace: str,\n        domain: str,\n        endpoint_name: str = \"wikidata\",\n        limit: int = None,\n    ) -&gt; str:\n        \"\"\"\n        Queries an external API to retrieve data based on a given namespace and name.\n\n        Args:\n            name (str): The name identifier of the data to be queried.\n            namespace (str): The namespace to which the query belongs. It helps in categorizing the data.\n            domain (str): The domain identifying the domain of the query.\n            endpoint_name (str): The name of the endpoint to be used for the query. Defaults to 'wikidata'.\n            limit(int): the limit for the query default: None\n\n            Returns:\n                str: the content retrieved\n        \"\"\"\n        try:\n            # content negotiation\n            name, r_format = self.get_r_format(name)\n            query_name = QueryName(domain=domain, namespace=namespace, name=name)\n            qb = self.nqm.get_query(query_name=query_name, endpoint_name=endpoint_name, limit=limit)\n            (qlod, stats) = qb.get_lod_with_stats()\n            self.nqm.store_stats([stats])\n            content = qb.format_result(qlod, r_format)\n            return content\n        except Exception as e:\n            # Handling specific exceptions can be more detailed based on what nqm.get_sparql and nqm.query can raise\n            raise HTTPException(status_code=404, detail=str(e))\n\n    def authenticated(self) -&gt; bool:\n        \"\"\"\n        Check if the user is authenticated.\n        Returns:\n            True if the user is authenticated, False otherwise.\n        \"\"\"\n        return self.login.authenticated() or self.orcid_auth.authenticated()\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQueryWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(self, config=SnapQueryWebServer.get_config())\n    users = Users(\"~/.solutions/snapquery\")\n    self.login = Login(self, users)\n    self.orcid_auth = OrcidAuth(Path(self.config.base_path))\n    self.nqm = NamedQueryManager.from_samples()\n\n    @ui.page(\"/admin\")\n    async def admin(client: Client):\n        if not self.login.authenticated():\n            return RedirectResponse(\"/login\")\n        return await self.page(client, SnapQuerySolution.admin_ui)\n\n    @ui.page(\"/nominate\")\n    async def nominate(client: Client):\n        return await self.page(client, SnapQuerySolution.nominate_ui)\n\n    @ui.page(\"/stats\")\n    async def stats(client: Client):\n        if not self.authenticated():\n            return RedirectResponse(\"/login\")\n        return await self.page(client, SnapQuerySolution.stats_ui)\n\n    @ui.page(\"/login\")\n    async def login(client: Client):\n        return await self.page(client, SnapQuerySolution.login_ui)\n\n    @app.get(\"/orcid_callback\")\n    async def orcid_authenticate_callback(code: str):\n        try:\n            self.orcid_auth.login(code)\n        except Exception as e:\n            return HTTPException(status_code=401, detail=str(e))\n        return RedirectResponse(\"/\")\n\n    @ui.page(\"/logout\")\n    async def logout(client: Client) -&gt; RedirectResponse:\n        if self.login.authenticated():\n            await self.login.logout()\n        if self.orcid_auth.authenticated():\n            self.orcid_auth.logout()\n        return RedirectResponse(\"/\")\n\n    @ui.page(\"/queries_by_namespace\")\n    async def queries_by_namespace(client: Client):\n        return await self.page(client, SnapQuerySolution.queries_by_namespace)\n\n    @ui.page(\"/query/{domain}/{namespace}/{name}\")\n    async def query_page(\n        client: Client,\n        domain: str,\n        namespace: str,\n        name: str,\n        endpoint_name: str = None,\n        limit: int = None,\n        format: str = \"html\",\n    ):\n        \"\"\"\n        show the query page for the given namespace and name\n        \"\"\"\n        if endpoint_name is None:\n            endpoint_name = SnapQuerySolution.get_user_endpoint()\n        return await self.page(\n            client,\n            SnapQuerySolution.query_page,\n            domain=domain,\n            namespace=namespace,\n            name=name,\n            endpoint_name=endpoint_name,\n            limit=limit,\n            r_format_str=format,\n        )\n\n    @app.get(\"/api/endpoints\")\n    def get_endpoints():\n        \"\"\"\n        list all endpoints\n        \"\"\"\n        endpoints = self.nqm.endpoints\n        return endpoints\n\n    @app.get(\"/api/meta_query/{name}\")\n    def meta_query(name: str, limit: int = None):\n        \"\"\"\n        run the meta query with the given name\n        \"\"\"\n        name, r_format = self.get_r_format(name, \"json\")\n        if name not in self.nqm.meta_qm.queriesByName:\n            raise HTTPException(status_code=404, detail=f\"meta query {name} not known\")\n        query = self.nqm.meta_qm.queriesByName[name]\n        qb = QueryBundle(named_query=None, query=query)\n        qlod = self.nqm.sql_db.query(query.query)\n        if limit:\n            qlod = qlod[:limit]\n        content = qb.format_result(qlod, r_format)\n        # content=content.replace(\"\\n\", \"&lt;br&gt;\\n\")\n        if r_format == Format.html:\n            return HTMLResponse(content)\n        return PlainTextResponse(content)\n\n    @app.get(\"/api/sparql/{domain}/{namespace}/{name}\")\n    def sparql(\n        domain: str,\n        namespace: str,\n        name: str,\n        endpoint_name: str = \"wikidata\",\n        limit: int = None,\n    ) -&gt; PlainTextResponse:\n        \"\"\"\n        Gets a SPARQL query by name within a specified namespace\n\n        Args:\n            domain (str): The domain identifying the domain of the query.\n            namespace (str): The namespace identifying the group or category of the query.\n            name (str): The specific name of the query to be executed.\n            endpoint_name(str): the name of the endpoint to use\n            limit(int): a limit to set, default=None\n        Returns:\n            HTMLResponse: The plain text SPARQL code\n\n        Raises:\n            HTTPException: If the query cannot be found or fails to execute.\n        \"\"\"\n        query_name = QueryName(domain=domain, namespace=namespace, name=name)\n        qb = self.nqm.get_query(query_name=query_name, endpoint_name=endpoint_name, limit=limit)\n        sparql_query = qb.query.query\n        return PlainTextResponse(sparql_query)\n\n    @app.get(\"/api/query/{domain}/{namespace}/{name}\")\n    def query(\n        domain: str,\n        namespace: str,\n        name: str,\n        endpoint_name: str = \"wikidata\",\n        limit: int = None,\n    ) -&gt; HTMLResponse:\n        \"\"\"\n        Executes a SPARQL query by name within a specified namespace, formats the results, and returns them as an HTML response.\n\n        Args:\n            domain (str): The domain identifying the domain of the query.\n            namespace (str): The namespace identifying the group or category of the query.\n            name (str): The specific name of the query to be executed.\n            endpoint_name(str): the name of the endpoint to use\n            limit(int): a limit to set, default=None\n\n        Returns:\n            HTMLResponse: The HTML formatted response containing the results of the query execution.\n\n        Raises:\n            HTTPException: If the query cannot be found or fails to execute.\n        \"\"\"\n        content = self.query(\n            name=name,\n            namespace=namespace,\n            domain=domain,\n            endpoint_name=endpoint_name,\n            limit=limit,\n        )\n        if not content:\n            raise HTTPException(status_code=500, detail=\"Could not create result\")\n\n        # Return the content as an HTML response\n        return HTMLResponse(content)\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQueryWebServer.authenticated","title":"<code>authenticated()</code>","text":"<p>Check if the user is authenticated. Returns:     True if the user is authenticated, False otherwise.</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def authenticated(self) -&gt; bool:\n    \"\"\"\n    Check if the user is authenticated.\n    Returns:\n        True if the user is authenticated, False otherwise.\n    \"\"\"\n    return self.login.authenticated() or self.orcid_auth.authenticated()\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQueryWebServer.get_config","title":"<code>get_config()</code>  <code>classmethod</code>","text":"<p>get the configuration for this Webserver</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>@classmethod\ndef get_config(cls) -&gt; WebserverConfig:\n    \"\"\"\n    get the configuration for this Webserver\n    \"\"\"\n    copy_right = \"\"\n    config = WebserverConfig(\n        short_name=\"snapquery\",\n        copy_right=copy_right,\n        version=Version(),\n        default_port=9862,\n        timeout=6.0,\n    )\n    server_config = WebserverConfig.get(config)\n    server_config.solution_class = SnapQuerySolution\n    return server_config\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQueryWebServer.get_r_format","title":"<code>get_r_format(name, default_format_str='html')</code>","text":"<p>get the result format from the given query name following the dot convention that . specifies the result format e.g. cats.json will ask for the json result format <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the query/meta query</p> required <code>default_format_str(str)</code> <p>the name of the default format to use</p> required <p>Returns:</p> Name Type Description <code>Format</code> <code>Format</code> <p>the result format</p> Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def get_r_format(self, name: str, default_format_str: str = \"html\") -&gt; Format:\n    \"\"\"\n    get the result format from the given query name following the\n    dot convention that &lt;name&gt;.&lt;r_format_str&gt; specifies the result format\n    e.g. cats.json will ask for the json result format\n\n    Args:\n        name(str): the name of the query/meta query\n        default_format_str(str): the name of the default format to use\n\n    Returns:\n        Format: the result format\n    \"\"\"\n    if \".\" in name:\n        r_format_str = name.split(\".\")[-1]\n        name = name[: name.rfind(\".\")]\n    else:\n        r_format_str = default_format_str\n    r_format = Format[r_format_str]\n    return name, r_format\n</code></pre>"},{"location":"#snapquery.snapquery_webserver.SnapQueryWebServer.query","title":"<code>query(name, namespace, domain, endpoint_name='wikidata', limit=None)</code>","text":"<p>Queries an external API to retrieve data based on a given namespace and name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name identifier of the data to be queried.</p> required <code>namespace</code> <code>str</code> <p>The namespace to which the query belongs. It helps in categorizing the data.</p> required <code>domain</code> <code>str</code> <p>The domain identifying the domain of the query.</p> required <code>endpoint_name</code> <code>str</code> <p>The name of the endpoint to be used for the query. Defaults to 'wikidata'.</p> <code>'wikidata'</code> <code>limit(int)</code> <p>the limit for the query default: None</p> required <code>Returns</code> <p>str: the content retrieved</p> required Source code in <code>snapquery/snapquery_webserver.py</code> <pre><code>def query(\n    self,\n    name: str,\n    namespace: str,\n    domain: str,\n    endpoint_name: str = \"wikidata\",\n    limit: int = None,\n) -&gt; str:\n    \"\"\"\n    Queries an external API to retrieve data based on a given namespace and name.\n\n    Args:\n        name (str): The name identifier of the data to be queried.\n        namespace (str): The namespace to which the query belongs. It helps in categorizing the data.\n        domain (str): The domain identifying the domain of the query.\n        endpoint_name (str): The name of the endpoint to be used for the query. Defaults to 'wikidata'.\n        limit(int): the limit for the query default: None\n\n        Returns:\n            str: the content retrieved\n    \"\"\"\n    try:\n        # content negotiation\n        name, r_format = self.get_r_format(name)\n        query_name = QueryName(domain=domain, namespace=namespace, name=name)\n        qb = self.nqm.get_query(query_name=query_name, endpoint_name=endpoint_name, limit=limit)\n        (qlod, stats) = qb.get_lod_with_stats()\n        self.nqm.store_stats([stats])\n        content = qb.format_result(qlod, r_format)\n        return content\n    except Exception as e:\n        # Handling specific exceptions can be more detailed based on what nqm.get_sparql and nqm.query can raise\n        raise HTTPException(status_code=404, detail=str(e))\n</code></pre>"},{"location":"#snapquery.sparql_analyzer","title":"<code>sparql_analyzer</code>","text":""},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer","title":"<code>SparqlAnalyzer</code>","text":"<p>SPARQL Query Analyzer</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>class SparqlAnalyzer:\n    \"\"\"\n    SPARQL Query Analyzer\n    \"\"\"\n\n    BLAZEGRAPH_NAMED_SUBQUERY_PATTERN = r\"\"\"WITH[\\s\\n]*(#[\\w\\s://\\.\\n,]+)?{(#[\\w\\s://\\.\\n,]+)?[\\s\\n](?P&lt;subquery&gt;[\\n\\r\\b\\w\\d:\\t\\.\";,\\{\\)\\(\\?\\}\\W#]*?)\\s+[Aa][Ss]\\s+%(?P&lt;name&gt;[A-Za-z\\d_]+)\"\"\"\n\n    @classmethod\n    def get_prefix_luts(cls) -&gt; dict[str, str]:\n        return {\n            \"biopax\": \"http://www.biopax.org/release/biopax-level3.owl#\",\n            \"bd\": \"http://www.bigdata.com/rdf#\",\n            \"cc\": \"http://creativecommons.org/ns#\",\n            \"datacite\": \"http://purl.org/spar/datacite/\",\n            \"dblp\": \"https://dblp.org/rdf/schema#\",\n            \"dc\": \"http://purl.org/dc/elements/1.1/\",\n            \"dct\": \"http://purl.org/dc/terms/\",\n            \"freq\": \"http://purl.org/cld/freq/\",\n            \"geo\": \"http://www.opengis.net/ont/geosparql#\",\n            \"geof\": \"http://www.opengis.net/def/function/geosparql/\",\n            \"geom\": \"http://geovocab.org/geometry#\",\n            \"gpml\": \"http://vocabularies.wikipathways.org/gpml#\",\n            \"litre\": \"http://purl.org/spar/literal/\",\n            \"lgdo\": \"http://linkedgeodata.org/ontology/\",\n            \"ontolex\": \"http://www.w3.org/ns/lemon/ontolex#\",\n            \"orkgp\": \"http://orkg.org/orkg/predicate/\",\n            \"orkgc\": \"http://orkg.org/orkg/class/\",\n            \"orkgr\": \"http://orkg.org/orkg/resource/\",\n            \"owl\": \"http://www.w3.org/2002/07/owl#\",\n            \"p\": \"http://www.wikidata.org/prop/\",\n            \"pav\": \"http://purl.org/pav/\",\n            \"pq\": \"http://www.wikidata.org/prop/qualifier/\",\n            \"pqn\": \"http://www.wikidata.org/prop/qualifier/value-normalized/\",\n            \"pqv\": \"http://www.wikidata.org/prop/qualifier/value/\",\n            \"pr\": \"http://www.wikidata.org/prop/reference/\",\n            \"prn\": \"http://www.wikidata.org/prop/reference/value-normalized/\",\n            \"prov\": \"http://www.w3.org/ns/prov#\",\n            \"prv\": \"http://www.wikidata.org/prop/reference/value/\",\n            \"ps\": \"http://www.wikidata.org/prop/statement/\",\n            \"psn\": \"http://www.wikidata.org/prop/statement/value-normalized/\",\n            \"psv\": \"http://www.wikidata.org/prop/statement/value/\",\n            \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n            \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n            \"schema\": \"http://schema.org/\",\n            \"skos\": \"http://www.w3.org/2004/02/skos/core#\",\n            \"void\": \"http://rdfs.org/ns/void#\",\n            \"vrank\": \"http://purl.org/voc/vrank#\",\n            \"wd\": \"http://www.wikidata.org/entity/\",\n            \"wdata\": \"http://www.wikidata.org/wiki/Special:EntityData/\",\n            \"wdno\": \"http://www.wikidata.org/prop/novalue/\",\n            \"wdref\": \"http://www.wikidata.org/reference/\",\n            \"wds\": \"http://www.wikidata.org/entity/statement/\",\n            \"wdt\": \"http://www.wikidata.org/prop/direct/\",\n            \"wdtn\": \"http://www.wikidata.org/prop/direct-normalized/\",\n            \"wdv\": \"http://www.wikidata.org/value/\",\n            \"wikibase\": \"http://wikiba.se/ontology#\",\n            \"wp\": \"http://vocabularies.wikipathways.org/wp#\",\n            \"wprdf\": \"http://rdf.wikipathways.org/\",\n            \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n            \"mwapi\": \"https://www.mediawiki.org/ontology#API/\",\n            \"hint\": \"http://www.bigdata.com/queryHints#\",\n            \"gas\": \"http://www.bigdata.com/rdf/gas#\",\n        }\n\n    @classmethod\n    def prefix_clause(cls, prefix: str, iri: str) -&gt; str:\n        \"\"\"\n        Provide SPARQL refix clause for given prefix and url\n        Args:\n            prefix: prefix name\n            iri: iri\n\n        Returns:\n            prefix clause\n        \"\"\"\n        return f\"PREFIX {prefix}:  &lt;{iri}&gt;\"\n\n    @classmethod\n    def extract_used_prefixes(cls, query: str) -&gt; tuple[dict[str, str], set[str]]:\n        \"\"\"\n        Extract used prefixes from SPARQL query\n        Args:\n            query: SPARQL query\n\n        Returns:\n            dict of declared prefixes\n        \"\"\"\n        # add prefixes to avoid parsing error due to missing prefix\n        prefix_lut = cls.get_prefix_luts()\n        prefixed_query = cls._add_prefixes(prefix_lut, query)\n        parsed_query = parseQuery(prefixed_query)\n        elements = parsed_query.as_list()\n        defined_prefixes = []\n        used_prefixes = []\n        for element in elements:\n            if isinstance(element, CompValue) and element.name == \"PrefixDecl\":\n                defined_prefixes.append(element)\n            elif isinstance(element, CompValue) and element.name == \"pname\":\n                used_prefixes.append(element)\n            elif isinstance(element, Iterable) and not isinstance(element, str):\n                if isinstance(element, dict):\n                    elements.extend(element.values())\n                else:\n                    elements.extend(element)\n            else:\n                pass\n        declared_prefix_counter = Counter([value.get(\"prefix\") for value in defined_prefixes])\n        multi_declarations = [prefix for prefix, count in declared_prefix_counter.items() if count &gt; 1]\n        used_prefix_names = {value.get(\"prefix\") for value in used_prefixes}\n        used_prefix_map = dict()\n        for prefix_value in reversed(defined_prefixes):\n            prefix_name = prefix_value.get(\"prefix\")\n            prefix_iri = prefix_value.get(\"iri\")\n            if prefix_name in multi_declarations or prefix_name not in prefix_lut:\n                used_prefix_map[prefix_name] = str(prefix_iri)\n        return used_prefix_map, used_prefix_names\n\n    @classmethod\n    def add_missing_prefixes(cls, query: str):\n        \"\"\"\n        Add missing prefixes to SPARQL query\n        Args:\n            query: SPARQL query\n\n        Returns:\n            SPARQL query\n        \"\"\"\n        try:\n            # normalize query for parsing\n            prepared_query = query\n            if cls.has_parameter(prepared_query):\n                prepared_query = cls.fill_with_sample_query_parameters(prepared_query)\n            if cls.has_blazegraph_with_clause(prepared_query):\n                prepared_query = cls.transform_with_clause_to_subquery(prepared_query)\n            # extract used and declared prefixes\n            declared_prefixes, used_prefixes = cls.extract_used_prefixes(prepared_query)\n            missing_prefix_declarations = used_prefixes - set(declared_prefixes.keys())\n            undefined_prefixes = missing_prefix_declarations.difference(cls.get_prefix_luts().keys())\n            if undefined_prefixes:\n                logger.error(\n                    f\"Prefix definitions missing for: {undefined_prefixes} \u2192 Not all prefixes that are missing can be added\"\n                )\n            missing_prefix_declarations_lut = {\n                key: value for key, value in cls.get_prefix_luts().items() if key in missing_prefix_declarations\n            }\n            fixed_query = cls._add_prefixes(missing_prefix_declarations_lut, query)\n        except Exception as e:\n            logger.debug(\"Adding missing prefixes to query failed \u2192 Unable to parse SPARQL query\")\n            logging.error(e)\n            fixed_query = query\n        return fixed_query\n\n    @classmethod\n    def transform_with_clause_to_subquery(cls, query: str) -&gt; str:\n        \"\"\"\n        Transform blazegraph with clause to subquery statement\n        Args:\n            query:\n\n        Returns:\n\n        \"\"\"\n        match = re.search(cls.BLAZEGRAPH_NAMED_SUBQUERY_PATTERN, query)\n        if match:\n            subquery = match.group(\"subquery\")\n            name = match.group(\"name\")\n            start_pos, end_pos = match.span()\n            # check if Where mus be added\n            select_part = query[:start_pos]\n            where_part = query[end_pos + 1 :]\n            if cls.has_blazegraph_with_clause(where_part):\n                where_part = cls.transform_with_clause_to_subquery(where_part)\n            if where_part.lower().strip().startswith(\"where\"):\n                query_with_removed = select_part + where_part\n            else:\n                query_with_removed = f\"{select_part}\\nWHERE\\n{where_part}\"\n\n            include_pattern = f\"[Ii][Nn][Cc][Ll][Uu][Dd][Ee]\\s+%{name}\"\n            subquery = f\"{{{subquery}\\n\"\n            query_transformed = re.sub(include_pattern, subquery, query_with_removed)\n            return query_transformed\n\n    @classmethod\n    def has_blazegraph_with_clause(cls, query: str) -&gt; bool:\n        \"\"\"\n        Check if the given query has a WITH clause (named subquery)\n        For details see https://github.com/blazegraph/database/wiki/NamedSubquery\n        Args:\n            query: SPARQL query\n\n        Returns:\n            True if the query has a WITH clause (named subquery)\n        \"\"\"\n        match = re.search(cls.BLAZEGRAPH_NAMED_SUBQUERY_PATTERN, query)\n        return True if match else False\n\n    @classmethod\n    def _add_prefixes(cls, prefixes: dict[str, str], query: str) -&gt; str:\n        \"\"\"\n        Add prefixes to SPARQL query\n        Args:\n            prefixes: prefixes to add\n            query: SPARQL query\n\n        Returns:\n            SPARQL query with prefixes added\n        \"\"\"\n        prefixes_clauses = [cls.prefix_clause(prefix, iri) for prefix, iri in prefixes.items()]\n        prefixes_clauses_str = \"\\n\".join(prefixes_clauses)\n        return prefixes_clauses_str + \"\\n\" + query\n\n    @classmethod\n    def has_parameter(cls, query: str) -&gt; bool:\n        \"\"\"\n        Check if the given query has parameters that need to need set\n        Args:\n            query: SPARQL query\n\n        Returns:\n            True if the query has parameters that need to need set\n        \"\"\"\n        vars = cls.get_query_parameter(query)\n        return len(vars) &gt; 0\n\n    @classmethod\n    def get_query_parameter(cls, query: str) -&gt; set[str]:\n        env = Environment()\n        ast = env.parse(query)\n        vars = meta.find_undeclared_variables(ast)\n        return vars\n\n    @classmethod\n    def fill_with_sample_query_parameters(cls, query: str) -&gt; str:\n        \"\"\"\n        Fill the given SPARQL query with sample query parameters\n        Args:\n            query: SPARQL query\n\n        Returns:\n\n        \"\"\"\n        if not cls.has_parameter(query):\n            return query\n        parameter_names = cls.get_query_parameter(query)\n        params = cls._prepare_sample_parameter(parameter_names)\n        return cls.bind_parameters_to_query(query, params)\n\n    @classmethod\n    def bind_parameters_to_query(cls, query: str, params: dict[str, str]) -&gt; str:\n        \"\"\"\n        Bind the parameters to the given query\n        Args:\n            query: SPARQL query\n            params: quera params\n\n        Returns:\n            Query with parameters binded\n        \"\"\"\n        template = Template(query)\n        query_with_param_values = template.render(**params)\n        return query_with_param_values\n\n    @classmethod\n    def _prepare_sample_parameter(cls, parameter_names: set[str]) -&gt; dict[str, str]:\n        \"\"\"\n        Prepare sample query parameters\n        \"\"\"\n        params = dict()\n        for name in parameter_names:\n            params[name] = f\"Q{random.randint(1, 1000)}\"\n        return params\n\n    @classmethod\n    def is_valid(cls, query: str):\n        \"\"\"\n        Check if query is valid SPARQL query\n        Args:\n            query: SPARQL query\n\n        Returns:\n            True if query is valid SPARQL query\n        \"\"\"\n        try:\n            prepareQuery(query)\n            return True\n        except Exception as e:\n            logger.debug(f\"Query is not valid SPARQL query: {e}\")\n            return False\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.add_missing_prefixes","title":"<code>add_missing_prefixes(query)</code>  <code>classmethod</code>","text":"<p>Add missing prefixes to SPARQL query Args:     query: SPARQL query</p> <p>Returns:</p> Type Description <p>SPARQL query</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef add_missing_prefixes(cls, query: str):\n    \"\"\"\n    Add missing prefixes to SPARQL query\n    Args:\n        query: SPARQL query\n\n    Returns:\n        SPARQL query\n    \"\"\"\n    try:\n        # normalize query for parsing\n        prepared_query = query\n        if cls.has_parameter(prepared_query):\n            prepared_query = cls.fill_with_sample_query_parameters(prepared_query)\n        if cls.has_blazegraph_with_clause(prepared_query):\n            prepared_query = cls.transform_with_clause_to_subquery(prepared_query)\n        # extract used and declared prefixes\n        declared_prefixes, used_prefixes = cls.extract_used_prefixes(prepared_query)\n        missing_prefix_declarations = used_prefixes - set(declared_prefixes.keys())\n        undefined_prefixes = missing_prefix_declarations.difference(cls.get_prefix_luts().keys())\n        if undefined_prefixes:\n            logger.error(\n                f\"Prefix definitions missing for: {undefined_prefixes} \u2192 Not all prefixes that are missing can be added\"\n            )\n        missing_prefix_declarations_lut = {\n            key: value for key, value in cls.get_prefix_luts().items() if key in missing_prefix_declarations\n        }\n        fixed_query = cls._add_prefixes(missing_prefix_declarations_lut, query)\n    except Exception as e:\n        logger.debug(\"Adding missing prefixes to query failed \u2192 Unable to parse SPARQL query\")\n        logging.error(e)\n        fixed_query = query\n    return fixed_query\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.bind_parameters_to_query","title":"<code>bind_parameters_to_query(query, params)</code>  <code>classmethod</code>","text":"<p>Bind the parameters to the given query Args:     query: SPARQL query     params: quera params</p> <p>Returns:</p> Type Description <code>str</code> <p>Query with parameters binded</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef bind_parameters_to_query(cls, query: str, params: dict[str, str]) -&gt; str:\n    \"\"\"\n    Bind the parameters to the given query\n    Args:\n        query: SPARQL query\n        params: quera params\n\n    Returns:\n        Query with parameters binded\n    \"\"\"\n    template = Template(query)\n    query_with_param_values = template.render(**params)\n    return query_with_param_values\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.extract_used_prefixes","title":"<code>extract_used_prefixes(query)</code>  <code>classmethod</code>","text":"<p>Extract used prefixes from SPARQL query Args:     query: SPARQL query</p> <p>Returns:</p> Type Description <code>tuple[dict[str, str], set[str]]</code> <p>dict of declared prefixes</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef extract_used_prefixes(cls, query: str) -&gt; tuple[dict[str, str], set[str]]:\n    \"\"\"\n    Extract used prefixes from SPARQL query\n    Args:\n        query: SPARQL query\n\n    Returns:\n        dict of declared prefixes\n    \"\"\"\n    # add prefixes to avoid parsing error due to missing prefix\n    prefix_lut = cls.get_prefix_luts()\n    prefixed_query = cls._add_prefixes(prefix_lut, query)\n    parsed_query = parseQuery(prefixed_query)\n    elements = parsed_query.as_list()\n    defined_prefixes = []\n    used_prefixes = []\n    for element in elements:\n        if isinstance(element, CompValue) and element.name == \"PrefixDecl\":\n            defined_prefixes.append(element)\n        elif isinstance(element, CompValue) and element.name == \"pname\":\n            used_prefixes.append(element)\n        elif isinstance(element, Iterable) and not isinstance(element, str):\n            if isinstance(element, dict):\n                elements.extend(element.values())\n            else:\n                elements.extend(element)\n        else:\n            pass\n    declared_prefix_counter = Counter([value.get(\"prefix\") for value in defined_prefixes])\n    multi_declarations = [prefix for prefix, count in declared_prefix_counter.items() if count &gt; 1]\n    used_prefix_names = {value.get(\"prefix\") for value in used_prefixes}\n    used_prefix_map = dict()\n    for prefix_value in reversed(defined_prefixes):\n        prefix_name = prefix_value.get(\"prefix\")\n        prefix_iri = prefix_value.get(\"iri\")\n        if prefix_name in multi_declarations or prefix_name not in prefix_lut:\n            used_prefix_map[prefix_name] = str(prefix_iri)\n    return used_prefix_map, used_prefix_names\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.fill_with_sample_query_parameters","title":"<code>fill_with_sample_query_parameters(query)</code>  <code>classmethod</code>","text":"<p>Fill the given SPARQL query with sample query parameters Args:     query: SPARQL query</p> <p>Returns:</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef fill_with_sample_query_parameters(cls, query: str) -&gt; str:\n    \"\"\"\n    Fill the given SPARQL query with sample query parameters\n    Args:\n        query: SPARQL query\n\n    Returns:\n\n    \"\"\"\n    if not cls.has_parameter(query):\n        return query\n    parameter_names = cls.get_query_parameter(query)\n    params = cls._prepare_sample_parameter(parameter_names)\n    return cls.bind_parameters_to_query(query, params)\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.has_blazegraph_with_clause","title":"<code>has_blazegraph_with_clause(query)</code>  <code>classmethod</code>","text":"<p>Check if the given query has a WITH clause (named subquery) For details see https://github.com/blazegraph/database/wiki/NamedSubquery Args:     query: SPARQL query</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the query has a WITH clause (named subquery)</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef has_blazegraph_with_clause(cls, query: str) -&gt; bool:\n    \"\"\"\n    Check if the given query has a WITH clause (named subquery)\n    For details see https://github.com/blazegraph/database/wiki/NamedSubquery\n    Args:\n        query: SPARQL query\n\n    Returns:\n        True if the query has a WITH clause (named subquery)\n    \"\"\"\n    match = re.search(cls.BLAZEGRAPH_NAMED_SUBQUERY_PATTERN, query)\n    return True if match else False\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.has_parameter","title":"<code>has_parameter(query)</code>  <code>classmethod</code>","text":"<p>Check if the given query has parameters that need to need set Args:     query: SPARQL query</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the query has parameters that need to need set</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef has_parameter(cls, query: str) -&gt; bool:\n    \"\"\"\n    Check if the given query has parameters that need to need set\n    Args:\n        query: SPARQL query\n\n    Returns:\n        True if the query has parameters that need to need set\n    \"\"\"\n    vars = cls.get_query_parameter(query)\n    return len(vars) &gt; 0\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.is_valid","title":"<code>is_valid(query)</code>  <code>classmethod</code>","text":"<p>Check if query is valid SPARQL query Args:     query: SPARQL query</p> <p>Returns:</p> Type Description <p>True if query is valid SPARQL query</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef is_valid(cls, query: str):\n    \"\"\"\n    Check if query is valid SPARQL query\n    Args:\n        query: SPARQL query\n\n    Returns:\n        True if query is valid SPARQL query\n    \"\"\"\n    try:\n        prepareQuery(query)\n        return True\n    except Exception as e:\n        logger.debug(f\"Query is not valid SPARQL query: {e}\")\n        return False\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.prefix_clause","title":"<code>prefix_clause(prefix, iri)</code>  <code>classmethod</code>","text":"<p>Provide SPARQL refix clause for given prefix and url Args:     prefix: prefix name     iri: iri</p> <p>Returns:</p> Type Description <code>str</code> <p>prefix clause</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef prefix_clause(cls, prefix: str, iri: str) -&gt; str:\n    \"\"\"\n    Provide SPARQL refix clause for given prefix and url\n    Args:\n        prefix: prefix name\n        iri: iri\n\n    Returns:\n        prefix clause\n    \"\"\"\n    return f\"PREFIX {prefix}:  &lt;{iri}&gt;\"\n</code></pre>"},{"location":"#snapquery.sparql_analyzer.SparqlAnalyzer.transform_with_clause_to_subquery","title":"<code>transform_with_clause_to_subquery(query)</code>  <code>classmethod</code>","text":"<p>Transform blazegraph with clause to subquery statement Args:     query:</p> <p>Returns:</p> Source code in <code>snapquery/sparql_analyzer.py</code> <pre><code>@classmethod\ndef transform_with_clause_to_subquery(cls, query: str) -&gt; str:\n    \"\"\"\n    Transform blazegraph with clause to subquery statement\n    Args:\n        query:\n\n    Returns:\n\n    \"\"\"\n    match = re.search(cls.BLAZEGRAPH_NAMED_SUBQUERY_PATTERN, query)\n    if match:\n        subquery = match.group(\"subquery\")\n        name = match.group(\"name\")\n        start_pos, end_pos = match.span()\n        # check if Where mus be added\n        select_part = query[:start_pos]\n        where_part = query[end_pos + 1 :]\n        if cls.has_blazegraph_with_clause(where_part):\n            where_part = cls.transform_with_clause_to_subquery(where_part)\n        if where_part.lower().strip().startswith(\"where\"):\n            query_with_removed = select_part + where_part\n        else:\n            query_with_removed = f\"{select_part}\\nWHERE\\n{where_part}\"\n\n        include_pattern = f\"[Ii][Nn][Cc][Ll][Uu][Dd][Ee]\\s+%{name}\"\n        subquery = f\"{{{subquery}\\n\"\n        query_transformed = re.sub(include_pattern, subquery, query_with_removed)\n        return query_transformed\n</code></pre>"},{"location":"#snapquery.stats_view","title":"<code>stats_view</code>","text":""},{"location":"#snapquery.stats_view.QueryStatsView","title":"<code>QueryStatsView</code>","text":"<p>display Query Import UI</p> Source code in <code>snapquery/stats_view.py</code> <pre><code>class QueryStatsView:\n    \"\"\"\n    display Query Import UI\n    \"\"\"\n\n    def __init__(self, solution=None):\n        self.solution = solution\n        if self.solution:\n            self.nqm = self.solution.nqm\n            self.setup_ui()\n\n    def setup_ui(self):\n        \"\"\"\n        setup the user interface\n        \"\"\"\n        with self.solution.container:\n            with ui.expansion(\n                text=\"Statistics about the properties and items used in the stored queries\",\n                value=True,\n            ):\n                self.input_row = ui.column()\n                self.input_row.classes(\"w-full\")\n                self.show_entity_usage()\n                self.show_property_usage()\n            with ui.expansion(text=\"Query Stats\", value=True):\n                ui.label(\"ToDo:\")\n\n    def show_entity_usage(self):\n        \"\"\"\n        show entity usage in the queries\n        \"\"\"\n        stats = QUERY_ITEM_STATS.get_entity_stats()\n        records = [{\"name\": stat.label, \"count\": stat.count, \"id\": stat.identifier} for stat in stats]\n        df = DataFrame.from_records(records).sort_values(by=\"count\", ascending=False)\n        fig = px.bar(df, x=\"name\", y=\"count\", title=\"Entity usage in queries\")\n        with self.input_row:\n            ui.plotly(fig).classes(\"w-full\")\n\n    def show_property_usage(self):\n        \"\"\"\n        show property usage in the queries\n        \"\"\"\n        stats = QUERY_ITEM_STATS.get_property_stats()\n        records = [{\"name\": stat.label, \"count\": stat.count} for stat in stats]\n        df = DataFrame.from_records(records).sort_values(by=\"count\", ascending=False)\n        fig = px.bar(df, x=\"name\", y=\"count\", title=\"Property usage in queries\")\n        with self.input_row:\n            ui.plotly(fig).classes(\"w-full\")\n</code></pre>"},{"location":"#snapquery.stats_view.QueryStatsView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>setup the user interface</p> Source code in <code>snapquery/stats_view.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    setup the user interface\n    \"\"\"\n    with self.solution.container:\n        with ui.expansion(\n            text=\"Statistics about the properties and items used in the stored queries\",\n            value=True,\n        ):\n            self.input_row = ui.column()\n            self.input_row.classes(\"w-full\")\n            self.show_entity_usage()\n            self.show_property_usage()\n        with ui.expansion(text=\"Query Stats\", value=True):\n            ui.label(\"ToDo:\")\n</code></pre>"},{"location":"#snapquery.stats_view.QueryStatsView.show_entity_usage","title":"<code>show_entity_usage()</code>","text":"<p>show entity usage in the queries</p> Source code in <code>snapquery/stats_view.py</code> <pre><code>def show_entity_usage(self):\n    \"\"\"\n    show entity usage in the queries\n    \"\"\"\n    stats = QUERY_ITEM_STATS.get_entity_stats()\n    records = [{\"name\": stat.label, \"count\": stat.count, \"id\": stat.identifier} for stat in stats]\n    df = DataFrame.from_records(records).sort_values(by=\"count\", ascending=False)\n    fig = px.bar(df, x=\"name\", y=\"count\", title=\"Entity usage in queries\")\n    with self.input_row:\n        ui.plotly(fig).classes(\"w-full\")\n</code></pre>"},{"location":"#snapquery.stats_view.QueryStatsView.show_property_usage","title":"<code>show_property_usage()</code>","text":"<p>show property usage in the queries</p> Source code in <code>snapquery/stats_view.py</code> <pre><code>def show_property_usage(self):\n    \"\"\"\n    show property usage in the queries\n    \"\"\"\n    stats = QUERY_ITEM_STATS.get_property_stats()\n    records = [{\"name\": stat.label, \"count\": stat.count} for stat in stats]\n    df = DataFrame.from_records(records).sort_values(by=\"count\", ascending=False)\n    fig = px.bar(df, x=\"name\", y=\"count\", title=\"Property usage in queries\")\n    with self.input_row:\n        ui.plotly(fig).classes(\"w-full\")\n</code></pre>"},{"location":"#snapquery.version","title":"<code>version</code>","text":"<p>Created on 2024-05-01</p> <p>@author: wf</p>"},{"location":"#snapquery.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>Version handling for nicepdf</p> Source code in <code>snapquery/version.py</code> <pre><code>@dataclass\nclass Version:\n    \"\"\"\n    Version handling for nicepdf\n    \"\"\"\n\n    name = \"snapquery\"\n    version = snapquery.__version__\n    date = \"2024-05-03\"\n    updated = \"2024-07-13\"\n    description = \"Introduce Named Queries and Named Query Middleware to wikidata\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/snapquery\"\n    chat_url = \"https://github.com/WolfgangFahl/snapquery/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/snapquery\"\n\n    license = \"\"\"Copyright 2024 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor","title":"<code>wd_page_query_extractor</code>","text":"<p>Created on 2024-05-04 Author: tholzheim</p>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor","title":"<code>WikipediaQueryExtractor</code>","text":"<p>A class to handle the extraction and management of SPARQL queries from a Wikipedia page.</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>class WikipediaQueryExtractor:\n    \"\"\"\n    A class to handle the extraction and management\n    of SPARQL queries from a Wikipedia page.\n    \"\"\"\n\n    def __init__(\n        self,\n        nqm: NamedQueryManager,\n        base_url: str,\n        domain: str,\n        namespace: str,\n        target_graph_name: str,\n        template_name: str = \"SPARQL\",  # https://en.wikipedia.org/wiki/Template:SPARQL) - if None seek for short-urls\n        debug: bool=False\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.nqm = nqm\n        self.base_url = base_url\n        self.domain = domain\n        self.namespace = namespace\n        self.target_graph_name = target_graph_name\n        self.template_name = template_name\n        self.debug=debug\n        self.logger = logging.getLogger(\"snapquery.wd_page_extractor.WikipediaQueryExtractor\")\n\n        self.named_query_list = NamedQuerySet(\n            domain=self.domain, \n            namespace=self.namespace, \n            target_graph_name=self.target_graph_name\n        )\n        self.errors = []\n\n    def log(self, message: str, is_error: bool = False):\n        if self.debug:\n            print(message)\n        if is_error:\n            self.logger.debug(message) \n            self.errors.append(message)\n\n    def get_wikitext(self) -&gt; str:\n        \"\"\"\n        Get wiki text with SPARQL query examples.\n\n        Returns:\n            str: Raw wikitext of the page.\n        \"\"\"\n        res = requests.get(f\"{self.base_url}?action=raw\")\n        return res.text\n\n    def sanitize_text(self, text: str) -&gt; str:\n        \"\"\"\n        General method to sanitize text by removing translation tags, comments,\n        and other non-essential markup.\n\n        Args:\n            text (str): The text to be sanitized.\n\n        Returns:\n            str: The sanitized text.\n        \"\"\"\n        # Remove &lt;translate&gt;...&lt;/translate&gt; tags\n        text = re.sub(r\"&lt;translate&gt;(.*?)&lt;\\/translate&gt;\", r\"\\1\", text, flags=re.DOTALL)\n        # Remove &lt;!--T:...--&gt; tags\n        text = re.sub(r\"&lt;!--T:\\d+--&gt;\", \"\", text)\n        # Strip whitespace that might be left at the beginning and end\n        text = text.strip()\n        return text\n\n    def extract_query_from_wiki_markup(self, title: str, markup: str, sparql: str,url:str=None) -&gt; NamedQuery:\n        \"\"\"\n        Extracts a named query from wiki markup.\n\n        This method processes the title, markup, and SPARQL query to create a NamedQuery object.\n        It sanitizes the text, removes section headers from the description, and constructs \n        a URL that points to the specific section of the Wikipedia page.\n\n        Args:\n            title (str): The title of the query section.\n            markup (str): The wiki markup text containing the query description.\n            sparql (str): The SPARQL query string.\n            url(str): the url to assign - if not given derive from base_url and section title\n\n        Returns:\n            NamedQuery: A NamedQuery object containing the processed information.\n\n        Note:\n            The method sanitizes the title and description, removes section headers from the\n            description, and constructs a URL with a section anchor based on the title.\n        \"\"\"\n        desc = self.sanitize_text(markup)\n        if desc:\n            # Remove section headers\n            desc = re.sub(r\"\\n*={2,4}.*?={2,4}\\n*\", \"\", desc)\n            desc = desc.strip()\n        title = self.sanitize_text(title)\n        if url is None:\n            url=f\"{self.base_url}#{title.replace(' ', '_')}\"\n        named_query = NamedQuery(\n            domain=self.domain,\n            namespace=self.namespace,\n            name=title,\n            title=title,\n            description=desc,\n            url=url,\n            sparql=sparql,\n        )\n        return named_query\n\n    def extract_queries_from_wiki_markup(self, markup: str) -&gt; List[NamedQuery]:\n        named_queries = []\n        pattern = r\"(.*?)(https?://w\\.wiki/\\S+)(.*?)(?=https?://w\\.wiki/|\\Z)\"\n        matches = re.findall(pattern, markup, re.DOTALL | re.MULTILINE)\n\n        for pre_text, short_url, post_text in matches:\n            self.log(f\"Processing short URL: {short_url}\")\n            pre_text = pre_text.strip()\n            post_text = post_text.strip()\n            description = f\"{pre_text} {post_text}\".strip()\n            short_url_instance = ShortUrl(short_url=short_url)\n\n            title = short_url_instance.name\n            query_name = QueryName(name=title, namespace=self.namespace, domain=self.domain)\n\n            if query_name.query_id in self.named_query_list._query_dict:\n                self.log(f\"Query with ID {query_name.query_id} already exists. Skipping.\", is_error=True)\n                continue\n\n            sparql_query = short_url_instance.read_query()\n            if short_url_instance.error:\n                self.log(f\"Error reading query from {short_url}: {short_url_instance.error}\", is_error=True)\n                continue\n\n            if sparql_query:\n                query = self.extract_query_from_wiki_markup(\n                    title=title, \n                    markup=description, \n                    sparql=sparql_query,\n                    url=short_url_instance.short_url)\n                self.named_query_list.add(query)\n                self.log(f\"Added query: {title}\")\n            else:\n                self.log(f\"No query found for short URL {short_url}\", is_error=True)\n\n        if not self.debug and self.errors:\n            self.logger.info(f\"Encountered {len(self.errors)} errors during extraction. Set debug=True for more details.\")\n\n        return named_queries\n\n    def extract_queries_from_section(self, section: Section):\n        \"\"\"\n        Extract named queries from section.\n\n        Args:\n            section (Section): Wikitext section containing a SPARQL query.\n        \"\"\"\n        if self.template_name:\n            template = self.get_template(section.templates)\n            if template:\n                sparql = template.arguments[0].value\n                if sparql:\n                    query = self.extract_query_from_wiki_markup(\n                        section.title, markup=section.plain_text(), sparql=sparql\n                    )\n                    self.named_query_list.add(query)\n        else:\n            markup = section.plain_text()\n            self.extract_queries_from_wiki_markup(markup)\n\n    def get_template(self, templates: list[Template]) -&gt; Template:\n        \"\"\"\n        Get template from the list of templates.\n\n        Args:\n            templates (list[Template]): List of Wikitext templates.\n\n        Returns:\n            Template: template if available, otherwise None.\n        \"\"\"\n        queries = [template for template in templates if template.name == self.template_name]\n        return queries[0] if len(queries) == 1 else None\n\n    def extract_queries(self, wikitext: str = None):\n        \"\"\"\n        Extract all queries from the base_url page.\n        \"\"\"\n        if wikitext is None:\n            wikitext = self.get_wikitext()\n        parsed = wtp.parse(wikitext)\n        for section in parsed.sections:\n            self.extract_queries_from_section(section)\n\n    def save_to_json(self, file_path: str):\n        \"\"\"\n        Save the NamedQueryList to a JSON file.\n\n        Args:\n           file_path (str): Path to the JSON file.\n        \"\"\"\n        self.named_query_list.save_to_json_file(file_path, indent=2)\n\n    def store_queries(self):\n        \"\"\"\n        Store the named queries into the database.\n        \"\"\"\n        self.nqm.store_named_query_list(self.named_query_list)\n\n    def show_queries(self):\n        for query in self.named_query_list.queries:\n            pprint.pprint(query)\n        print(f\"Found {len(self.named_query_list.queries)} queries\")\n\n    def show_errors(self):\n        print(f\"{len(self.errors)} errors:\")\n        for i,error in enumerate(self.errors,start=1):\n            print(f\"{i:3}:{error}\")\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.__init__","title":"<code>__init__(nqm, base_url, domain, namespace, target_graph_name, template_name='SPARQL', debug=False)</code>","text":"<p>Constructor</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def __init__(\n    self,\n    nqm: NamedQueryManager,\n    base_url: str,\n    domain: str,\n    namespace: str,\n    target_graph_name: str,\n    template_name: str = \"SPARQL\",  # https://en.wikipedia.org/wiki/Template:SPARQL) - if None seek for short-urls\n    debug: bool=False\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.nqm = nqm\n    self.base_url = base_url\n    self.domain = domain\n    self.namespace = namespace\n    self.target_graph_name = target_graph_name\n    self.template_name = template_name\n    self.debug=debug\n    self.logger = logging.getLogger(\"snapquery.wd_page_extractor.WikipediaQueryExtractor\")\n\n    self.named_query_list = NamedQuerySet(\n        domain=self.domain, \n        namespace=self.namespace, \n        target_graph_name=self.target_graph_name\n    )\n    self.errors = []\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.extract_queries","title":"<code>extract_queries(wikitext=None)</code>","text":"<p>Extract all queries from the base_url page.</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def extract_queries(self, wikitext: str = None):\n    \"\"\"\n    Extract all queries from the base_url page.\n    \"\"\"\n    if wikitext is None:\n        wikitext = self.get_wikitext()\n    parsed = wtp.parse(wikitext)\n    for section in parsed.sections:\n        self.extract_queries_from_section(section)\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.extract_queries_from_section","title":"<code>extract_queries_from_section(section)</code>","text":"<p>Extract named queries from section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>Section</code> <p>Wikitext section containing a SPARQL query.</p> required Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def extract_queries_from_section(self, section: Section):\n    \"\"\"\n    Extract named queries from section.\n\n    Args:\n        section (Section): Wikitext section containing a SPARQL query.\n    \"\"\"\n    if self.template_name:\n        template = self.get_template(section.templates)\n        if template:\n            sparql = template.arguments[0].value\n            if sparql:\n                query = self.extract_query_from_wiki_markup(\n                    section.title, markup=section.plain_text(), sparql=sparql\n                )\n                self.named_query_list.add(query)\n    else:\n        markup = section.plain_text()\n        self.extract_queries_from_wiki_markup(markup)\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.extract_query_from_wiki_markup","title":"<code>extract_query_from_wiki_markup(title, markup, sparql, url=None)</code>","text":"<p>Extracts a named query from wiki markup.</p> <p>This method processes the title, markup, and SPARQL query to create a NamedQuery object. It sanitizes the text, removes section headers from the description, and constructs  a URL that points to the specific section of the Wikipedia page.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the query section.</p> required <code>markup</code> <code>str</code> <p>The wiki markup text containing the query description.</p> required <code>sparql</code> <code>str</code> <p>The SPARQL query string.</p> required <code>url(str)</code> <p>the url to assign - if not given derive from base_url and section title</p> required <p>Returns:</p> Name Type Description <code>NamedQuery</code> <code>NamedQuery</code> <p>A NamedQuery object containing the processed information.</p> Note <p>The method sanitizes the title and description, removes section headers from the description, and constructs a URL with a section anchor based on the title.</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def extract_query_from_wiki_markup(self, title: str, markup: str, sparql: str,url:str=None) -&gt; NamedQuery:\n    \"\"\"\n    Extracts a named query from wiki markup.\n\n    This method processes the title, markup, and SPARQL query to create a NamedQuery object.\n    It sanitizes the text, removes section headers from the description, and constructs \n    a URL that points to the specific section of the Wikipedia page.\n\n    Args:\n        title (str): The title of the query section.\n        markup (str): The wiki markup text containing the query description.\n        sparql (str): The SPARQL query string.\n        url(str): the url to assign - if not given derive from base_url and section title\n\n    Returns:\n        NamedQuery: A NamedQuery object containing the processed information.\n\n    Note:\n        The method sanitizes the title and description, removes section headers from the\n        description, and constructs a URL with a section anchor based on the title.\n    \"\"\"\n    desc = self.sanitize_text(markup)\n    if desc:\n        # Remove section headers\n        desc = re.sub(r\"\\n*={2,4}.*?={2,4}\\n*\", \"\", desc)\n        desc = desc.strip()\n    title = self.sanitize_text(title)\n    if url is None:\n        url=f\"{self.base_url}#{title.replace(' ', '_')}\"\n    named_query = NamedQuery(\n        domain=self.domain,\n        namespace=self.namespace,\n        name=title,\n        title=title,\n        description=desc,\n        url=url,\n        sparql=sparql,\n    )\n    return named_query\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.get_template","title":"<code>get_template(templates)</code>","text":"<p>Get template from the list of templates.</p> <p>Parameters:</p> Name Type Description Default <code>templates</code> <code>list[Template]</code> <p>List of Wikitext templates.</p> required <p>Returns:</p> Name Type Description <code>Template</code> <code>Template</code> <p>template if available, otherwise None.</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def get_template(self, templates: list[Template]) -&gt; Template:\n    \"\"\"\n    Get template from the list of templates.\n\n    Args:\n        templates (list[Template]): List of Wikitext templates.\n\n    Returns:\n        Template: template if available, otherwise None.\n    \"\"\"\n    queries = [template for template in templates if template.name == self.template_name]\n    return queries[0] if len(queries) == 1 else None\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.get_wikitext","title":"<code>get_wikitext()</code>","text":"<p>Get wiki text with SPARQL query examples.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Raw wikitext of the page.</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def get_wikitext(self) -&gt; str:\n    \"\"\"\n    Get wiki text with SPARQL query examples.\n\n    Returns:\n        str: Raw wikitext of the page.\n    \"\"\"\n    res = requests.get(f\"{self.base_url}?action=raw\")\n    return res.text\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.sanitize_text","title":"<code>sanitize_text(text)</code>","text":"<p>General method to sanitize text by removing translation tags, comments, and other non-essential markup.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be sanitized.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The sanitized text.</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def sanitize_text(self, text: str) -&gt; str:\n    \"\"\"\n    General method to sanitize text by removing translation tags, comments,\n    and other non-essential markup.\n\n    Args:\n        text (str): The text to be sanitized.\n\n    Returns:\n        str: The sanitized text.\n    \"\"\"\n    # Remove &lt;translate&gt;...&lt;/translate&gt; tags\n    text = re.sub(r\"&lt;translate&gt;(.*?)&lt;\\/translate&gt;\", r\"\\1\", text, flags=re.DOTALL)\n    # Remove &lt;!--T:...--&gt; tags\n    text = re.sub(r\"&lt;!--T:\\d+--&gt;\", \"\", text)\n    # Strip whitespace that might be left at the beginning and end\n    text = text.strip()\n    return text\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.save_to_json","title":"<code>save_to_json(file_path)</code>","text":"<p>Save the NamedQueryList to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the JSON file.</p> required Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def save_to_json(self, file_path: str):\n    \"\"\"\n    Save the NamedQueryList to a JSON file.\n\n    Args:\n       file_path (str): Path to the JSON file.\n    \"\"\"\n    self.named_query_list.save_to_json_file(file_path, indent=2)\n</code></pre>"},{"location":"#snapquery.wd_page_query_extractor.WikipediaQueryExtractor.store_queries","title":"<code>store_queries()</code>","text":"<p>Store the named queries into the database.</p> Source code in <code>snapquery/wd_page_query_extractor.py</code> <pre><code>def store_queries(self):\n    \"\"\"\n    Store the named queries into the database.\n    \"\"\"\n    self.nqm.store_named_query_list(self.named_query_list)\n</code></pre>"},{"location":"#snapquery.wd_short_url","title":"<code>wd_short_url</code>","text":"<p>Created on 2024-05-12</p> <p>@author: wf</p>"},{"location":"#snapquery.wd_short_url.ShortIds","title":"<code>ShortIds</code>","text":"<p>short id handling</p> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>class ShortIds:\n    \"\"\"\n    short id handling\n    \"\"\"\n\n    def __init__(\n        self,\n        base_chars: str = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz$\",\n    ):\n        self.base_chars = base_chars\n\n    def id_to_int(self, id_str: str) -&gt; int:\n        \"\"\"\n        Convert an ID string to an integer using my base character set.\n\n        Args:\n            id_str (str): The custom ID string to convert.\n\n        Returns:\n            int: The converted integer value.\n        \"\"\"\n        base = len(self.base_chars)\n        value = 0\n\n        for char in id_str:\n            value *= base\n            value += self.base_chars.index(char)\n\n        return value\n\n    def get_random(self, k: int = 4) -&gt; str:\n        \"\"\"\n        get a random short id\n\n        Returns:\n            str: a random short id\n        \"\"\"\n        short_id = \"\".join(random.choices(self.base_chars, k=k))\n        return short_id\n</code></pre>"},{"location":"#snapquery.wd_short_url.ShortIds.get_random","title":"<code>get_random(k=4)</code>","text":"<p>get a random short id</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a random short id</p> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>def get_random(self, k: int = 4) -&gt; str:\n    \"\"\"\n    get a random short id\n\n    Returns:\n        str: a random short id\n    \"\"\"\n    short_id = \"\".join(random.choices(self.base_chars, k=k))\n    return short_id\n</code></pre>"},{"location":"#snapquery.wd_short_url.ShortIds.id_to_int","title":"<code>id_to_int(id_str)</code>","text":"<p>Convert an ID string to an integer using my base character set.</p> <p>Parameters:</p> Name Type Description Default <code>id_str</code> <code>str</code> <p>The custom ID string to convert.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The converted integer value.</p> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>def id_to_int(self, id_str: str) -&gt; int:\n    \"\"\"\n    Convert an ID string to an integer using my base character set.\n\n    Args:\n        id_str (str): The custom ID string to convert.\n\n    Returns:\n        int: The converted integer value.\n    \"\"\"\n    base = len(self.base_chars)\n    value = 0\n\n    for char in id_str:\n        value *= base\n        value += self.base_chars.index(char)\n\n    return value\n</code></pre>"},{"location":"#snapquery.wd_short_url.ShortUrl","title":"<code>ShortUrl</code>","text":"<p>Handles operations related to wikidata and similar short URLs such as QLever. see https://meta.wikimedia.org/wiki/Wikimedia_URL_Shortener for</p> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>class ShortUrl:\n    \"\"\"\n    Handles operations related to wikidata and similar short URLs such as QLever.\n    see https://meta.wikimedia.org/wiki/Wikimedia_URL_Shortener for\n    \"\"\"\n    # see https://stackoverflow.com/questions/62396801/how-to-handle-too-many-requests-on-wikidata-using-sparqlwrapper\n    CALLS_PER_MINUTE = 30\n    ONE_MINUTE = 60\n\n    def __init__(self, short_url: str, scheme: str = \"https\", netloc: str = \"query.wikidata.org\"):\n        \"\"\"\n        Constructor\n\n        Args:\n            short_url (str): The URL to be processed.\n            scheme (str): URL scheme to be used (e.g., 'https' or 'http') for validating URL format.\n            netloc (str): Network location part of the URL, typically the domain name, to be used for validating URL format.\n        \"\"\"\n\n        self.short_url = short_url\n        self.scheme = scheme\n        self.netloc = netloc\n        self.url = None\n        self.sparql = None\n        self.error = None\n        self.user_agent = self.get_user_agent()\n\n    @staticmethod\n    def get_user_agent():\n        version = Version()\n        return f\"{version.name}/{version.version} ({version.cm_url}; {version.authors}) Python-requests/{requests.__version__}\"\n\n\n    @property\n    def name(self):\n        \"\"\"\n        Extracts and returns the name part of the short URL.\n\n        Returns:\n            str: The name part of the short URL.\n        \"\"\"\n        # Assuming the short URL ends with the name part after the last '/'\n        if self.short_url:\n            name_part = self.short_url.rsplit(\"/\", 1)[-1]\n            return name_part\n        return None\n\n    @classmethod\n    def get_prompt_text(cls, sparql: str) -&gt; str:\n        prompt_text = f\"\"\"give an english name, title and description in json \nfor cut &amp;paste for the SPARQL query below- the name should be less than 60 chars be a proper identifier which has no special chars so it can be used in an url without escaping. The title should be less than 80 chars and the \ndescription not more than three lines of 80 chars. \nA valid example result would be e.g.\n{{\n  \"name\": \"Locations_in_Rennes_with_French_Wikipedia_Article\"\n  \"title\": \"Locations in Rennes with a French Wikipedia Article\",\n  \"description\": \"Maps locations in Rennes linked to French Wikipedia articles. It displays entities within 10 km of Rennes' center, showing their names, coordinates, and linked Wikipedia pages. The results include entities' identifiers, coordinates, and related site links.\"\n}}\n\nThe example is just an example - do not use it's content if it does not match. \nAvoid  hallucinating and stick to the facts.\nIf the you can not determine a proper name, title and description return {{}}\nSPARQL: {sparql}\n\"\"\"\n        return prompt_text\n\n    @classmethod\n    def get_random_query_list(\n        cls,\n        namespace: str,\n        count: int,\n        max_postfix=\"9pfu\",\n        with_llm=False,\n        with_progress: bool = False,\n        debug=False,\n    ) -&gt; NamedQuerySet:\n        \"\"\"\n        Read a specified number of random queries from a list of short URLs.\n\n        Args:\n            namespace(str): the name to use for the named query list\n            count (int): Number of random URLs to fetch.\n            max_postfix(str): the maximum ID to try\n            with_progress(bool): if True show progress\n\n        Returns:\n            NamedQueryList: A NamedQueryList containing the queries read from the URLs.\n        \"\"\"\n        if with_llm:\n            llm = LLM(model=\"gpt-4\")\n        short_ids = ShortIds()\n        base_url = \"https://w.wiki/\"\n        unique_urls = set()\n        unique_names = set()\n\n        nq_set = NamedQuerySet(domain=\"wikidata.org\", namespace=namespace, target_graph_name=\"wikidata\")\n        give_up = (\n            count * 15\n        )  # heuristic factor for probability that a short url points to a wikidata entry - 14 has worked so far\n        max_short_int = short_ids.id_to_int(max_postfix)\n        while len(unique_urls) &lt; count and give_up &gt; 0:\n            if with_progress and not debug:\n                print(\".\", end=\"\")\n                if give_up % 80 == 0:\n                    print()\n            # Generate a 4-char base36 string\n            postfix = short_ids.get_random()\n            if short_ids.id_to_int(postfix) &gt; max_short_int:\n                continue\n            if debug:\n                print(f\"{give_up:4}:{postfix}\")\n            wd_short_url = f\"{base_url}{postfix}\"\n            short_url = cls(short_url=wd_short_url)\n            short_url.read_query()\n            if short_url.sparql and not short_url.error:\n                nq = NamedQuery(\n                    domain=nq_set.domain,\n                    name=postfix,\n                    namespace=nq_set.namespace,\n                    url=wd_short_url,\n                    sparql=short_url.sparql,\n                )\n                if with_llm:\n                    try:\n                        llm_response = llm.ask(cls.get_prompt_text(short_url.sparql))\n                        if llm_response:\n                            response_json = json.loads(llm_response)\n                            name = response_json.get(\"name\", None)\n                            if name in unique_names:\n                                # try again with a different url to avoid name clash\n                                give_up -= 1\n                                continue\n                            if name:\n                                nq.name = name\n                            title = response_json.get(\"title\", \"\")\n                            description = response_json.get(\"description\", \"\")\n                            nq.title = title\n                            nq.description = description\n                            nq.__post_init__()\n                    except Exception as ex:\n                        if debug:\n                            print(f\"Failed to get LLM response: {str(ex)}\")\n                        continue\n                nq_set.queries.append(nq)\n                unique_urls.add(nq.url)\n                unique_names.add(nq.name)\n                if debug:\n                    print(nq)\n            else:\n                give_up -= 1\n        return nq_set\n\n    @sleep_and_retry\n    @limits(calls=CALLS_PER_MINUTE, period=ONE_MINUTE)\n    def fetch_final_url(self):\n        \"\"\"\n        Follow the redirection to get the final URL with rate limiting.\n\n        Returns:\n            str: The final URL after redirection.\n        \"\"\"\n        try:\n            headers = {'User-Agent': self.user_agent}\n            response = requests.get(self.short_url, headers=headers, allow_redirects=True)\n            response.raise_for_status()\n            self.url = response.url\n        except Exception as ex:\n            self.error = ex\n        return self.url\n\n    def read_query(self) -&gt; str:\n        \"\"\"\n        Read a query from a short URL.\n\n        Returns:\n            str: The SPARQL query extracted from the short URL.\n        \"\"\"\n        self.fetch_final_url()\n        if self.url:\n            parsed_url = urllib.parse.urlparse(self.url)\n            if parsed_url.scheme == self.scheme and parsed_url.netloc == self.netloc:\n                if parsed_url.fragment:\n                    self.sparql = urllib.parse.unquote(parsed_url.fragment)\n                else:\n                    query_params = urllib.parse.parse_qs(parsed_url.query)\n                    if \"query\" in query_params:\n                        self.sparql = query_params[\"query\"][0]\n        return self.sparql\n</code></pre>"},{"location":"#snapquery.wd_short_url.ShortUrl.name","title":"<code>name</code>  <code>property</code>","text":"<p>Extracts and returns the name part of the short URL.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The name part of the short URL.</p>"},{"location":"#snapquery.wd_short_url.ShortUrl.__init__","title":"<code>__init__(short_url, scheme='https', netloc='query.wikidata.org')</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>short_url</code> <code>str</code> <p>The URL to be processed.</p> required <code>scheme</code> <code>str</code> <p>URL scheme to be used (e.g., 'https' or 'http') for validating URL format.</p> <code>'https'</code> <code>netloc</code> <code>str</code> <p>Network location part of the URL, typically the domain name, to be used for validating URL format.</p> <code>'query.wikidata.org'</code> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>def __init__(self, short_url: str, scheme: str = \"https\", netloc: str = \"query.wikidata.org\"):\n    \"\"\"\n    Constructor\n\n    Args:\n        short_url (str): The URL to be processed.\n        scheme (str): URL scheme to be used (e.g., 'https' or 'http') for validating URL format.\n        netloc (str): Network location part of the URL, typically the domain name, to be used for validating URL format.\n    \"\"\"\n\n    self.short_url = short_url\n    self.scheme = scheme\n    self.netloc = netloc\n    self.url = None\n    self.sparql = None\n    self.error = None\n    self.user_agent = self.get_user_agent()\n</code></pre>"},{"location":"#snapquery.wd_short_url.ShortUrl.fetch_final_url","title":"<code>fetch_final_url()</code>","text":"<p>Follow the redirection to get the final URL with rate limiting.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The final URL after redirection.</p> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>@sleep_and_retry\n@limits(calls=CALLS_PER_MINUTE, period=ONE_MINUTE)\ndef fetch_final_url(self):\n    \"\"\"\n    Follow the redirection to get the final URL with rate limiting.\n\n    Returns:\n        str: The final URL after redirection.\n    \"\"\"\n    try:\n        headers = {'User-Agent': self.user_agent}\n        response = requests.get(self.short_url, headers=headers, allow_redirects=True)\n        response.raise_for_status()\n        self.url = response.url\n    except Exception as ex:\n        self.error = ex\n    return self.url\n</code></pre>"},{"location":"#snapquery.wd_short_url.ShortUrl.get_random_query_list","title":"<code>get_random_query_list(namespace, count, max_postfix='9pfu', with_llm=False, with_progress=False, debug=False)</code>  <code>classmethod</code>","text":"<p>Read a specified number of random queries from a list of short URLs.</p> <p>Parameters:</p> Name Type Description Default <code>namespace(str)</code> <p>the name to use for the named query list</p> required <code>count</code> <code>int</code> <p>Number of random URLs to fetch.</p> required <code>max_postfix(str)</code> <p>the maximum ID to try</p> required <code>with_progress(bool)</code> <p>if True show progress</p> required <p>Returns:</p> Name Type Description <code>NamedQueryList</code> <code>NamedQuerySet</code> <p>A NamedQueryList containing the queries read from the URLs.</p> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>@classmethod\ndef get_random_query_list(\n    cls,\n    namespace: str,\n    count: int,\n    max_postfix=\"9pfu\",\n    with_llm=False,\n    with_progress: bool = False,\n    debug=False,\n) -&gt; NamedQuerySet:\n    \"\"\"\n    Read a specified number of random queries from a list of short URLs.\n\n    Args:\n        namespace(str): the name to use for the named query list\n        count (int): Number of random URLs to fetch.\n        max_postfix(str): the maximum ID to try\n        with_progress(bool): if True show progress\n\n    Returns:\n        NamedQueryList: A NamedQueryList containing the queries read from the URLs.\n    \"\"\"\n    if with_llm:\n        llm = LLM(model=\"gpt-4\")\n    short_ids = ShortIds()\n    base_url = \"https://w.wiki/\"\n    unique_urls = set()\n    unique_names = set()\n\n    nq_set = NamedQuerySet(domain=\"wikidata.org\", namespace=namespace, target_graph_name=\"wikidata\")\n    give_up = (\n        count * 15\n    )  # heuristic factor for probability that a short url points to a wikidata entry - 14 has worked so far\n    max_short_int = short_ids.id_to_int(max_postfix)\n    while len(unique_urls) &lt; count and give_up &gt; 0:\n        if with_progress and not debug:\n            print(\".\", end=\"\")\n            if give_up % 80 == 0:\n                print()\n        # Generate a 4-char base36 string\n        postfix = short_ids.get_random()\n        if short_ids.id_to_int(postfix) &gt; max_short_int:\n            continue\n        if debug:\n            print(f\"{give_up:4}:{postfix}\")\n        wd_short_url = f\"{base_url}{postfix}\"\n        short_url = cls(short_url=wd_short_url)\n        short_url.read_query()\n        if short_url.sparql and not short_url.error:\n            nq = NamedQuery(\n                domain=nq_set.domain,\n                name=postfix,\n                namespace=nq_set.namespace,\n                url=wd_short_url,\n                sparql=short_url.sparql,\n            )\n            if with_llm:\n                try:\n                    llm_response = llm.ask(cls.get_prompt_text(short_url.sparql))\n                    if llm_response:\n                        response_json = json.loads(llm_response)\n                        name = response_json.get(\"name\", None)\n                        if name in unique_names:\n                            # try again with a different url to avoid name clash\n                            give_up -= 1\n                            continue\n                        if name:\n                            nq.name = name\n                        title = response_json.get(\"title\", \"\")\n                        description = response_json.get(\"description\", \"\")\n                        nq.title = title\n                        nq.description = description\n                        nq.__post_init__()\n                except Exception as ex:\n                    if debug:\n                        print(f\"Failed to get LLM response: {str(ex)}\")\n                    continue\n            nq_set.queries.append(nq)\n            unique_urls.add(nq.url)\n            unique_names.add(nq.name)\n            if debug:\n                print(nq)\n        else:\n            give_up -= 1\n    return nq_set\n</code></pre>"},{"location":"#snapquery.wd_short_url.ShortUrl.read_query","title":"<code>read_query()</code>","text":"<p>Read a query from a short URL.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The SPARQL query extracted from the short URL.</p> Source code in <code>snapquery/wd_short_url.py</code> <pre><code>def read_query(self) -&gt; str:\n    \"\"\"\n    Read a query from a short URL.\n\n    Returns:\n        str: The SPARQL query extracted from the short URL.\n    \"\"\"\n    self.fetch_final_url()\n    if self.url:\n        parsed_url = urllib.parse.urlparse(self.url)\n        if parsed_url.scheme == self.scheme and parsed_url.netloc == self.netloc:\n            if parsed_url.fragment:\n                self.sparql = urllib.parse.unquote(parsed_url.fragment)\n            else:\n                query_params = urllib.parse.parse_qs(parsed_url.query)\n                if \"query\" in query_params:\n                    self.sparql = query_params[\"query\"][0]\n    return self.sparql\n</code></pre>"}]}