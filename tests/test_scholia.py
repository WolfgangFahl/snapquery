"""
Created on 2024-05-04

@author: wf
"""
import re
import os
from typing import Dict,List, Any
from pathlib import Path
import unittest
from lodstorage.params import Param
from basemkit.basetest import Basetest
from lodstorage.query import Query
from snapquery.scholia import ScholiaQueries, GitHubQueries
from snapquery.snapquery_core import NamedQueryManager, NamedQuerySet, \
    NamedQuery


class QueryParameterizer:
    """
    Parameterizer for Scholia Query Sets.
    Transforms Jinja2-based Scholia templates into standard
    LoDStorage Parameterized Queries.
    """
    def __init__(self,debug:bool=False):
        self.debug=debug

    # Replacement for Scholia's label macro
    LABEL_SERVICE = 'SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }'

    def _infer_param_details(self, var_name: str) -> Dict[str, Any]:
        """
        Heuristics to determine type and default value based on variable name.
        """
        details = {"type": "string", "default": "Q80"}

        if var_name in ['q', 'target', 'item', 'person', 'work']:
            details["type"] = "WikidataItem"
            details["default"] = "Q80" # Tim Berners-Lee
        elif var_name in ['p', 'property']:
            details["type"] = "WikidataProperty"
            details["default"] = "P31"
        elif var_name in ['limit']:
            details["type"] = "int"
            details["default"] = 10
        elif var_name in ['lang', 'language']:
            details["type"] = "string"
            details["default"] = "en"

        return details

    def parameterize_query_set(self, query_set: NamedQuerySet) -> List[Query]:
        """
        Parameterize the given query set to produce a list of LoDStorage queries.

        Args:
            query_set (NamedQuerySet): The set of named queries to transform.

        Returns:
            List[Query]: A list of transformed LoDStorage Query objects.
        """
        query_list = []
        for nq in query_set.queries:
            query = self.parameterize_query(nq)
            query_list.append(query)
        return query_list

    def parameterize_query(self, nq: NamedQuery) -> Query:
        """
        Parameterize a single named query.

        1. Cleans Jinja2 specific imports.
        2. Replaces Scholia Macros (sparql_helpers) with standard SPARQL.
        3. Detects variables and creates Param objects.

        Args:
            nq (NamedQuery): The named query input.

        Returns:
            Query: The transformed LoDStorage Query object.
        """
        raw_sparql = nq.sparql

        # 1. Remove Jinja imports
        # e.g., {% import 'sparql-helpers.sparql' as sparql_helpers -%}
        txt = re.sub(r'\{%\s*import\s*.*?%\}', '', raw_sparql, flags=re.DOTALL)

        # 2. Replace Label/Description Macros
        # Matches: {{ sparql_helpers.labels(["?mol"], languages) }}
        txt = re.sub(
            r"\{\{\s*sparql_helpers\.(labels|descriptions).*?\}\}",
            self.LABEL_SERVICE,
            txt,
            flags=re.DOTALL
        )

        # 3. Detect Variables to build Param list
        # Look for {{ var }} patterns.
        # Note: We keep the {{ }} syntax or convert to { } depending on how
        # the storage engine handles format(), but here we focus on extraction.
        found_vars = set(re.findall(r"\{\{\s*([a-zA-Z0-9_]+)\s*\}\}", txt))
        found_vars.discard('sparql_helpers') # Ensure module names aren't params

        # Create lodstorage Query object
        # We strip surrounding whitespace generated by Jinja removals
        clean_sparql = txt.strip()

        query_obj = Query(
            name=nq.name,
            query=clean_sparql,
            title=nq.title,
            description=nq.description,
            lang='sparql'
        )

        # 4. Attach Parameters
        # Currently lodstorage Query doesn't have a direct 'params' list in __init__,
        # usually it's handled via a dict or external management.
        # However, we can use the `params` attribute if we wish to store metadata.
        # We will create a list of Param objects.

        param_list = []
        for var in sorted(found_vars):
            details = self._infer_param_details(var)
            p = Param(
                name=var,
                type=details["type"],
                default_value=details["default"]
            )
            param_list.append(p)

        # Store params in the query object for subsequent usage/testing
        # (This assumes the Query object is dynamic or we tack it on)
        query_obj.param_list = param_list

        return query_obj


class TestScholia(Basetest):
    """
    test scholia queries
    """

    def setUp(self, debug=True, profile=True):
        Basetest.setUp(self, debug=debug, profile=profile)
        self.samples_dir = Path(__file__).parent.parent / "snapquery" / "samples" / "query-sets" / "yaml"

    def prepare_nqm(self,prefix:str):
        self.prefix=prefix
        db_path = f"/tmp/{self.prefix}_queries.db"
        if os.path.exists(db_path):
            os.remove(db_path)
        # Adjust limit based on environment (e.g., CI)
        if self.inPublicCI():
            self.limit = 10
        else:
            self.limit = None
            # limit=10
        # Create a NamedQueryManager and ScholiaQueries instance
        self.nqm = NamedQueryManager.from_samples(db_path=db_path)

    def check_queries(self,queries,):
        queries.store_queries()
        queries.save_to_json(f"/tmp/{self.prefix}.json")

        # Verify the data was stored
        records = self.nqm.sql_db.query(
            f"""SELECT *
FROM NamedQuery
WHERE namespace='{queries.named_query_set.namespace}'
AND domain='{queries.named_query_set.domain}'
"""
        )
        self.assertEqual(len(records), len(queries.named_query_set.queries))


    @unittest.skipIf(Basetest.inPublicCI(), "avoid github rate limit")
    def test_scholia_queries(self):
        """
        Test retrieving Scholia queries.
        """
        prefix="scholia"
        nqm=self.prepare_nqm(prefix)
        scholia_queries = ScholiaQueries(nqm, debug=self.debug)

        # Extract, store, and save queries to JSON
        scholia_queries.extract_queries(limit=self.limit)
        self.check_queries(scholia_queries)

    @unittest.skipIf(Basetest.inPublicCI(), "avoid github rate limit")
    def test_scholia_qlever(self):
        """
        Test retrieving Scholia QLever queries from the specific branch.
        """
        prefix = "scholia_qlever"
        nqm = self.prepare_nqm(prefix)

        # Configure for ad-freiburg/scholia branch:qlever
        scholia_qlever = ScholiaQueries(
            nqm,
            owner="ad-freiburg",
            repo="scholia",
            branch="qlever",
            namespace="named_queries_qlever",
            debug=self.debug
        )

        scholia_qlever.extract_queries(limit=self.limit)
        self.check_queries(scholia_qlever)

    def test_parameterizing_queries(self):
        """
        test parameterizing scholia queries
        """
        debug=self.debug
        debug=True
        iso_date = "2025-12-16"
        parameterizer = QueryParameterizer(debug=debug)
        for tag in ["scholia","scholia-qlever"]:
            yaml_file=f"{tag}-{iso_date}.yaml"
            yaml_path = self.samples_dir / yaml_file
            query_set=NamedQuerySet.load_from_yaml_file(yaml_path) # @UndefinedVariable
            query_count=len(query_set.queries)
            if debug:
                print(f"Parameterizing {query_count} {tag} queries")
            pquery_list=parameterizer.parameterize_query_set(query_set)
            self.assertEqual(len(pquery_list), query_count)
            if debug:
                for i,query in enumerate(pquery_list):
                    print(f"{i}:{query.to_yaml()}")

    @unittest.skipIf(Basetest.inPublicCI(), "avoid github rate limit")
    def test_exploratory_querying_sessions(self):
        owner = "hartig"
        repo= "ExploratoryQueryingSessions"
        path= "/sessions"
        extension = ".rq"
        limit = 5
        prefix="hartig_eqs"
        self.prepare_nqm(prefix)
        show_progress=self.debug
        show_progress=True
        hartig_queries = GitHubQueries(self.nqm, owner=owner,repo=repo, path=path,extension=extension, debug=self.debug)
        hartig_queries.extract_queries(limit=limit, show_progress=show_progress)
        self.check_queries(hartig_queries)

